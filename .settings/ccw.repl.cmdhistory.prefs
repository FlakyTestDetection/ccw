#Fri Aug 05 13:43:01 CEST 2011
cmdhistory=["(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"&\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"`o\\")" "(sexp \\"o\#\\")" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"\\")" "(sexp \\"\:sdf\#sdf\\")" "(sexp \\"^\\")" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r (comment [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ])]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "^" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r (comment [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ])]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"^\\")" "(clojure.core/in-ns 'paredit.tests)\\n[\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"3/\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"3/\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"\\n             \\"\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\:[\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!]))\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol ; \\"\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])\\"\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!]))\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol ; \\"\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])\\"\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" ";; Loading file src/paredit/parser.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.parser\\\\n  (\:use clojure.test)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:use paredit.regex-utils)\\\\n\\\\t(\:require [clojure.zip \:as zip])\\\\n  (\:require [clojure.contrib.zip-filter \:as zf])\\\\n  (\:use net.cgrand.parsley)\\\\n  (\:require [net.cgrand.parsley.lrplus \:as lr+])\\\\n  (\:require [net.cgrand.regex \:as r]))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n(defn aaa \\\\\\"abc (ns ...)\\\\\\" [])\\\\n(def *brackets-tags* \#{\:list \:map \:vector \:string \:set \:fn \:regex})\\\\n(def *tag-closing-brackets* {\:list \\\\\\")\\\\\\", \:map \\\\\\"}\\\\\\", \:vector \\\\\\"]\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"}\\\\\\", \:fn \\\\\\")\\\\\\"})\\\\n(def *tag-opening-brackets* {\:list \\\\\\"(\\\\\\", \:map \\\\\\"{\\\\\\", \:vector \\\\\\"[\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"\#{\\\\\\", \:fn \\\\\\"\#(\\\\\\"})\\\\n(def *atom* \#{\:symbol \:keyword \:int \:float \:ratio \:anon-arg})\\\\n(aaa)\\\\n\#_(def ^{\:private true} *brackets* {\\\\\\"(\\\\\\" \\\\\\")\\\\\\", \\\\\\"{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"[\\\\\\" \\\\\\"]\\\\\\", \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"\#(\\\\\\" \\\\\\")\\\\\\"})\\\\n\#_(def ^{\:private true} *opening-bracket-tags* {\\\\\\"(\\\\\\" \:list, \\\\\\"{\\\\\\" \:map, \\\\\\"[\\\\\\" \:vector, \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \:string, \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \:regex, \\\\\\"\#{\\\\\\" \:set, \\\\\\"\#(\\\\\\" \:fn})\\\\n\#_(def ^{\:private true} *opening-brackets* (set (keys *brackets*)))\\\\n\#_(def ^{\:private true} *closing-brackets* (set (vals *brackets*)))\\\\n\#_(def ^{\:private true} *spaces* \#{(str \\\\\\\\space) (str \\\\\\\\tab) (str \\\\\\\\newline) (str \\\\\\\\return) (str \\\\\\\\,)})\\\\n\#_(def *atoms* (conj *atom* \:whitespace))\\\\n\\\\n(defn eof [s eof?]\\\\n  (when (and (\= 0 (.length s)) eof?) [0 eof]))\\\\n\\\\n(defn bracket-end [s eof?]\\\\n  (lr+/match \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof} s eof?))\\\\n\\\\n(def gspaces \#{\:whitespace \:comment \:discard})\\\\n(def only-code (partial remove (comp gspaces \:tag)))\\\\n(defn code-children [e] (only-code (\:content e)))\\\\n(defn sym-name\\\\n  \\\\\\"returns the symbol name\\\\\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))\\\\n(defn call-of [e c] (and (\#{\\\\\\"(\\\\\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))\\\\n(defn call-args [e] (-> (code-children e) nnext butlast))\\\\n(defn form \\\\n  \\\\\\"removes the meta(s) to get to the form\\\\\\" \\\\n  [e]\\\\n  (if-not (\#{\:meta} (\:tag e))\\\\n    e\\\\n    (recur (nth (code-children e) 2))))\\\\n\\\\n(def open-list \\\\\\"(\\\\\\")\\\\n(def open-vector \\\\\\"[\\\\\\")\\\\n(def open-map \\\\\\"{\\\\\\")\\\\n(def open-set \\\\\\"\#{\\\\\\")\\\\n(def open-quote \\\\\\\\')\\\\n(def open-meta \\\\\\"^\\\\\\")\\\\n(def open-deref \\\\\\\\@)         ;\\\\\\"\#(?\:[\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\" \\\\n(def open-syntax-quote \\\\\\\\`)\\\\n(def open-fn \\\\\\"\#(\\\\\\")\\\\n(def open-var \\\\\\"\#'\\\\\\")\\\\n(def open-deprecated-meta \\\\\\"\#^\\\\\\")\\\\n(def open-string \\\\\\\\\\\\\\")\\\\n(def open-regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\")\\\\n(def open-unquote-splicing \\\\\\"~@\\\\\\")\\\\n(def open-unquote \#\\\\\\"~(?\!@)\\\\\\")\\\\n(def open-anon-arg \\\\\\"%\\\\\\")\\\\n(def open-keyword \#\\\\\\"\:{1,2}\\\\\\")\\\\n(def open-discard \\\\\\"\#_\\\\\\")\\\\n(def whitespace \#\\\\\\"(?\:,|\\\\\\\\s)+\\\\\\")\\\\n(def open-comment \#\\\\\\"(?\:\\\\\\\\\#\\\\\\\\\!|;)\\\\\\")\\\\n(def open-char \\\\\\"\\\\\\\\\\\\\\\\\\\\\\")\\\\n(def symbol-exclusion \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\\!\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`;0-9]\\\\\\")\\\\n(def ^{\:private true} prefixes\\\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\\\n    open-char})\\\\n(def sexp\\\\n  (parser {\:root-tag \:root\\\\n           \:main \:expr*\\\\n           \:space (unspaced gspaces \:*)}\\\\n    \:expr- \#{\\\\n             \:list\\\\n             \:vector\\\\n             \:map\\\\n             \:set\\\\n             \:quote\\\\n             \:meta\\\\n             \:deref\\\\n             \:syntax-quote\\\\n             \:var\\\\n             \:fn\\\\n             \:deprecated-meta\\\\n             \:unquote-splicing\\\\n             \:unquote\\\\n             \:string\\\\n             \:regex\\\\n             \:symbol \\\\n             \:keyword \\\\n             \:int \\\\n             \:float \\\\n             \:ratio \\\\n             \:anon-arg\\\\n             \:char\\\\n             \:chimera\\\\n             }\\\\n    \:list [open-list \:expr* \\\\\\")\\\\\\"]\\\\n    \:chimera \#{ [open-list  \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}] \\\\n                [open-vector  \:expr* \#{\\\\\\")\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-map \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                [open-fn \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-set \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                }\\\\n    \:vector [open-vector \:expr* \\\\\\"]\\\\\\"]\\\\n    \:map [open-map \:expr* \\\\\\"}\\\\\\"]\\\\n    \:set [open-set \:expr* \\\\\\"}\\\\\\"]\\\\n    \:quote [open-quote \:expr]\\\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\\\n    \:deref [open-deref \:expr]\\\\n    \:syntax-quote [open-syntax-quote \:expr]\\\\n    \:var [open-var \:expr]\\\\n    \:fn [open-fn \:expr* \\\\\\")\\\\\\"]\\\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\\\n    \:unquote [open-unquote \:expr]\\\\n    \:string (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:regex  (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:symbol ; \\\\\\"\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\"\\\\n      \#\\\\\\"(?\:[\\\\\\\\-\\\\\\\\+](?\![0-9])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)|(?\:[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}\\\\\\\\-\\\\\\\\+;0-9][^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*|\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)\#?\\\\\\"\\\\n    \:keyword (unspaced open-keyword \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\{\\\\\\\\'\\\\\\\\^\\\\\\\\@\\\\\\\\`\\\\\\\\~\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\)\\\\\\\\]\\\\\\\\}]*\\\\\\"); factorize with symbol\\\\n    \:int \#\\\\\\"(?\:[-+]?(?\:0(?\!\\\\\\\\.)|[1-9][0-9]*+(?\!\\\\\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\\\\\.)|0[0-7]+(?\!\\\\\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\\\\\.)|0[0-9]+(?\!\\\\\\\\.))(?\!/))\\\\\\"\\\\n    \:ratio \#\\\\\\"[-+]?[0-9]+/[0-9]*\\\\\\"\\\\n    \:float \#\\\\\\"[-+]?[0-9]+\\\\\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\\\\\"\\\\n    \:anon-arg (unspaced open-anon-arg \#\\\\\\"(?\:[0-9|\\\\\\\\&])?+\\\\\\")\\\\n    \:char (unspaced open-char \#\\\\\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\\\\\")\\\\n    \:whitespace whitespace\\\\n    \:comment (unspaced open-comment \#\\\\\\"[^\\\\\\\\n]*\\\\\\")\\\\n    \:discard [open-discard \:expr]\\\\n    ))\\\\n\\\\n(defn parse\\\\n  ([^String text]\\\\n    (sexp text))\\\\n  ([^String text offset]\\\\n    (sexp text)))\\\\n\\\\n(defn parse-tree\\\\n  [state]\\\\n  state)\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/parser.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(def a [[1 2 3]\\n       [4 5 6]\\n       [7 8 9]])" "(map vector a)" "(apply map vector a)" "(vec (apply map vector a))" ";; Loading file src/paredit/parser.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.parser\\\\n  (\:use clojure.test)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:use paredit.regex-utils)\\\\n\\\\t(\:require [clojure.zip \:as zip])\\\\n  (\:require [clojure.contrib.zip-filter \:as zf])\\\\n  (\:use net.cgrand.parsley)\\\\n  (\:require [net.cgrand.parsley.lrplus \:as lr+])\\\\n  (\:require [net.cgrand.regex \:as r]))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n(defn get-in-2 [] 10)\\\\n\\\\n(defn usage [] (get-in-2))\\\\n\\\\n\\\\n(def *brackets-tags* \#{\:list \:map \:vector \:string \:set \:fn \:regex})\\\\n(def *tag-closing-brackets* {\:list \\\\\\")\\\\\\", \:map \\\\\\"}\\\\\\", \:vector \\\\\\"]\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"}\\\\\\", \:fn \\\\\\")\\\\\\"})\\\\n(def *tag-opening-brackets* {\:list \\\\\\"(\\\\\\", \:map \\\\\\"{\\\\\\", \:vector \\\\\\"[\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"\#{\\\\\\", \:fn \\\\\\"\#(\\\\\\"})\\\\n(def *atom* \#{\:symbol \:keyword \:int \:float \:ratio \:anon-arg})\\\\n\\\\n\#_(def ^{\:private true} *brackets* {\\\\\\"(\\\\\\" \\\\\\")\\\\\\", \\\\\\"{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"[\\\\\\" \\\\\\"]\\\\\\", \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"\#(\\\\\\" \\\\\\")\\\\\\"})\\\\n\#_(def ^{\:private true} *opening-bracket-tags* {\\\\\\"(\\\\\\" \:list, \\\\\\"{\\\\\\" \:map, \\\\\\"[\\\\\\" \:vector, \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \:string, \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \:regex, \\\\\\"\#{\\\\\\" \:set, \\\\\\"\#(\\\\\\" \:fn})\\\\n\#_(def ^{\:private true} *opening-brackets* (set (keys *brackets*)))\\\\n\#_(def ^{\:private true} *closing-brackets* (set (vals *brackets*)))\\\\n\#_(def ^{\:private true} *spaces* \#{(str \\\\\\\\space) (str \\\\\\\\tab) (str \\\\\\\\newline) (str \\\\\\\\return) (str \\\\\\\\,)})\\\\n\#_(def *atoms* (conj *atom* \:whitespace))\\\\n\\\\n(defn eof [s eof?]\\\\n  (when (and (\= 0 (.length s)) eof?) [0 eof]))\\\\n\\\\n(defn bracket-end [s eof?]\\\\n  (lr+/match \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof} s eof?))\\\\n\\\\n(def gspaces \#{\:whitespace \:comment \:discard})\\\\n(def only-code (partial remove (comp gspaces \:tag)))\\\\n(defn code-children [e] (only-code (\:content e)))\\\\n(defn sym-name\\\\n  \\\\\\"returns the symbol name\\\\\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))\\\\n(defn call-of [e c] (and (\#{\\\\\\"(\\\\\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))\\\\n(defn call-args [e] (-> (code-children e) nnext butlast))\\\\n(defn form \\\\n  \\\\\\"removes the meta(s) to get to the form\\\\\\" \\\\n  [e]\\\\n  (if-not (\#{\:meta} (\:tag e))\\\\n    e\\\\n    (recur (nth (code-children e) 2))))\\\\n\\\\n(def open-list \\\\\\"(\\\\\\")\\\\n(def open-vector \\\\\\"[\\\\\\")\\\\n(def open-map \\\\\\"{\\\\\\")\\\\n(def open-set \\\\\\"\#{\\\\\\")\\\\n(def open-quote \\\\\\\\')\\\\n(def open-meta \\\\\\"^\\\\\\")\\\\n(def open-deref \\\\\\\\@)         ;\\\\\\"\#(?\:[\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\" \\\\n(def open-syntax-quote \\\\\\\\`)\\\\n(def open-fn \\\\\\"\#(\\\\\\")\\\\n(def open-var \\\\\\"\#'\\\\\\")\\\\n(def open-deprecated-meta \\\\\\"\#^\\\\\\")\\\\n(def open-string \\\\\\\\\\\\\\")\\\\n(def open-regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\")\\\\n(def open-unquote-splicing \\\\\\"~@\\\\\\")\\\\n(def open-unquote \#\\\\\\"~(?\!@)\\\\\\")\\\\n(def open-anon-arg \\\\\\"%\\\\\\")\\\\n(def open-keyword \#\\\\\\"\:{1,2}\\\\\\")\\\\n(def open-discard \\\\\\"\#_\\\\\\")\\\\n(def whitespace \#\\\\\\"(?\:,|\\\\\\\\s)+\\\\\\")\\\\n(def open-comment \#\\\\\\"(?\:\\\\\\\\\#\\\\\\\\\!|;)\\\\\\")\\\\n(def open-char \\\\\\"\\\\\\\\\\\\\\\\\\\\\\")\\\\n(def symbol-exclusion \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\\!\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`;0-9]\\\\\\")\\\\n(def ^{\:private true} prefixes\\\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\\\n    open-char})\\\\n(def sexp\\\\n  (parser {\:root-tag \:root\\\\n           \:main \:expr*\\\\n           \:space (unspaced gspaces \:*)}\\\\n    \:expr- \#{\\\\n             \:list\\\\n             \:vector\\\\n             \:map\\\\n             \:set\\\\n             \:quote\\\\n             \:meta\\\\n             \:deref\\\\n             \:syntax-quote\\\\n             \:var\\\\n             \:fn\\\\n             \:deprecated-meta\\\\n             \:unquote-splicing\\\\n             \:unquote\\\\n             \:string\\\\n             \:regex\\\\n             \:symbol \\\\n             \:keyword \\\\n             \:int \\\\n             \:float \\\\n             \:ratio \\\\n             \:anon-arg\\\\n             \:char\\\\n             \:chimera\\\\n             }\\\\n    \:list [open-list \:expr* \\\\\\")\\\\\\"]\\\\n    \:chimera \#{ [open-list  \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}] \\\\n                [open-vector  \:expr* \#{\\\\\\")\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-map \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                [open-fn \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-set \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                }\\\\n    \:vector [open-vector \:expr* \\\\\\"]\\\\\\"]\\\\n    \:map [open-map \:expr* \\\\\\"}\\\\\\"]\\\\n    \:set [open-set \:expr* \\\\\\"}\\\\\\"]\\\\n    \:quote [open-quote \:expr]\\\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\\\n    \:deref [open-deref \:expr]\\\\n    \:syntax-quote [open-syntax-quote \:expr]\\\\n    \:var [open-var \:expr]\\\\n    \:fn [open-fn \:expr* \\\\\\")\\\\\\"]\\\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\\\n    \:unquote [open-unquote \:expr]\\\\n    \:string (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:regex  (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:symbol ; \\\\\\"\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\"\\\\n      \#\\\\\\"(?\:[\\\\\\\\-\\\\\\\\+](?\![0-9])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)|(?\:[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}\\\\\\\\-\\\\\\\\+;0-9][^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*|\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)\#?\\\\\\"\\\\n    \:keyword (unspaced open-keyword \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\{\\\\\\\\'\\\\\\\\^\\\\\\\\@\\\\\\\\`\\\\\\\\~\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\)\\\\\\\\]\\\\\\\\}]*\\\\\\"); factorize with symbol\\\\n    \:int \#\\\\\\"(?\:[-+]?(?\:0(?\!\\\\\\\\.)|[1-9][0-9]*+(?\!\\\\\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\\\\\.)|0[0-7]+(?\!\\\\\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\\\\\.)|0[0-9]+(?\!\\\\\\\\.))(?\!/))\\\\\\"\\\\n    \:ratio \#\\\\\\"[-+]?[0-9]+/[0-9]*\\\\\\"\\\\n    \:float \#\\\\\\"[-+]?[0-9]+\\\\\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\\\\\"\\\\n    \:anon-arg (unspaced open-anon-arg \#\\\\\\"(?\:[0-9|\\\\\\\\&])?+\\\\\\")\\\\n    \:char (unspaced open-char \#\\\\\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\\\\\")\\\\n    \:whitespace whitespace\\\\n    \:comment (unspaced open-comment \#\\\\\\"[^\\\\\\\\n]*\\\\\\")\\\\n    \:discard [open-discard \:expr]\\\\n    ))\\\\n\\\\n(defn parse\\\\n  ([^String text]\\\\n    (sexp text))\\\\n  ([^String text offset]\\\\n    (sexp text)))\\\\n\\\\n(defn parse-tree\\\\n  [state]\\\\n  state)\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/parser.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(map (fn [c1 c2 c3] [c1 c2 c3]) [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3])" "(map vector [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3])\\n([\:c1.1 \:c2.1 \:c3.1] [\:c1.2 \:c2.2 \:c3.2] [\:c1.3 \:c2.3 \:c3.3])" "(map vector [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3])" "(apply map vector (list [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3]))" "(let [users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\")]\\n(firs users)\\n)" "(let [users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\")]\\n(first users)\\n)" "(let [users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\")]\\n(-> users \:content \:first)\\n)" "(def users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\"))" "users" "(-> users \:content first)" "'(require 'paredit.parser)" "'(in-ns 'paredit.parser)" "(in-ns 'paredit.parser)" "(require 'paredit.tests)" "(in-ns 'p.t)" "(in-ns 'paredit.tests)" "(pts)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(clojure.core/in-ns 'paredit.parser)\\n(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr*]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol ; \\"\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])\\"\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))\\n(clojure.core/in-ns 'paredit.tests)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(run-tests)" "(pts)" "(-> sexp \\"(salut)\\" pprint)" "(-> \\"(salut)\\" sexp  pprint)" ";; Switching to paredit.parser namespace" "(-> \\"(salut)\\" sexp  pprint)" "(use 'paredit.loc-utils)" "(-> \\"(salut)\\" sexp  node-text)" "step" "lr+/step" "lr+/reset" "reset" "(-> \\"(salut)\\" lr+/step)" "(def d [\\"(defn foo [bar\\", \\"           baz]\\" \\"  \\\\\\"hello\\\\\\")\\"])" "d" "(defn dser-ser [d] (-> (s/join \\"\\\\n\\" d) sexp node-text))" "(require '[clojure.string \:as s])" "(defn dser-ser [d] (-> (s/join \\"\\\\n\\" d) sexp node-text))" "(dser-ser d)" "(print (dser-ser d))" "d" "(def d0 (first d))" "d0" "(-> d0 (sexp zero d0) )" "(-> d0 (sexp lr+/zero d0) )" "(->> d0 (sexp lr+/zero) )" "(->> d0 (sexp lr+/zero) stitch)" "(let [a (sexp d0 lr+/zero)\\n      b (sexp a nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (lr+/stich a b))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (lr+/stitch a b))" "(require '[net.cgrand.parsley.fold \:as f])" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "step" "lr+/step" "(lr+/step d0)" "(lr+/step sexp d0)" "(lr+/step sexp lr+/zero d0)" "(sexp d0)" "(def d1 (second d))" "(sexp lr+/zero d0)" "(let [a (sexp lr+/zero d0)\\n      b (sexp d0 nil)]\\n  (f/stitch a b))" "(let [a (sexp lr+/zero d0)\\n      b (sexp d0 nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/make-node (f/stitch a b)))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/make-node sexp (f/stitch a b)))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(def d0 \\"(\\\\n\\")" "(def d1 \\")\\")" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(require '[net.cgrand.parsley.lrplus \:as lr+])" "(require '[net.cgrand.parsley.fold \:as f])" "(require '[net.cgrand.parsley.lrplus \:as l])" "(require '[net.cgrand.parsley.fold \:as f])" "(def d0 \\"(\\\\n\\")" "(def d1 \\")\\")" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(require '[net.cgrand.parsley.lrplus \:as l])" "(require '[net.cgrand.parsley.fold \:as f])" "(def d0 \\"(\\\\n\\")" "(def d1 \\")\\")" "(let [a (sexp l/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(let [a (sexp l/zero d0)\\n      b (sexp a d1)\\n      c (sexp b nil)]\\n  (f/stitch (f/stitch a b) c))" "(let [a (sexp l/zero d0)\\n      b (sexp a d1)\\n      c (sexp b nil)]\\n  (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2)))" "(let [a (sexp l/zero d0)\\n      b (sexp a d1)\\n      c (sexp b nil)]\\n  (node-text (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "d" "(dser-ser d)" "(defn dser-ser-inc [d] nil)" "(dser-ser-inc d)" "(doc reductions\\n  )" "(peek [1 2])" "(defn dser-ser-inc [d]\\n  (let [steps (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [] (concat [l/zero] d nil))]\\n    steps))" "(dser-ser-inc d)" "(concat [l/zero] d nil)" "(concat [l/zero] d [nil])" "(defn dser-ser-inc [d]\\n  (let [steps (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [] (concat [l/zero] d [nil]))]\\n    steps))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [] (concat [l/zero] d [nil])))]\\n    steps))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))]\\n    steps))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    stitch))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (f/make-node \:root (nth stitch 2))))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (node-text (f/make-node \:root (nth stitch 2)))))" "(dser-ser-inc d)" "(deftest assert-incremental (is (\= (dser-ser d) (dser-ser-inc d))))" "(assert-incremental)" "d" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (node-text (f/make-node \:root (nth stitch 2)))))" "d" "(def d [\\"([\\" \\"])\\"])" "(assert-incremental)" "(def d [\\"([\\" \\"]) \\"])" "(assert-incremental)" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (f/make-node \:root (nth stitch 2))))" "(dser-ser-inc d)" "(defn dser-ser [d] (-> (s/join \\"\\\\n\\" d) sexp))" "(dser-ser d)" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\"])\\")\\n      c (sexp b      nil)]\\n  (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2)))" "(def sexp (parser {\:main \:expr*} \:expr- \#{\:list \:vector}, \:list [\\"(\\" \:expr* \\")\\"], \:vector [\\"[\\" \:expr* \\"]\\"]))" "(sexp \\"([])\\")" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\"])\\")\\n      c (sexp b      nil)]\\n  (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2)))" "(def sexp (parser {\:main \:expr*} \\n                  \:expr- \#{\:list \:vector}, \\n                  \:list [\\"(\\" \:expr* \\")\\"], \\n                  \:vector [\\"[\\" \:expr* \\"]\\"]))" "(pprint (sexp \\"([])\\"))" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\"])\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\")\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"(\\")\\n      b (sexp a      \\")\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"((\\")\\n      b (sexp a      \\"))\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]))\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch (f/stitch a b) c) nil) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]\\")\\n      c (sexp b      nil)]\\n  (f/stitch (f/stitch a b) c))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"salut\\")" "(sexp \\"]\\")" "(sexp \\"\\\\\\"\\")" "(sexp \\"]\\")" "(sexp \\"[]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" "(sexp \\"[]\\")" ";; Loading file src\\\\paredit\\\\core.clj" "(sexp \\"[]\\")" "(sexp \\"]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" "(sexp \\"]\\")" ";; Loading file src\\\\paredit\\\\core.clj" "(sexp \\"]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley.clj" ";; Loading file src\\\\paredit\\\\core.clj" "(sexp \\"]\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"]\\")" "(sexp \\"[\\")" "(sexp \\"[]\\")" "(sexp \\"]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"]\\")" "(sexp \\"a\\")" "(net.cgrand.parsley.lrplus/step sexp net.cgrand.parsley.lrplus/zero \\"a\\")" "(sexp \\"a\\")" "(sexp \\"ab\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(dser-ser-inc [\\"(hello\\" \\"(little)\\" \\"world)\\"])" "(dser-ser-inc [\\"((\\" \\"))\\"])" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" "(dser-ser-inc [\\"((\\" \\"))\\"])" "(dser-ser-inc [\\"(\\" \\"(\\" \\"coucou\\" \\")\\" \\")\\"])" "(dser-ser-inc [\\"(\\" \\"[(\\" \\"coucou\\" \\")\\" \\"])\\"])" "(dser-ser-inc [\\"(\\" \\"[(\\" \\"coucou\\" \\")\\" \\"})\\"])" "(dser-ser-inc [\\"(\\" \\"[(\\" \\"coucou\\" \\")\\" \\"}\\"])" "(dser-ser-inc \\"((foo))\\")" "(dser-ser-inc [\\"((foo))\\"])" "(lu/node-text (dser-ser-inc [\\"((foo))\\"]))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")] (lu/node-text (dser-ser-inc [\\"((foo))\\"])))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")] (\= c (lu/node-text (dser-ser-inc [c]))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (seq (.split c \\"\\\\n\\"))] (\= c (lu/node-text (dser-ser-inc d))))" "(.split \\"salut\\\\nles\\\\ncopains\\")" "(.split \\"salut\\\\nles\\\\ncopains\\" \\"\\\\n\\")" "(seq (.split \\"salut\\\\nles\\\\ncopains\\" \\"\\\\n\\"))" "(clojure.string/split-lines \\"salut\\\\nles\\\\ncopains\\")" "(map \#(str % \\"\\\\n\\") (clojure.string/split-lines \\"salut\\\\nles\\\\ncopains\\"))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (\= c (lu/node-text (dser-ser-inc d))))" "(\= 1 1 1)" "(\= 1 2 1)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (\= c (lu/node-text (dser-ser-inc d)) (sexp c)))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(update-in {} [\:lines \\"id\\"] identity)" "(update-in {} [\:lines \\"id\\" \:qty] + 2)" "(update-in {} [\:lines \\"id\\"] (fnil update-in {\:qty 3}) [\:qty] + 2)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(require '[paredit.loc-utils \:as lu])" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(doc time)" "(source time)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(doc treeseq)" "(doc tree-seq)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(sexp \\"salut\\")" "(sexp \\"(\\")" "(map? {})" "(nil? (\:tag {}))" "(sexp \\"(\\")" "(sexp \\"(())\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Loading file test\\\\paredit\\\\tests.clj" ";; Switching to paredit.tests namespace" "(pts)" ";; Switching to paredit.tests namespace" "(pts)" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(doc into)" "(doc into\!)" "(find-doc \\"transient\\")" "(show into)" "(source into)" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Loading file test\\\\paredit\\\\tests.clj" "(pts)" ";; Switching to paredit.tests namespace" "(pts)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Loading file test\\\\paredit\\\\tests.clj" ";; Loading file src\\\\paredit\\\\core.clj" ";; Loading file src\\\\paredit\\\\loc_utils.clj" ";; Loading file src\\\\paredit\\\\regex_utils.clj" ";; Loading file src\\\\paredit\\\\compile.clj" ";; Loading file src\\\\paredit\\\\core_commands.clj" ";; Loading file src\\\\paredit\\\\text_utils.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "(sexp \\"(foo)\\")" "(vec 1 2)" "(vector 1 2)" "(sexp \\"(foo)\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"(foo)\\")" "(doc doall)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"lolo\\")" "(sexp \\"(((())))\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (sexp \\"((foo))\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (sexp \\"((foo))\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"(lolo)\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"(lolo)\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"(lolo)\\")" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (sexp \\"(lolo)\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"(lolo)\\")))" "(pprint (\:tokens (sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")))" "(sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")" "(\:tokens (sexp \\"(lolo \\\\\\"coucou\\\\\\")\\"))" "(pprint (\:tokens (sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(token \:sym 5)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"(lolo \\\\\\"coucou\\\\\\")\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"coucou\\")" "(pprint (\:tokens (sexp \\"coucou\\")))" "(pprint (\:tokens (sexp \\"(coucou\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"(coucou\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"(coucou\\")))" "(doc last)" "(doc peek)" "(doc pop)" "(doc subvec)" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"(coucou\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"(coucou\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"(coucou\\")))" "(pprint (\:tokens (sexp \\"[coucou\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"[coucou \\\\o\\")))" "(pprint (\:tokens (sexp \\"[coucou \\\\\\\\o\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"[coucou \\\\\\\\o\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"[coucou \\\\\\\\o\\")))" "(pprint (\:tokens (sexp \\"456\\")))" "(pprint (\:tokens (sexp \\"456L\\")))" "(pprint (\:tokens (sexp \\"456M\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"456M\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"456M\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"(456M)\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\"(([(\\r\\n     ())]))\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (\:tokens (sexp \\"(([(\\r\\n     ())]))\\")))" "(sexp \\"(([(\\r\\n     ())]))\\")" "(pprint (sexp \\"(([(\\r\\n     ())]))\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint (sexp \\"(([(\\r\\n     ())]))\\"))" "(pprint (\:tokens (sexp \\"(([(\\r\\n     ())]))\\")))" "(pprint (\:tokens (sexp \\"\\\\\\"lolo\\\\\\"\\")))" "(pprint (\:tokens (sexp \\"\\\\\\"lolo\\\\\\" \\\\\\"bisou\\\\\\"\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\";oto\\")))" "(pprint (sexp \\";oto\\"))" "(pprint (\:tokens (sexp \\";oto\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (\:tokens (sexp \\";oto\\")))" "(pprint (sexp \\";oto\\"))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint (sexp \\";oto\\"))" "(pprint (\:tokens (sexp \\";oto\\")))" "(pprint (\:tokens (sexp \\"\#_oto\\")))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"o\\")" ";; Switching to paredit.parser namespace" "(edit-buffer nil 0 0 \\"toto\\")" "(-> (edit-buffer nil 0 0 \\"toto\\") buffer-parse-tree)" "(-> (edit-buffer nil 0 0 \\"toto\\") (edit-buffer 0 0 \\" \\") buffer-parse-tree)" "(-> (edit-buffer nil 0 0 \\"toto)\\") (edit-buffer 0 0 \\" \\") (edit-buffer 0 0 \\"(coucou\\") buffer-parse-tree)" "(-> (edit-buffer nil 0 0 \\"toto)\\") (edit-buffer 0 0 \\" \\") (edit-buffer 0 0 \\"(coucou\\") buffer-parse-tree \:tokens)" "(-> (edit-buffer nil 0 0 \\"toto\\") (edit-buffer 0 0 \\" \\") (edit-buffer 0 0 \\"(coucou\\") buffer-parse-tree \:tokens)" "(sexp \\"\\\\\\"\\\\\\\\\\\\\\"%s\\\\\\"\\")" "(sexp \\"(printf \\\\\\"(clojure.core/load \\\\\\\\\\\\\\"%s\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\" path)\\")" "(pprint (sexp \\"(printf \\\\\\"(clojure.core/load \\\\\\\\\\\\\\"%s\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\" path)\\"))" "(.substring \\"abc\\" 0 1)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "*1" "(*1 parse-tree-view)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "(*1 parse-tree-view)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "(*1 parse-tree-view)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "(*1 parse-tree-view)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "(*1 parse-tree-view)" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"coucou\\")" "(*1 parse-tree-view)" "(\:tokens *1)" "(-> \\"coucou\\" sexp)" "(*1 parse-tree-view)" "(\:tokens *1\\n         )" "(-> \\"(defn {coucou})\\" sexp)" "(*1 parse-tree-view)" "(\:tokens *1\\n         )" ";; Loading file src\\\\paredit\\\\parser.clj" "(parse \\"lolo\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" ";; Loading file src\\\\paredit\\\\parser.clj" "(parse \\"lolo\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(binding [*build-id* 0] (parse \\"lolo\\"))" "(edit-buffer nil 0 0 \\"lolo\\")" "(-> (edit-buffer nil 0 0 \\"lolo\\")\\n    (edit-buffer 0 0 \\"()\\"))" "(-> (edit-buffer nil 0 0 \\"lolo\\")\\n    (edit-buffer 0 0 \\"()\\")\\n    buffer-parse-tree)" "(let [b (-> (edit-buffer nil 0 0 \\"lolo\\")\\n          (edit-buffer 0 0 \\"()\\"))]\\n  (binding [*build-id* 0]\\n    (buffer-parse-tree b)))" "(let [b (-> (edit-buffer nil 0 0 \\"lolo\\")\\n          (edit-buffer 0 0 \\"()\\"))]\\n  (binding [*build-id* 0]\\n    (buffer-parse-tree b))\\n  (buffer-parse-tree b))" "(let [b (-> (edit-buffer nil 0 0 \\"lolo\\")\\n          (edit-buffer 0 0 \\"()\\"))]\\n  (binding [*build-id* 0]\\n    (buffer-parse-tree b))\\n  (let [b (-> b (edit-buffer 0 0 \\"[]\\"))]))" "(let [b (-> (edit-buffer nil 0 0 \\"lolo\\")\\n          (edit-buffer 0 0 \\"()\\"))]\\n  (binding [*build-id* 0]\\n    (buffer-parse-tree b))\\n  (let [b (-> b (edit-buffer 0 0 \\"[]\\"))]\\n    (binding [*build-id* 1]\\n      (buffer-parse-tree b))))" "(pprint (let [b (-> (edit-buffer nil 0 0 \\"lolo\\")\\n                  (edit-buffer 0 0 \\"()\\"))]\\n          (binding [*build-id* 0]\\n            (buffer-parse-tree b))\\n          (let [b (-> b (edit-buffer 0 0 \\"[]\\"))]\\n            (binding [*build-id* 1]\\n              (buffer-parse-tree b)))))" "(pprint (let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\")\\n                  (edit-buffer 4 0 \\"()\\"))]\\n          (binding [*build-id* 0]\\n            (buffer-parse-tree b))\\n          (let [b (-> b \\n                    (edit-buffer 0 0 \\"[]\\"))]\\n            (binding [*build-id* 1]\\n              (buffer-parse-tree b)))))" "(pprint (let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo lili\\")\\n                  (edit-buffer 4 0 \\"()\\")\\n                  (edit-buffer 0 0 \\" \\"))]\\n          (binding [*build-id* 0]\\n            (buffer-parse-tree b))\\n          (let [b (-> b \\n                    (edit-buffer 0 0 \\"[]\\"))]\\n            (binding [*build-id* 1]\\n              (buffer-parse-tree b)))))" "(pprint (let [b (-> nil \\n                  (edit-buffer 0 0 \\"(lolo lili)\\")\\n                  (edit-buffer 4 0 \\"(lulu)\\")\\n                  (edit-buffer 0 0 \\" \\"))]\\n          (binding [*build-id* 0]\\n            (buffer-parse-tree b))\\n          (let [b (-> b \\n                    (edit-buffer 0 0 \\"[lala]\\"))]\\n            (binding [*build-id* 1]\\n              (buffer-parse-tree b)))))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo \\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 0 0 \\"[lala]\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo lili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  ((paredit.parser/parse-tree b) coarse-damage-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  ((paredit.parser/parse-tree b) coarse-damage-view))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  ((p/parse-tree b) coarse-damage-view))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 1] ((p/parse-tree b) coarse-damage-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 1] ((p/parse-tree b) coarse-damage-view)))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  ((p/parse-tree b) coarse-damage-view))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" "(mapcat nil)" "(mapcat identity [nil nil])" ";; Loading file src\\\\paredit\\\\parser.clj" "(mapcat identity [nil nil])" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 1] ((p/parse-tree b) coarse-damage-view)))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* 2] ((p/parse-tree b) coarse-damage-view)))" "(let [b (-> nil \\n                  (edit-buffer 0 0 \\"lolo\\\\nlili\\"))\\n              pt1 (binding [*build-id* 0]\\n                    (buffer-parse-tree b))\\n              b (-> b \\n                  (edit-buffer 1 0 \\"b\\"))\\n              pt2 (binding [*build-id* 1]\\n                    (buffer-parse-tree b))]\\n  (println \\"pt1\:\\")\\n  (pprint pt1)\\n  (println \\"pt2\:\\")\\n  (pprint pt2)\\n  (println \\"coarse damage view\:\\")\\n  (binding [*build-id* (\:build-id pt2)] ((p/parse-tree b) coarse-damage-view)))" "(doc parents\\n     \\n     )" "(doc clojure.zip/parents)" "(doc clojure.zip/parent\\n     )" "(doc find)" "(doc search)" "(find-doc \\"dich\\")" "(find-doc \\"search\\")" "(find-doc \\"bin\\")" "(find-doc \\"binar\\")" "(defn search \\n  \\"search by dichotomy on a vector. Returns the offset of the element, or nil if not found.\\n   f applied to the currently examined value must return 0 if the correct value is found, a negative number is the current value is less than the searched value,\\n     a positive number if the current value is more than the searched value.\\n   to be efficient, coll must be fast for `get and `count functions.\\"\\n  ([coll f] (search coll f 0 (count coll)))\\n  ([coll f x y]\\n    (cond\\n      (< y x)  nil\\n      (\= y x) (when (zero? (f (get coll x))) x)\\n      \:else   (let [pivot (rem (- y x) 2)\\n                    fv    (f (get coll pivot))]\\n                (cond\\n                  (zero? fv) pivot\\n                  (neg? fv) (recur coll f (inc pivot) y)\\n                  \:else     (recur coll f x (dec pivot)))))))" "(search [0 1 2 3 4 5] \#(\= % 3))" "(search [0 1 2 3 4 5] \#(- % 3))" "(defn search \\n  \\"search by dichotomy on a vector. Returns the offset of the element, or nil if not found.\\n   f applied to the currently examined value must return 0 if the correct value is found, a negative number is the current value is less than the searched value,\\n     a positive number if the current value is more than the searched value.\\n   to be efficient, coll must be fast for `get and `count functions.\\"\\n  ([coll f] (search coll f 0 (count coll)))\\n  ([coll f x y]\\n    (cond\\n      (< y x)  nil\\n      (\= y x) (when (zero? (f (get coll x))) x)\\n      \:else   (let [pivot (rem (- y x) 2)\\n                    fv    (f (get coll pivot))]\\n                (cond\\n                  (zero? fv) pivot\\n                  (pos? fv) (recur coll f (inc pivot) y)\\n                  \:else     (recur coll f x (dec pivot)))))))" "(search [0 1 2 3 4 5] \#(- % 3))" "(defn search \\n  \\"search by dichotomy on a vector. Returns the offset of the element, or nil if not found.\\n   f applied to the currently examined value must return 0 if the correct value is found, a negative number is the current value is less than the searched value,\\n     a positive number if the current value is more than the searched value.\\n   to be efficient, coll must be fast for `get and `count functions.\\"\\n  ([coll f] (search coll f 0 (count coll)))\\n  ([coll f x y]\\n    (cond\\n      (< y x)  nil\\n      (\= y x) (when (zero? (f (get coll x))) x)\\n      \:else   (let [pivot (quot (- y x) 2)\\n                    fv    (f (get coll pivot))]\\n                (cond\\n                  (zero? fv) pivot\\n                  (neg? fv) (recur coll f (inc pivot) y)\\n                  \:else     (recur coll f x (dec pivot)))))))" "(search [0 1 2 3 4 5] \#(- % 3))" "(search [0 1 2 3 4 5] \#(- 3 %))" "(search [0 1 2 3 4 5] \#(- % 1))" "(search [0 1 2 3 4 5] \#(- 1 %))" "(search [0 1 2 3 4 5] \#(- -1 %))" "(search [0 1 2 3 4 5] \#(- % -1))" "(search [[0 4] [4 10] [10 15]] (fn [[x y]] (cond (< 5 x) -1 (< y 5) 1 \:else 0)))" "(search [[0 4] [4 10] [10 15]] (fn [[x y]] (cond (< 5 4) -1 (< y 4) 1 \:else 0)))" "(search [[0 4] [4 10] [10 15]] (fn [[x y]] (cond (< 5 x) -1 (< y 4) 1 \:else 0)))" "(search [[0 4] [4 10] [10 15]] (fn [[x y]] (cond (< 4 x) -1 (< y 4) 1 \:else 0)))" "(search [[0 4] [4 4] [4 10] [10 15]] (fn [[x y]] (cond (< 4 x) -1 (< y 4) 1 \:else 0)))" "(find-doc \\"compar\\")" ";; Loading file src\\\\ccw\\\\editors\\\\clojure\\\\ClojureTopLevelFormsDamager.clj" ";; Loading file src\\\\paredit\\\\utils.clj" ";; Loading file src\\\\ccw\\\\editors\\\\clojure\\\\ClojureTopLevelFormsDamager.clj" ";; Loading file src\\\\paredit\\\\utils.clj" "(search [[0 4] [4 4] [4 10] [10 15]] (fn [[x y]] (cond (< 4 x) -1 (< y 4) 1 \:else 0)))" ";; Loading file src\\\\ccw\\\\editors\\\\clojure\\\\ClojureTopLevelFormsDamager.clj" "(defn parse-tree-get [parse-tree idx]\\r\\n  (let [offset ((\:content-cumulative-count parse-tree) idx)\\r\\n        length (\:count ((\:content parse-tree) idx))]\\r\\n    [offset (+ offset length)]))\\r\\n\\r\\n(defn parse-tree-count [parse-tree idx] (count (\:content parse-tree)))\\r\\n\\r\\n(defn parse-tree-content-range [parse-tree text-offset text-length]\\r\\n  (let [start-idx (bin-search [parse-tree-get parse-tree-count]\\r\\n                              parse-tree \\r\\n                              (partial range-contains-in-ex\\r\\n                                       text-offset))\\r\\n        stop-idx  (bin-search [parse-tree-get parse-tree-count]\\r\\n                              parse-tree \\r\\n                              (partial range-contains-ex-in \\r\\n                                       (+ text-offset \\r\\n                                          text-length)))]\\r\\n    [start-idx stop-idx]))\\n" ";; Loading file src\\\\paredit\\\\utils.clj" ";; Switching to paredit.utils namespace" "(defn parse-tree-get [parse-tree idx]\\r\\n  (let [offset ((\:content-cumulative-count parse-tree) idx)\\r\\n        length (\:count ((\:content parse-tree) idx))]\\r\\n    [offset (+ offset length)]))\\r\\n\\r\\n(defn parse-tree-count [parse-tree idx] (count (\:content parse-tree)))\\r\\n\\r\\n(defn parse-tree-content-range [parse-tree text-offset text-length]\\r\\n  (let [start-idx (bin-search [parse-tree-get parse-tree-count]\\r\\n                              parse-tree \\r\\n                              (partial range-contains-in-ex\\r\\n                                       text-offset))\\r\\n        stop-idx  (bin-search [parse-tree-get parse-tree-count]\\r\\n                              parse-tree \\r\\n                              (partial range-contains-ex-in \\r\\n                                       (+ text-offset \\r\\n                                          text-length)))]\\r\\n    [start-idx stop-idx]))" "(parse-tree-content-range\\n  {\:content {\:count 5},\\n   \:content-cumulative-count [0]}\\n  0 5)" "(parse-tree-content-range\\n  {\:content [{\:count 5}],\\n   \:content-cumulative-count [0]}\\n  0 5)" "(parse-tree-get {\:content [{\:count 5}],\\n                 \:content-cumulative-count [0]}\\n                0)" "(parse-tree-get {\:content [{\:count 5} {\:count 3}],\\n                 \:content-cumulative-count [0 5]}\\n                0)" "(parse-tree-get {\:content [{\:count 5} {\:count 3}],\\n                 \:content-cumulative-count [0 5]}\\n                1)" "(parse-tree-count {\:content [{\:count 5} {\:count 3}],\\n                 \:content-cumulative-count [0 5]})" "(defn parse-tree-count [parse-tree] (count (\:content parse-tree)))" "(parse-tree-count {\:content [{\:count 5} {\:count 3}],\\n                 \:content-cumulative-count [0 5]})" "(parse-tree-content-range\\n  {\:content [{\:count 5}],\\n   \:content-cumulative-count [0]}\\n  0 5)" "(parse-tree-get {\:content [{\:count 5} {\:count 3}],\\n                 \:content-cumulative-count [0 5]}\\n                1)" "(def pt {\:content [{\:count 5} {\:count 3}],\\n         \:content-cumulative-count [0 5]})" "pt" "(parse-tree-get pt 1)" "(parse-tree-count pt)" "(parse-tree-content-range pt 0 3)" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       1))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       0))" "pt" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       0))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       5))" "p" "pt" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       6\\n                                       ))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       7\\n                                       ))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2\\n                                       ))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2\\n                                       ))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2\\n                                       ))" "pt" ";; Loading file src\\\\paredit\\\\utils.clj" ";; Switching to paredit.utils namespace" "pt" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       2\\n                                       ))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       1))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       1))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       3))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       4))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       5))" "pt" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       5)\\n                              )" "pt" "{\:content [{\:count 5} {\:count 3}], \:content-cumulative-count [0 4]}" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       5)\\n                              )" "{\:content [{\:count 5} {\:count 3}], \:content-cumulative-count [0 5]}" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-in-ex\\r\\n                                       6))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       6))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       2))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       2))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       6))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       6))" "{\:content [{\:count 1} {\:count 1}\\n           {\:count 1} {\:count 1}\\n           {\:count 1} {\:count 1}\\n           {\:count 1} {\:count 1}\\n           {\:count 1}],\\n \:content-cumulative-count [0 1\\n                            2 3\\n                            4 5\\n                            6 7\\n                            8]}" "(def pt {\:content [{\:count 1} {\:count 1}\\n                   {\:count 1} {\:count 1}\\n                   {\:count 1} {\:count 1}\\n                   {\:count 1} {\:count 1}\\n                   {\:count 1}],\\n         \:content-cumulative-count [0 1\\n                                    2 3\\n                                    4 5\\n                                    6 7\\n                                    8]})" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       6))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       1))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       2))" "(def pt {\:content [{\:count 1} {\:count 1}\\n                   {\:count 1} {\:count 1}\\n                   {\:count 1} {\:count 1}\\n                   {\:count 2} {\:count 1}\\n                   {\:count 1}],\\n         \:content-cumulative-count [0 1 2 3 4 5 6 8 9]})" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       7))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       7))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       6))" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       7))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       7))" ";; Loading file src\\\\paredit\\\\utils.clj" "(bin-search [parse-tree-get parse-tree-count]\\r\\n                              pt \\r\\n                              (partial range-contains-ex-in\\r\\n                                       7))" ";; Loading file src\\\\ccw\\\\editors\\\\clojure\\\\ClojureTopLevelFormsDamager.clj" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"toto\\")" "(sexp \\"toto\\" p/parse-tree)" "((sexp \\"toto\\") p-t-v)" "((sexp \\"toto\\") parse-tree-view)" "(parse \\"toto\\")" "(pprint (parse \\"toto\\"))" "(pprint (parse \\"\#()\\"))" "(-> nil (edit-buffer 0 0 \\"\#()\\") p/parse-tree parse-tree-view)" "(-> nil (edit-buffer 0 0 \\"\#()\\") p/parse-tree (parse-tree-view 1))" "(-> nil (edit-buffer 0 0 \\"\#()\\") p/parse-tree (apply parse-tree-view))" "(-> nil (edit-buffer 0 0 \\"\#()\\") p/parse-tree (apply [parse-tree-view]))" "(binding [*build-id* 0] (-> nil (edit-buffer 0 0 \\"\#()\\") p/parse-tree (apply [parse-tree-view])))" "(binding [*build-id* 0] (-> nil (edit-buffer 0 0 \\"\#()\\") p/parse-tree (apply [parse-tree-view]) pprint))" "(delay 3)" "(def d (delay (println \\"forced\!\\") 3))" "d" "(def d (delay (println \\"forced\!\\") 3))" "(def e (delay (println \\"forced\!\\") 3))" "(\= d e)" "(\= @d @e)" "(def d (delay (println \\"forced\!\\") 3))" "(type d)" "(find-doc \\"delay\\")" "(delay? d)" "(find-doc \\"forc\\")" "(find-doc \\"forced\\")" "(doc force)" "(force 4)" "(force d)" "(def d (delay 1))" "(def e (delay 1))" "d" "e" "(\= d e)" "(\= @d @e\\n   )" "(\#{\:a} \:b \:c)" "(get \#{\:a} \:b \:c)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" " ((lolo))" " (parse \\"((lolo))\\")" "5.q" "((\:abstract-node (parse \\"((lolo))\\")) parse-tree-view)" "((\:abstract-node (parse \\"((lolo))\\")) tokens-view)" "((\:abstract-node (parse \\"lolo\\")) tokens-view)" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"lolo\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(lolo)\\")) parse-tree-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(lolo)\\")) parse-tree-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(lolo)\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"lolo\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"lolo lili\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"lolo)\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(lolo)\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"()\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(a)\\")) parse-tree-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(a)\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"(()a)\\")) parse-tree-view)))" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"((a))\\")) parse-tree-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"((a))\\")) parse-tree-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"((a))\\")) parse-tree-view)))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(mapcat \#((\:abstract-node %) paredit.parser/tokens-view) (\:content ((\:abstract-node (parse \\"((a))\\")) parse-tree-view)))" "(\\n  + 1 2)" "(def a {\:id 1 \:c [{\:id 2} {\:id 3 \:c [{\:id 4}]}]})" "a" "(pprint a)" "(require '[clojure.zip \:as zip])" "(def make-zipper (partial zip/zipper (constantly true) \:c \#(assoc %1 \:c (vec %2))))" "(def z (make-zipper a))" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    n-seq))" "(rmv a 2)" "(count(rmv a 2))" "(pprint a)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (some \#(\= k (\:id (zip/node %))) n-seq)]\\n      (zip/root (zip/edit loc dissoc k))\\n      a)))" "(rmv a 1)" "(-> a make-zipper zip/next zip/node \:id)" "(require '[clojure.zip \:as zip])" "(def make-zipper (partial zip/zipper (constantly true) \:c \#(assoc %1 \:c (vec %2))))" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (some \#(\= k (\:id (zip/node %))) n-seq)]\\n      (zip/root (zip/edit loc dissoc k))\\n      a)))" "(rmv a 4)" "(doc some)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (first (take-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (zip/root (zip/edit loc dissoc k))\\n      a)))" "(rmv a 3)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (first (take-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (zip/root (zip/remove loc))\\n      a)))" "(rmv a 3)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (first (drop-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (zip/root (zip/remove loc))\\n      a)))" "(rmv a 3)" "a" "(rmv a 4)" "(require '[clojure.zip \:as zip])" "(def make-zipper (partial zip/zipper (constantly true) \:c \#(assoc %1 \:c (vec %2))))" "(def a {\:id 1 \:c [{\:id 2} {\:id 3 \:c [{\:id 4}]}]})" "(def make-zipper (partial zip/zipper (constantly true) \:c \#(assoc %1 \:c (vec %2))))" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (first (drop-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (zip/root (zip/remove loc))\\n      a)))" "(rmv a 3)" "(rmv a 1)" "(rmv a 4)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (first (drop-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (if (\= a (zip/node loc))\\n        a\\n        (zip/root (zip/remove loc)))\\n      a)))" "a" "(rmv a 1)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while \#(not (zip/end? %)) (iterate zip/next z))]\\n    (if-let [loc (first (drop-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (when (not\= a (zip/node loc))\\n        (zip/root (zip/remove loc)))\\n      a)))" "(rmv a 1)" "(rmv a 4)" "(rmv a 3)" "(defn rmv [a k]\\n  (let [z (make-zipper a)\\n        n-seq (take-while (complement zip/end?) (iterate zip/next z))]\\n    (if-let [loc (first (drop-while \#(not\= k (\:id (zip/node %))) n-seq))]\\n      (when (not\= a (zip/node loc))\\n        (zip/root (zip/remove loc)))\\n      a)))" "(rmv a 3)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(parse \\"coucou\\")" "(pprint (parse \\"coucou\\"))" "((\:abstract-node (parse \\"coucou\\")) tokens-view)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"coucou\\")) tokens-view)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"coucou\\")) tokens-view)" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"\\")) tokens-view)" "((\:abstract-node (parse \\"a\\")) tokens-view)" "(vec (list 1 2))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"a\\")) tokens-view)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"a\\")) tokens-view)" "((\:abstract-node (parse \\"[[a] b]\\")) tokens-view)" "((\:abstract-node (parse \\"[[a b] c]\\")) tokens-view)" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"a\\")) parse-tree-view)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "((\:abstract-node (parse \\"a\\")) parse-tree-view)" "((\:abstract-node (parse \\"a\\")) tokens-view)" "((\:abstract-node (parse \\"(a)\\")) tokens-view)" "(pprint ((\:abstract-node (parse \\"(a)\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"((a))\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Loading file src\\\\ccw\\\\editors\\\\clojure\\\\PareditAutoEditStrategy.clj" ";; Loading file src\\\\ccw\\\\editors\\\\clojure\\\\ClojureTopLevelFormsDamager.clj" ";; Loading file src\\\\paredit\\\\loc_utils.clj" ";; Loading file src\\\\paredit\\\\utils.clj" ";; Loading file src\\\\paredit\\\\core.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"(b)\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"(b)\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"(b)\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"(a b)\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" "(vec nil)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'paredit.parser)))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'paredit.parser)))" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"((a b) c)\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"((a b) c)\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"a b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"(a )b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"(a )b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"(a )b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" "(get (list 0 1) 0)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(pprint ((\:abstract-node (parse \\"^a b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"^ a b\\")) tokens-view))" "(pprint ((\:abstract-node (parse \\"^ a b\\")) parse-tree-view))" "^ {\:tag 1} {}" "(meta ^ {\:tag 1} {})" ";; Loading file src\\\\paredit\\\\core.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "\#(% \:foo)" "(map \#(% \:foo) [identity])" "(map (fn f [b] (b \:foo)) [identity])" "(map (fn f [b] (b f)) [(fn [x] x)])" "(map (fn f [b] (b f)) [(fn [x] x)(fn [x] x)(fn [x] x)])" "(ns student.dialect (\:require [clojure.string \:as str]))\\r\\n(defn germanize\\r\\n  [sentence]\\r\\n  (def german-letters {\\"a\\" \\"\u00E4\\" \\"u\\" \\"\u00FC\\" \\"o\\" \\"\u00F6\\" \\"ss\\" \\"\u00DF\\"})\\r\\n  (doseq [[original-letter new-letter] german-letters]\\r\\n    (str/replace sentence original-letter new-letter)))" "(defn germanize [sentence]\\n  (apply str (map \#((fnil german-letters %) %) sentence)))" "(germanize \\"gross u\\")" "ger" "german-letters" "(def german-letters {\\"a\\" \\"\u00E4\\" \\"u\\" \\"\u00FC\\" \\"o\\" \\"\u00F6\\" \\"ss\\" \\"\u00DF\\"})" "(defn germanize [sentence]\\n  (apply str (map \#((fnil german-letters %) %) sentence)))" "(germanize \\"gross u\\")" "(defn germanize [sentence]\\n  (apply str (map \#(get german-letters % %) sentence)))" "(germanize \\"gross u\\")" "german-letters" "(defn germanize [sentence]\\n  (apply str (map \#(german-letters % %) sentence)))" "(germanize \\"u\\")" "(german-letters \\"u\\")" "(german-letters \\\\u)" "(defn germanize [sentence]\\n  (apply str (map \#((fnil german-letters (str %)) %) sentence)))" "(germanize \\"u\\")" "(german-letters \\\\u)" "(defn germanize [sentence]\\n  (apply str (map \#(german-letters (str %) %) sentence)))" "(germanize \\"u\\")" "(germanize \\"ss\\")" "(doc merge)" "(merge \#{\:a} {\:b})" "(require '[clojure.set \:as s])" "(s/project \#{\:a \:b} \:c)" "(s/project \#{{\:id 1 \:a 2}} \#{\:id})" "(s/project \#{{\:id 1 \:a 2} \#{\:id 2 \:b 4}} \#{\:id})" "(s/project \#{{\:id 1 \:a 2} {\:id 2 \:b 4}} \#{\:id})" "(s/project \#{{\:id 1 \:a 2} {\:id 2 \:b 4} {\:b 5}} \#{\:id})" "(s/join \#{{\:i 1}} \#{\:i 2})" "(s/join \#{{\:i 1}} \#{{\:i 2}})" "(s/join \#{{\:i 1}} \#{{\:i 1}})" "(s/join \#{{\:i 1}} \#{{\:i 1 \:b 4} } \#{\:i})" "(s/join \#{{\:i 1}} \#{{\:i 1 \:b 4} } \#{\:i \:i})" "(s/join \#{{\:i 1}} \#{{\:i 1 \:b 4} } {\:i \:i})" "(s/join \#{{\:i 1}} \#{{\:i 1 \:b 4} } )" "(s/join \#{{\:i 1 \:k 9}} \#{{\:i 1 \:b 4} } )" "(s/join \#{{\:i 1 \:k 9}} \#{{\:i 1 \:b 4} {\:b 5 \:e 6}} )" "(s/join \#{{\:i 1 \:k 9} {\:b 5 \:s 5}} \#{{\:i 1 \:b 4} {\:b 5 \:e 6}} )" "(use 'clojure.set)" "ys" "hs" "ys" "(def ys \#{{\:a 11 \:b 11 \:c 11 \:e 5}\\r\\n         {\:a 12 \:b 11 \:c 12 \:e 3}\\r\\n         {\:a 3 \:b 3 \:c 3 \:e 7 }})" "ys" "(pprint ys)" "(index ys [\:b])" "(index ys [\:b \:a])" "(index ys [\:b \:a \:j])" "(defn germanize [sentence]\\n  (apply str (map \#(german-letters % %) sentence)))" "(def substitutions-set \#{ \#{\\\\a \\\\n} \#{\\\\b \\\\o} \#{\\\\c \\\\p}\#{\\\\d \\\\q}\\n                          \#{\\\\e \\\\r} \#{\\\\f  \\\\s} \#{\\\\g \\\\t}\#{\\\\h \\\\u}\\n                          \#{\\\\i \\\\v} \#{\\\\j \\\\w} \#{\\\\l \\\\x} \#{\\\\l \\\\y}\\n                          \#{\\\\m \\\\z}})" "(def substitutions (reduce (fn [s [x y]] (assoc s x y y x)) {} substitution-set))" "(def substitutions (reduce (fn [s [x y]] (assoc s x y y x)) {} substitutions-set))" "(def substitutions (reduce (fn [s su] (let [[x y] (seq su)] (assoc s x y y x))) {} substitutions-set))" "substitutions" "(defn rot13 [s]\\n  (apply str (map substitutions s)))" "(rot13 \\"Vs lbh obgurerq qrpvcurevat guvf gura cyrnfr ercyl jvgu j00g\\")" "(def substitutions (reduce (fn [s su] (let [[x y] (seq su)] (assoc s x y y x))) {} substitutions-set))" "(parse \\"coucou\\")" "(parse \\"^foo bar\\")" "((-> (parse \\"^foo bar\\") \:abstract-node) tokens-view)" "((-> (parse \\"^{\:foo \:bar} bar\\") \:abstract-node) tokens-view)" "(doc peek)" "(doc pop)"]
eclipse.preferences.version=1
