#Thu Jun 16 15:54:28 CEST 2011
cmdhistory=["(binding [clojure.test/*test-out* (System/out)] (paredit.tests/pts))" "(def \\n  ^{ \:doc \\"\\n    The format for documenting the commands is simple, and a slight varation of\\n    the original paredit.el format \:\\n    paredit-commands \:\= [ group* ]\\n    group \:\= [ group-name-str command* ]\\n    command \:\= [ default-triggering-keys \\n                 command-name-keyword \\n                 { before-after-documentation-pair* } \\n                 { before-after-non-regression-pair* }* ]\\n    before-after-documentation-pair \:\= before-after-non-regression-pair\\n    before-after-non-regression-pair \:\= before-text-spec after-text-spec\\n    before-text-spec \:\= after-text-spec \:\= text-spec\\n    text-spec \:\= a string, with the caret position indicated by a pipe character |, \\n                 and if there is a selected portion of the text, the end of the text\\n                 selection is marked with another pipe character |\\"}\\n  *paredit-commands*\\n  [\\n    [\\"Basic Insertion Commands\\"\\n\\t    [\\"(\\"         \:paredit-open-round\\n\\t                {\\"(a b |c d)\\"\\n\\t                 \\"(a b (|) c d)\\"\\n\\t                 \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar (|baz\\\\\\" quux)\\"\\n                  }\\n\\t                {\\"(a b|c d)\\" \\"(a b (|) c d)\\"\\n\\t                 \\"(|)\\" \\"((|))\\"\\n\\t                 \\"|\\" \\"(|)\\"\\n\\t                 \\"a|\\" \\"a (|)\\"\\n\\t                 \\"(a |,b)\\" \\"(a (|),b)\\"\\n\\t                 \\"(a,| b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|b)\\" \\"(a, (|) b),h\\"\\n\\t                 \\"(a,|)\\" \\"(a, (|))\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\(| \\" \\n\\t                 \\"~|\\" \\"~(|)\\"\\n\\t                 \\"~@|\\" \\"~@(|)\\"\\n\\t                 \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ (|) \\"\\n                  }]\\n\\t    [\\")\\"         \:paredit-close-round\\n\\t                {\\"(a |b)\\" \\"(a b)|\\"\\n\\t                 \\"(a |b) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a |b ) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a b |c [])\\" \\"(a b c [])|\\"\\n                   \\"(a b c [|] )\\" \\"(a b c [])|\\"\\n\\t                 \\"(a b |c   )\\" \\"(a b c)|\\"\\n                   \\"( a,  b |[a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"( a,  b [|a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"[ a,  b (|a b )   ]\\" \\"[ a,  b (a b)|   ]\\"\\n\\t                 \\"(a b |c ,  )\\" \\"(a b c)|\\"\\n\\t                 \\"(a b| [d e]\\" \\"(a b)| [d e]\\"\\n\\t                 \\"; Hello,| world\!\\"  \\"; Hello,)| world\!\\"\\n\\t                 \\"(  \\\\\\"Hello,| world\!\\\\\\" foo )\\" \\"(  \\\\\\"Hello,)| world\!\\\\\\" foo )\\"\\n\\t                 \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,)| world\!\\"\\n\\t                 \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\)|\\"\\n                  ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar])|\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo bar)|})\\"\\n                  }]\\n\\t    \#_[\\"M-)\\"       \:paredit-close-round-and-newline\\n\\t                {\\"(defun f (x|  ))\\"\\n\\t                 \\"(defun f (x)\\\\n  |)\\"\\n\\t                 \\"; (Foo.|\\"\\n\\t                 \\"; (Foo.)|\\"}]\\n      [\\"[\\"         \:paredit-open-square\\n                 {\\"(a b |c d)\\"  \\"(a b [|] c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar [|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b [|] c d)\\"\\n                   \\"(|)\\" \\"([|])\\"\\n                   \\"|\\" \\"[|]\\"\\n                   \\"a|\\" \\"a [|]\\"\\n                   \\"(a |,b)\\" \\"(a [|],b)\\"\\n                   \\"(a,| b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|)\\" \\"(a, [|])\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\[| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ [|] \\"}]\\n      [\\"]\\"         \:paredit-close-square\\n                  {\\"(define-key keymap [frob|  ] 'frobnicate)\\"\\n                   \\"(define-key keymap [frob]| 'frobnicate)\\"\\n                   \\"; [Bar.|\\" \\"; [Bar.]|\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,]| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,]| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\]|\\"\\n                   ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar]|)\\"\\n                   \\"({(foo |bar]))\\" \\"({(foo bar]|))\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo ]|bar)})\\"\\n                   \\"[foo (bar [baz {bleh |blah}))]\\" \\"[foo (bar [baz {bleh blah}))]|\\"\\n                   }]\\n      [\\"{\\"         \:paredit-open-curly\\n                 {\\"(a b |c d)\\"  \\"(a b {|} c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar {|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b {|} c d)\\"\\n                   \\"(|)\\" \\"({|})\\"\\n                   \\"|\\" \\"{|}\\"\\n                   \\"a|\\" \\"a {|}\\"\\n                   \\"\#|\\" \\"\#{|}\\" ; specific to clojure sets\\n                   \\"(a |,b)\\" \\"(a {|},b)\\"\\n                   \\"(a,| b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|)\\" \\"(a, {|})\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\{| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ {|} \\"\\n                   }]\\n      [\\"}\\"         \:paredit-close-curly\\n                  {\\"{a b |c   }\\" \\"{a b c}|\\"\\n                   \\"; Hello,| world\!\\"\\n                   \\"; Hello,}| world\!\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,}| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,}| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\}|\\"\\n                   \\"({(foo |bar}))\\" \\"({(foo bar}|))\\"\\n                   }]\\n      [\\"\\\\\\"\\"        \:paredit-doublequote\\n                  { \\"(frob grovel |full lexical)\\" \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\" \\"(frob grovel \\\\\\"\\\\\\"| full lexical)\\",\\n                   \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar \\\\\\\\\\\\\\"|baz\\\\\\" quux)\\",\\n                   \\";|ab\\" \\";\\\\\\"|ab\\", \\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                     \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                   \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|a\\\\\\"\\",\\n                   \\"\\\\\\"fo|o\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;\\"\#\\\\\\"fo|o\\\\\\"\\" \\"\#\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;;;\\"\#\\\\\\"foo\\\\\\"\\" \\"\#\\\\\\"foo\\\\\\"\\"\\n\\n                  ;; \\"\#|\\" \\"\#\\\\\\"|\\\\\\"\\" ; specific to clojure regexs\\n\\n                   }]\\n    ]\\n    [\\"Deleting & Killing\\"\\n      [\\"Del\\"     \:paredit-forward-delete\\n                {\\"(quu|x \\\\\\"zot\\\\\\")\\" \\"(quu| \\\\\\"zot\\\\\\")\\",\\n                 \\"(quux |\\\\\\"zot\\\\\\")\\" \\"(quux \\\\\\"|zot\\\\\\")\\",\\n                 \\"(quux \\\\\\"|zot\\\\\\")\\" \\"(quux \\\\\\"|ot\\\\\\")\\",\\n                 \\"(foo |(a) bar)\\" \\"(foo (|a) bar)\\"\\n                 \\"(foo (|a) bar)\\" \\"(foo (|) bar)\\" \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo [|] bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo {|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo (a|) bar)\\" \\"(foo (a|) bar)\\"\\n                 \\"(foo [a|] bar)\\" \\"(foo [a|] bar)\\"\\n                 \\"(foo {a|} bar)\\" \\"(foo {a|} bar)\\"\\n\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#{a|} bar)\\" \\"(foo \#{a|} bar)\\"\\n                 \\"(foo \#{a |d} bar)\\" \\"(foo \#{a |} bar)\\"\\n                 \\"(|\#{foo bar})\\" \\"(\#{|foo bar})\\"\\n\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#(a|) bar)\\" \\"(foo \#(a|) bar)\\"\\n                 \\"(foo \#(a |d) bar)\\" \\"(foo \#(a |) bar)\\"\\n                 \\"(|\#(foo bar))\\" \\"(\#(|foo bar))\\"\\n\\n                 \\"(foo \#\\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#\\\\\\"a|\\\\\\" bar)\\" \\"(foo \#\\\\\\"a|\\\\\\" bar)\\"\\n                 \\"(foo \#\\\\\\"a |d\\\\\\" bar)\\" \\"(foo \#\\\\\\"a |\\\\\\" bar)\\"\\n                 \\"(|\#\\\\\\"foo bar\\\\\\")\\" \\"(\#\\\\\\"|foo bar\\\\\\")\\"\\n\\n                 \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\n                 \\"(|(foo bar))\\" \\"((|foo bar))\\"\\n                 \\"(|[foo bar])\\" \\"([|foo bar])\\"\\n                 \\"(|{foo bar})\\" \\"({|foo bar})\\"\\n                 \\n                 \\"|\\" \\"|\\"\\n                 }]\\n      [\\"BackDel\\" \:paredit-backward-delete\\n                {\\n                 \\"(\\\\\\"zot\\\\\\" q|uux)\\" \\"(\\\\\\"zot\\\\\\" |uux)\\",\\n                 \\"(\\\\\\"zot\\\\\\"| quux)\\" \\"(\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\\\\\\"zot|\\\\\\" quux)\\" \\"(\\\\\\"zo|\\\\\\" quux)\\",\\n\\n                 \\"(\#\\\\\\"zot\\\\\\"| quux)\\" \\"(\#\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\#\\\\\\"zot|\\\\\\" quux)\\" \\"(\#\\\\\\"zo|\\\\\\" quux)\\",\\n                 \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\",\\n                 \\n                 \\"(foo bar)|\\" \\"(foo bar|)\\",\\n                 \\"(foo bar|)\\" \\"(foo ba|)\\",\\n                 \\n                 \\"|\\" \\"|\\"\\n                 \\n                 \\"\\\\\\"\\\\\\"|\\" \\"\\\\\\"|\\\\\\"\\"\\n                 \\"\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\"\#\\\\\\"\\\\\\"|\\" \\"\#\\\\\\"|\\\\\\"\\"\\n                 \\"\#\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\n                 \\"\#(foo bar)|\\" \\"\#(foo bar|)\\",\\n                 \\"\#(foo bar|)\\" \\"\#(foo ba|)\\",\\n                 \\"\#{foo bar}|\\" \\"\#{foo bar|}\\",\\n                 \\"\#{foo bar|}\\" \\"\#{foo ba|}\\",\\n                 \\"\#(|)\\" \\"|\\",\\n                 \\"\#{|}\\" \\"|\\"\\n                 }]\\n      ;\#_[\\"C-k\\"     \:paredit-kill\\n      ;          {\\"(foo bar)|     ; Useless comment\!\\"\\n      ;           \\"(foo bar)|\\",\\n      ;          \\"(|foo bar)     ; Useful comment\!\\"\\n      ;           \\"(|)     ; Useful comment\!\\",\\n      ;          \\"|(foo bar)     ; Useless line\!\\"\\n      ;           \\"|\\",\\n      ;          \\"(foo \\\\\\"|bar baz\\\\\\"\\\\n     quux)\\"\\n      ;           \\"(foo \\\\\\"|\\\\\\"\\\\n     quux)\\"}]\\n      ]\\n    \\n    [\\"Depth-Changing Commands\\"\\n     [\\"M-(\\"       \:paredit-wrap-round\\n      {\\"(foo |bar baz)\\" \\"(foo (|bar) baz)\\",\\n       \\";hel|lo\\" \\";hel(|lo\\",\\n       \\"a |\\\\\\"hi\\\\\\"\\" \\"a (|\\\\\\"hi\\\\\\")\\",\\n       \\"a |\\\\\\"hi\\\\\\"|\\" \\"a (|\\\\\\"hi\\\\\\"|)\\",\\n       \\"foo |bar| foo\\" \\"foo (|bar|) foo\\",\\n       \\"foo |bar baz| foo\\" \\"foo (|bar baz|) foo\\",\\n       \\"foo (|bar| baz) foo\\" \\"foo ((|bar|) baz) foo\\"\\n       \\"foo (|bar baz|) foo\\" \\"foo ((|bar baz|)) foo\\"\\n       ;; not-yet \\"foo |(bar| baz) foo\\" \\"foo |(bar| baz) foo\\"\\n       ;; not-yet \\"foo (bar| baz)| foo\\" \\"foo (bar| baz)| foo\\"\\n       \\"foo |(bar baz)| foo\\" \\"foo (|(bar baz)|) foo\\"\\n       \\"foo |(bar\\\\n;comment\\\\n baz)| foo\\" \\"foo (|(bar\\\\n;comment\\\\n baz)|) foo\\"\\n       ;; not-yet \\"foo |bar ba|z foo\\" \\"foo |bar ba|z foo\\",\\n       \\"foo \\\\\\"|bar ba|z\\\\\\" foo\\" \\"foo \\\\\\"(|z\\\\\\" foo\\",\\n       ;; not-yet \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\" \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\",\\n       \\"foo |bar|\\" \\"foo (|bar|)\\"\\n       \\"foo |(bar)|\\" \\"foo (|(bar)|)\\"\\n       }]\\n     ;[\\"M-s\\"       \:paredit-splice-sexp\\n     ;           {\\"(foo (bar| baz) quux)\\"\\n     ;            \\"(foo bar| baz quux)\\"}]\\n     ;[(\\"M-<up>\\" \\"ESC <up>\\")\\n     ;           paredit-splice-sexp-killing-backward\\n     ;           (\\"(foo (let ((x 5)) |(sqrt n)) bar)\\"\\n     ;            \\"(foo (sqrt n) bar)\\")]\\n     ;((\\"M-<down>\\" \\"ESC <down>\\")\\n     ;           paredit-splice-sexp-killing-forward\\n     ;           (\\"(a (b c| d e) f)\\"\\n     ;            \\"(a b c f)\\"))\\n     [\\"M-r\\"       \:paredit-raise-sexp\\n                {\\"(dynamic-wind in (lambda () |body|) out)\\" \\"(dynamic-wind in |body out)\\"\\n                 \\"(dynamic-wind in |body| out)\\" \\"|body\\" \\n                 \\"(foo bar|)\\" \\"(foo bar|)\\"\\n                 \\"(foo |bar)\\" \\"|bar\\"\\n                 \\"(foo |(bar))\\" \\"|(bar)\\"\\n                 \\"(foo |(bar]|)\\" \\"|(bar]\\"\\n                 }]\\n     ]\\n    \\n    [\\"Selection\\"\\n     [\\"Shift+Alt+Left\\" \:paredit-expand-left\\n                {\\n                 \\"foo bar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo bar |baz\\" \\"foo bar| |baz\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 bar b|a|z\\" \\"foo1 bar |baz|\\"\\n                 \\"foo2 bar ba|z|\\" \\"foo2 bar |baz|\\"\\n                 \\"foo3 bar |baz|\\" \\"foo3 bar| baz|\\"\\n                 \\"foo bar| baz|\\" \\"foo |bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"foo| bar baz|\\"\\n                 \\"|(foo bar baz)|\\" \\"|(foo bar baz)|\\"\\n                 ;;not-yet \\"|fo|o bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo| bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo b|ar baz\\" \\"|foo bar baz|\\" \\n                 \\"foo (bar| baz)\\" \\"foo (|bar| baz)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 (|bar| baz)\\" \\"foo1 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"(foo bar|)\\" \\"(foo |bar|)\\"\\n                 \\"fooz foo |(bar)| baz\\" \\"fooz foo| (bar)| baz\\"\\n                 \\"fooz foo| (bar)| baz\\" \\"fooz |foo (bar)| baz\\"\\n                 ;with \:chimera\\n                 \\"(foo bar|]\\" \\"(foo |bar|]\\"\\n                 \\"(foo {bar)|]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Right\\" \:paredit-expand-right\\n                {\\n                 \\"foo bar| baz\\" \\"foo bar| |baz\\"\\n                 \\"foo4 bar |baz\\" \\"foo4 bar |baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo5 bar b|a|z\\" \\"foo5 bar |baz|\\"\\n                 \\"foo6 bar ba|z|\\" \\"foo6 bar |baz|\\"\\n                 ;;not-yet \\"foo bar |baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo| bar baz\\";;\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo |bar baz\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar| baz\\"\\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo (bar| baz)\\" \\"foo (bar| |baz)\\"\\n                 \\"foo (bar |baz)\\" \\"foo (bar |baz|)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo2 (bar baz|)\\" \\"foo2 |(bar baz)|\\"\\n                 \\"foo3 (bar |baz|)\\" \\"foo3 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"(foo |bar|]\\"\\n                 \\"(foo |{bar)]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Up\\" \:paredit-expand-up\\n                {\\n                 \\"abc defgh|i \\" \\"abc |defghi| \\"\\n                 \\"|abc| defghi \\" \\"|abc defghi |\\"\\n                 \\"foo bar| baz\\" \\"|foo bar baz|\\"\\n                 \\"foo bar |baz\\" \\"|foo bar baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo7 bar b|a|z\\" \\"foo7 bar |baz|\\"\\n                 \\"foo8 bar ba|z|\\" \\"foo8 bar |baz|\\"\\n                 \\"foo9 bar |baz|\\" \\"|foo9 bar baz|\\"\\n                 \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo4 (bar| baz)\\" \\"foo4 |(bar baz)|\\"\\n                 \\"foo5 (bar |baz)\\" \\"foo5 |(bar baz)|\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo6 (bar baz|)\\" \\"foo6 |(bar baz)|\\"\\n                 \\"foo7 (bar |baz|)\\" \\"foo7 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"foo ([|bar])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo ([b|ar])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([b|a|r])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([|bar|])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo (|[bar]|)\\" \\"foo |([bar])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"|(foo bar]|\\"\\n                 \\"(foo |{bar)]\\" \\"|(foo {bar)]|\\"\\n                 }]\\n     ]\\n    [\\"Miscellaneous\\"             \\n      [\\"Tab\\"     \:paredit-indent-line\\n                {\\"[a\\\\n|b]\\"  \\"[a\\\\n |b]\\"\\n                 \\"([a1\\\\n|b])\\"  \\"([a1\\\\n  |b])\\"\\n                 \\"([a1b\\\\n  |b])\\" \\"([a1b\\\\n  |b])\\"\\n                 \\"(a\\\\n |)\\" \\"(a\\\\n  |)\\"\\n                 \\"(a b c\\\\nd| e)\\" \\"(a b c\\\\n  d| e)\\"\\n                 \\"|(toto)\\" \\"|(toto)\\"\\n                 \\"(a\\\\n  ;sdfdf\\\\n  |b)\\" \\"(a\\\\n  ;sdfdf\\\\n  |b)\\"\\n                 \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\" \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\"\\n                 \\"[a\\\\n|\\\\\\"a\\\\\\"]\\" \\"[a\\\\n |\\\\\\"a\\\\\\"]\\"\\n                 \\"(a\\\\n\\\\t|b)\\" \\"(a\\\\n  |b)\\"\\n                 \\"(\\\\n|\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n  |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n   |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n , |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"  {\\\\n|a}\\" \\"  {\\\\n   |a}\\"\\n                 \\" (\\\\n|    ab c)\\" \\" (\\\\n|   ab c)\\"\\n                 \\" (\\\\n |   ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |  ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\" (\\\\n   | ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n    |ab c)\\" \\" (\\\\n   |ab c)\\" \\n                 \\" (\\\\n    a|b c)\\" \\" (\\\\n   a|b c)\\"  \\n                 \\" (\\\\n    |    ab c)\\" \\" (\\\\n|   ab c)\\" \\n                 \\" (\\\\n      |  ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n| ab c)\\" \\" (\\\\n|   ab c)\\"  \\n                 \\" (\\\\n  | ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\"(a\\\\n |b\\" \\"(a\\\\n  |b\\" \\n                 ;;;\\"foo (let [n (frobbotz)] \\\\n|(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;;;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;;;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;;;   \\"\\\\n        port))\\\\n        bar\\"\\n                 ;;   )\\n                 \\"   a\\\\n       |\\" \\"   a\\\\n   |\\"\\n                 \\")|s\\" \\")|s\\"\\n                 \\")\\\\n|s\\" \\")\\\\n|s\\"\\n                 \\"\#(a\\\\n|)\\" \\"\#(a\\\\n   |)\\"\\n                 ; with chimera\\n                 \\"(a\\\\n|(])\\" \\"(a\\\\n  |(])\\"\\n                 \\"(a\\\\n|\\" \\"(a\\\\n  |\\"\\n                 \\"(a\\\\n|]\\" \\"(a\\\\n  |]\\"\\n                 \\" \#(a\\\\n|]\\" \\" \#(a\\\\n    |]\\"\\n                 }]\\n      [\#\\"C-j\\"     \:paredit-newline\\n                {\\"(ab|cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"(ab|     cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"   a|\\" \\"   a\\\\n   |\\"\\n                 ;\\"foo (let [n (frobbotz)] |(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;   \\"\\\\n        port))\\\\n        bar\\")\\n                 }]\\n      [\\"M-S\\"    \:paredit-split-sexp\\n                {\\"(hello  |  world)\\" \\"(hello)| (world)\\",\\n                 \\"\\\\\\"Hello, |world\!\\\\\\"\\" \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\",\\n                 \\"(hel|lo)\\" \\"(hel)| (lo)\\",\\n                 \\"[hello |world]\\" \\"[hello]| [world]\\",\\n                 \\"{hello brave |new world}\\" \\"{hello brave}| {new world}\\",\\n                 \\"{|}\\" \\"{}| {}\\"\\n                 \\"(foo|)\\" \\"(foo)| ()\\"\\n                 \\"({|})\\" \\"({}| {})\\"\\n                 \\"(defn hello |[world])\\" \\"(defn hello)| ([world])\\"\\n                 }]\\n      [\\"M-J\\"    \:paredit-join-sexps\\n                {\\"(hello)| (world)\\" \\"(hello| world)\\",\\n                 \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\" \\"\\\\\\"Hello, |world\!\\\\\\"\\",\\n                 \\"hello-\\\\n|  world\\" \\"hello-|world\\"\\n                 \\"({\:foo \:bar}| {\:baz \:fooz})\\" \\"({\:foo \:bar| \:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} |{\:baz \:fooz})\\" \\"({\:foo \:bar |\:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} {|\:baz \:fooz})\\" \\"({\:foo \:bar} {|\:baz \:fooz})\\"\\n                 \\"({\:baz \:fooz|} {\:foo \:bar})\\" \\"({\:baz \:fooz|} {\:foo \:bar})\\"\\n                 }]\\n    ]\\n  ])" "(binding [clojure.test/*test-out* (System/out)] (paredit.tests/pts))" "(binding [clojure.test/*test-out* *out*] (paredit.tests/pts))" "(def \\n  ^{ \:doc \\"\\n    The format for documenting the commands is simple, and a slight varation of\\n    the original paredit.el format \:\\n    paredit-commands \:\= [ group* ]\\n    group \:\= [ group-name-str command* ]\\n    command \:\= [ default-triggering-keys \\n                 command-name-keyword \\n                 { before-after-documentation-pair* } \\n                 { before-after-non-regression-pair* }* ]\\n    before-after-documentation-pair \:\= before-after-non-regression-pair\\n    before-after-non-regression-pair \:\= before-text-spec after-text-spec\\n    before-text-spec \:\= after-text-spec \:\= text-spec\\n    text-spec \:\= a string, with the caret position indicated by a pipe character |, \\n                 and if there is a selected portion of the text, the end of the text\\n                 selection is marked with another pipe character |\\"}\\n  *paredit-commands*\\n  [\\n    [\\"Basic Insertion Commands\\"\\n\\t    [\\"(\\"         \:paredit-open-round\\n\\t                {\\"(a b |c d)\\"\\n\\t                 \\"(a b (|) c d)\\"\\n\\t                 \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar (|baz\\\\\\" quux)\\"\\n                  }\\n\\t                {\\"(a b|c d)\\" \\"(a b (|) c d)\\"\\n\\t                 \\"(|)\\" \\"((|))\\"\\n\\t                 \\"|\\" \\"(|)\\"\\n\\t                 \\"a|\\" \\"a (|)\\"\\n\\t                 \\"(a |,b)\\" \\"(a (|),b)\\"\\n\\t                 \\"(a,| b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|)\\" \\"(a, (|))\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\(| \\" \\n\\t                 \\"~|\\" \\"~(|)\\"\\n\\t                 \\"~@|\\" \\"~@(|)\\"\\n\\t                 \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ (|) \\"\\n                  }]\\n\\t    [\\")\\"         \:paredit-close-round\\n\\t                {\\"(a |b)\\" \\"(a b)|\\"\\n\\t                 \\"(a |b) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a |b ) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a b |c [])\\" \\"(a b c [])|\\"\\n                   \\"(a b c [|] )\\" \\"(a b c [])|\\"\\n\\t                 \\"(a b |c   )\\" \\"(a b c)|\\"\\n                   \\"( a,  b |[a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"( a,  b [|a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"[ a,  b (|a b )   ]\\" \\"[ a,  b (a b)|   ]\\"\\n\\t                 \\"(a b |c ,  )\\" \\"(a b c)|\\"\\n\\t                 \\"(a b| [d e]\\" \\"(a b)| [d e]\\"\\n\\t                 \\"; Hello,| world\!\\"  \\"; Hello,)| world\!\\"\\n\\t                 \\"(  \\\\\\"Hello,| world\!\\\\\\" foo )\\" \\"(  \\\\\\"Hello,)| world\!\\\\\\" foo )\\"\\n\\t                 \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,)| world\!\\"\\n\\t                 \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\)|\\"\\n                  ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar])|\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo bar)|})\\"\\n                  }]\\n\\t    \#_[\\"M-)\\"       \:paredit-close-round-and-newline\\n\\t                {\\"(defun f (x|  ))\\"\\n\\t                 \\"(defun f (x)\\\\n  |)\\"\\n\\t                 \\"; (Foo.|\\"\\n\\t                 \\"; (Foo.)|\\"}]\\n      [\\"[\\"         \:paredit-open-square\\n                 {\\"(a b |c d)\\"  \\"(a b [|] c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar [|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b [|] c d)\\"\\n                   \\"(|)\\" \\"([|])\\"\\n                   \\"|\\" \\"[|]\\"\\n                   \\"a|\\" \\"a [|]\\"\\n                   \\"(a |,b)\\" \\"(a [|],b)\\"\\n                   \\"(a,| b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|)\\" \\"(a, [|])\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\[| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ [|] \\"}]\\n      [\\"]\\"         \:paredit-close-square\\n                  {\\"(define-key keymap [frob|  ] 'frobnicate)\\"\\n                   \\"(define-key keymap [frob]| 'frobnicate)\\"\\n                   \\"; [Bar.|\\" \\"; [Bar.]|\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,]| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,]| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\]|\\"\\n                   ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar]|)\\"\\n                   \\"({(foo |bar]))\\" \\"({(foo bar]|))\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo ]|bar)})\\"\\n                   \\"[foo (bar [baz {bleh |blah}))]\\" \\"[foo (bar [baz {bleh blah}))]|\\"\\n                   }]\\n      [\\"{\\"         \:paredit-open-curly\\n                 {\\"(a b |c d)\\"  \\"(a b {|} c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar {|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b {|} c d)\\"\\n                   \\"(|)\\" \\"({|})\\"\\n                   \\"|\\" \\"{|}\\"\\n                   \\"a|\\" \\"a {|}\\"\\n                   \\"\#|\\" \\"\#{|}\\" ; specific to clojure sets\\n                   \\"(a |,b)\\" \\"(a {|},b)\\"\\n                   \\"(a,| b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|)\\" \\"(a, {|})\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\{| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ {|} \\"\\n                   }]\\n      [\\"}\\"         \:paredit-close-curly\\n                  {\\"{a b |c   }\\" \\"{a b c}|\\"\\n                   \\"; Hello,| world\!\\"\\n                   \\"; Hello,}| world\!\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,}| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,}| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\}|\\"\\n                   \\"({(foo |bar}))\\" \\"({(foo bar}|))\\"\\n                   }]\\n      [\\"\\\\\\"\\"        \:paredit-doublequote\\n                  { \\"(frob grovel |full lexical)\\" \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\" \\"(frob grovel \\\\\\"\\\\\\"| full lexical)\\",\\n                   \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar \\\\\\\\\\\\\\"|baz\\\\\\" quux)\\",\\n                   \\";|ab\\" \\";\\\\\\"|ab\\", \\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                     \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                   \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|a\\\\\\"\\",\\n                   \\"\\\\\\"fo|o\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;\\"\#\\\\\\"fo|o\\\\\\"\\" \\"\#\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;;;\\"\#\\\\\\"foo\\\\\\"\\" \\"\#\\\\\\"foo\\\\\\"\\"\\n\\n                  ;; \\"\#|\\" \\"\#\\\\\\"|\\\\\\"\\" ; specific to clojure regexs\\n\\n                   }]\\n    ]\\n    [\\"Deleting & Killing\\"\\n      [\\"Del\\"     \:paredit-forward-delete\\n                {\\"(quu|x \\\\\\"zot\\\\\\")\\" \\"(quu| \\\\\\"zot\\\\\\")\\",\\n                 \\"(quux |\\\\\\"zot\\\\\\")\\" \\"(quux \\\\\\"|zot\\\\\\")\\",\\n                 \\"(quux \\\\\\"|zot\\\\\\")\\" \\"(quux \\\\\\"|ot\\\\\\")\\",\\n                 \\"(foo |(a) bar)\\" \\"(foo (|a) bar)\\"\\n                 \\"(foo (|a) bar)\\" \\"(foo (|) bar)\\" \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo [|] bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo {|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo (a|) bar)\\" \\"(foo (a|) bar)\\"\\n                 \\"(foo [a|] bar)\\" \\"(foo [a|] bar)\\"\\n                 \\"(foo {a|} bar)\\" \\"(foo {a|} bar)\\"\\n\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#{a|} bar)\\" \\"(foo \#{a|} bar)\\"\\n                 \\"(foo \#{a |d} bar)\\" \\"(foo \#{a |} bar)\\"\\n                 \\"(|\#{foo bar})\\" \\"(\#{|foo bar})\\"\\n\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#(a|) bar)\\" \\"(foo \#(a|) bar)\\"\\n                 \\"(foo \#(a |d) bar)\\" \\"(foo \#(a |) bar)\\"\\n                 \\"(|\#(foo bar))\\" \\"(\#(|foo bar))\\"\\n\\n                 \\"(foo \#\\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#\\\\\\"a|\\\\\\" bar)\\" \\"(foo \#\\\\\\"a|\\\\\\" bar)\\"\\n                 \\"(foo \#\\\\\\"a |d\\\\\\" bar)\\" \\"(foo \#\\\\\\"a |\\\\\\" bar)\\"\\n                 \\"(|\#\\\\\\"foo bar\\\\\\")\\" \\"(\#\\\\\\"|foo bar\\\\\\")\\"\\n\\n                 \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\n                 \\"(|(foo bar))\\" \\"((|foo bar))\\"\\n                 \\"(|[foo bar])\\" \\"([|foo bar])\\"\\n                 \\"(|{foo bar})\\" \\"({|foo bar})\\"\\n                 \\n                 \\"|\\" \\"|\\"\\n                 }]\\n      [\\"BackDel\\" \:paredit-backward-delete\\n                {\\n                 \\"(\\\\\\"zot\\\\\\" q|uux)\\" \\"(\\\\\\"zot\\\\\\" |uux)\\",\\n                 \\"(\\\\\\"zot\\\\\\"| quux)\\" \\"(\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\\\\\\"zot|\\\\\\" quux)\\" \\"(\\\\\\"zo|\\\\\\" quux)\\",\\n\\n                 \\"(\#\\\\\\"zot\\\\\\"| quux)\\" \\"(\#\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\#\\\\\\"zot|\\\\\\" quux)\\" \\"(\#\\\\\\"zo|\\\\\\" quux)\\",\\n                 \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\",\\n                 \\n                 \\"(foo bar)|\\" \\"(foo bar|)\\",\\n                 \\"(foo bar|)\\" \\"(foo ba|)\\",\\n                 \\n                 \\"|\\" \\"|\\"\\n                 \\n                 \\"\\\\\\"\\\\\\"|\\" \\"\\\\\\"|\\\\\\"\\"\\n                 \\"\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\"\#\\\\\\"\\\\\\"|\\" \\"\#\\\\\\"|\\\\\\"\\"\\n                 \\"\#\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\n                 \\"\#(foo bar)|\\" \\"\#(foo bar|)\\",\\n                 \\"\#(foo bar|)\\" \\"\#(foo ba|)\\",\\n                 \\"\#{foo bar}|\\" \\"\#{foo bar|}\\",\\n                 \\"\#{foo bar|}\\" \\"\#{foo ba|}\\",\\n                 \\"\#(|)\\" \\"|\\",\\n                 \\"\#{|}\\" \\"|\\"\\n                 }]\\n      ;\#_[\\"C-k\\"     \:paredit-kill\\n      ;          {\\"(foo bar)|     ; Useless comment\!\\"\\n      ;           \\"(foo bar)|\\",\\n      ;          \\"(|foo bar)     ; Useful comment\!\\"\\n      ;           \\"(|)     ; Useful comment\!\\",\\n      ;          \\"|(foo bar)     ; Useless line\!\\"\\n      ;           \\"|\\",\\n      ;          \\"(foo \\\\\\"|bar baz\\\\\\"\\\\n     quux)\\"\\n      ;           \\"(foo \\\\\\"|\\\\\\"\\\\n     quux)\\"}]\\n      ]\\n    \\n    [\\"Depth-Changing Commands\\"\\n     [\\"M-(\\"       \:paredit-wrap-round\\n      {\\"(foo |bar baz)\\" \\"(foo (|bar) baz)\\",\\n       \\";hel|lo\\" \\";hel(|lo\\",\\n       \\"a |\\\\\\"hi\\\\\\"\\" \\"a (|\\\\\\"hi\\\\\\")\\",\\n       \\"a |\\\\\\"hi\\\\\\"|\\" \\"a (|\\\\\\"hi\\\\\\"|)\\",\\n       \\"foo |bar| foo\\" \\"foo (|bar|) foo\\",\\n       \\"foo |bar baz| foo\\" \\"foo (|bar baz|) foo\\",\\n       \\"foo (|bar| baz) foo\\" \\"foo ((|bar|) baz) foo\\"\\n       \\"foo (|bar baz|) foo\\" \\"foo ((|bar baz|)) foo\\"\\n       ;; not-yet \\"foo |(bar| baz) foo\\" \\"foo |(bar| baz) foo\\"\\n       ;; not-yet \\"foo (bar| baz)| foo\\" \\"foo (bar| baz)| foo\\"\\n       \\"foo |(bar baz)| foo\\" \\"foo (|(bar baz)|) foo\\"\\n       \\"foo |(bar\\\\n;comment\\\\n baz)| foo\\" \\"foo (|(bar\\\\n;comment\\\\n baz)|) foo\\"\\n       ;; not-yet \\"foo |bar ba|z foo\\" \\"foo |bar ba|z foo\\",\\n       \\"foo \\\\\\"|bar ba|z\\\\\\" foo\\" \\"foo \\\\\\"(|z\\\\\\" foo\\",\\n       ;; not-yet \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\" \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\",\\n       \\"foo |bar|\\" \\"foo (|bar|)\\"\\n       \\"foo |(bar)|\\" \\"foo (|(bar)|)\\"\\n       }]\\n     ;[\\"M-s\\"       \:paredit-splice-sexp\\n     ;           {\\"(foo (bar| baz) quux)\\"\\n     ;            \\"(foo bar| baz quux)\\"}]\\n     ;[(\\"M-<up>\\" \\"ESC <up>\\")\\n     ;           paredit-splice-sexp-killing-backward\\n     ;           (\\"(foo (let ((x 5)) |(sqrt n)) bar)\\"\\n     ;            \\"(foo (sqrt n) bar)\\")]\\n     ;((\\"M-<down>\\" \\"ESC <down>\\")\\n     ;           paredit-splice-sexp-killing-forward\\n     ;           (\\"(a (b c| d e) f)\\"\\n     ;            \\"(a b c f)\\"))\\n     [\\"M-r\\"       \:paredit-raise-sexp\\n                {\\"(dynamic-wind in (lambda () |body|) out)\\" \\"(dynamic-wind in |body out)\\"\\n                 \\"(dynamic-wind in |body| out)\\" \\"|body\\" \\n                 \\"(foo bar|)\\" \\"(foo bar|)\\"\\n                 \\"(foo |bar)\\" \\"|bar\\"\\n                 \\"(foo |(bar))\\" \\"|(bar)\\"\\n                 \\"(foo |(bar]|)\\" \\"|(bar]\\"\\n                 }]\\n     ]\\n    \\n    [\\"Selection\\"\\n     [\\"Shift+Alt+Left\\" \:paredit-expand-left\\n                {\\n                 \\"foo bar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo bar |baz\\" \\"foo bar| |baz\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 bar b|a|z\\" \\"foo1 bar |baz|\\"\\n                 \\"foo2 bar ba|z|\\" \\"foo2 bar |baz|\\"\\n                 \\"foo3 bar |baz|\\" \\"foo3 bar| baz|\\"\\n                 \\"foo bar| baz|\\" \\"foo |bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"foo| bar baz|\\"\\n                 \\"|(foo bar baz)|\\" \\"|(foo bar baz)|\\"\\n                 ;;not-yet \\"|fo|o bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo| bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo b|ar baz\\" \\"|foo bar baz|\\" \\n                 \\"foo (bar| baz)\\" \\"foo (|bar| baz)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 (|bar| baz)\\" \\"foo1 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"(foo bar|)\\" \\"(foo |bar|)\\"\\n                 \\"fooz foo |(bar)| baz\\" \\"fooz foo| (bar)| baz\\"\\n                 \\"fooz foo| (bar)| baz\\" \\"fooz |foo (bar)| baz\\"\\n                 ;with \:chimera\\n                 \\"(foo bar|]\\" \\"(foo |bar|]\\"\\n                 \\"(foo {bar)|]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Right\\" \:paredit-expand-right\\n                {\\n                 \\"foo bar| baz\\" \\"foo bar| |baz\\"\\n                 \\"foo4 bar |baz\\" \\"foo4 bar |baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo5 bar b|a|z\\" \\"foo5 bar |baz|\\"\\n                 \\"foo6 bar ba|z|\\" \\"foo6 bar |baz|\\"\\n                 ;;not-yet \\"foo bar |baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo| bar baz\\";;\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo |bar baz\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar| baz\\"\\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo (bar| baz)\\" \\"foo (bar| |baz)\\"\\n                 \\"foo (bar |baz)\\" \\"foo (bar |baz|)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo2 (bar baz|)\\" \\"foo2 |(bar baz)|\\"\\n                 \\"foo3 (bar |baz|)\\" \\"foo3 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"(foo |bar|]\\"\\n                 \\"(foo |{bar)]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Up\\" \:paredit-expand-up\\n                {\\n                 \\"abc defgh|i \\" \\"abc |defghi| \\"\\n                 \\"|abc| defghi \\" \\"|abc defghi |\\"\\n                 \\"foo bar| baz\\" \\"|foo bar baz|\\"\\n                 \\"foo bar |baz\\" \\"|foo bar baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo7 bar b|a|z\\" \\"foo7 bar |baz|\\"\\n                 \\"foo8 bar ba|z|\\" \\"foo8 bar |baz|\\"\\n                 \\"foo9 bar |baz|\\" \\"|foo9 bar baz|\\"\\n                 \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo4 (bar| baz)\\" \\"foo4 |(bar baz)|\\"\\n                 \\"foo5 (bar |baz)\\" \\"foo5 |(bar baz)|\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo6 (bar baz|)\\" \\"foo6 |(bar baz)|\\"\\n                 \\"foo7 (bar |baz|)\\" \\"foo7 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"foo ([|bar])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo ([b|ar])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([b|a|r])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([|bar|])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo (|[bar]|)\\" \\"foo |([bar])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"|(foo bar]|\\"\\n                 \\"(foo |{bar)]\\" \\"|(foo {bar)]|\\"\\n                 }]\\n     ]\\n    [\\"Miscellaneous\\"             \\n      [\\"Tab\\"     \:paredit-indent-line\\n                {\\"[a\\\\n|b]\\"  \\"[a\\\\n |b]\\"\\n                 \\"([a1\\\\n|b])\\"  \\"([a1\\\\n  |b])\\"\\n                 \\"([a1b\\\\n  |b])\\" \\"([a1b\\\\n  |b])\\"\\n                 \\"(a\\\\n |)\\" \\"(a\\\\n  |)\\"\\n                 \\"(a b c\\\\nd| e)\\" \\"(a b c\\\\n  d| e)\\"\\n                 \\"|(toto)\\" \\"|(toto)\\"\\n                 \\"(a\\\\n  ;sdfdf\\\\n  |b)\\" \\"(a\\\\n  ;sdfdf\\\\n  |b)\\"\\n                 \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\" \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\"\\n                 \\"[a\\\\n|\\\\\\"a\\\\\\"]\\" \\"[a\\\\n |\\\\\\"a\\\\\\"]\\"\\n                 \\"(a\\\\n\\\\t|b)\\" \\"(a\\\\n  |b)\\"\\n                 \\"(\\\\n|\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n  |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n   |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n , |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"  {\\\\n|a}\\" \\"  {\\\\n   |a}\\"\\n                 \\" (\\\\n|    ab c)\\" \\" (\\\\n|   ab c)\\"\\n                 \\" (\\\\n |   ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |  ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\" (\\\\n   | ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n    |ab c)\\" \\" (\\\\n   |ab c)\\" \\n                 \\" (\\\\n    a|b c)\\" \\" (\\\\n   a|b c)\\"  \\n                 \\" (\\\\n    |    ab c)\\" \\" (\\\\n|   ab c)\\" \\n                 \\" (\\\\n      |  ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n| ab c)\\" \\" (\\\\n|   ab c)\\"  \\n                 \\" (\\\\n  | ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\"(a\\\\n |b\\" \\"(a\\\\n  |b\\" \\n                 ;;;\\"foo (let [n (frobbotz)] \\\\n|(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;;;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;;;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;;;   \\"\\\\n        port))\\\\n        bar\\"\\n                 ;;   )\\n                 \\"   a\\\\n       |\\" \\"   a\\\\n   |\\"\\n                 \\")|s\\" \\")|s\\"\\n                 \\")\\\\n|s\\" \\")\\\\n|s\\"\\n                 \\"\#(a\\\\n|)\\" \\"\#(a\\\\n   |)\\"\\n                 ; with chimera\\n                 \\"(a\\\\n|(])\\" \\"(a\\\\n  |(])\\"\\n                 \\"(a\\\\n|\\" \\"(a\\\\n  |\\"\\n                 \\"(a\\\\n|]\\" \\"(a\\\\n  |]\\"\\n                 \\" \#(a\\\\n|]\\" \\" \#(a\\\\n    |]\\"\\n                 }]\\n      [\#\\"C-j\\"     \:paredit-newline\\n                {\\"(ab|cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"(ab|     cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"   a|\\" \\"   a\\\\n   |\\"\\n                 ;\\"foo (let [n (frobbotz)] |(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;   \\"\\\\n        port))\\\\n        bar\\")\\n                 }]\\n      [\\"M-S\\"    \:paredit-split-sexp\\n                {\\"(hello  |  world)\\" \\"(hello)| (world)\\",\\n                 \\"\\\\\\"Hello, |world\!\\\\\\"\\" \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\",\\n                 \\"(hel|lo)\\" \\"(hel)| (lo)\\",\\n                 \\"[hello |world]\\" \\"[hello]| [world]\\",\\n                 \\"{hello brave |new world}\\" \\"{hello brave}| {new world}\\",\\n                 \\"{|}\\" \\"{}| {}\\"\\n                 \\"(foo|)\\" \\"(foo)| ()\\"\\n                 \\"({|})\\" \\"({}| {})\\"\\n                 \\"(defn hello |[world])\\" \\"(defn hello)| ([world])\\"\\n                 }]\\n      [\\"M-J\\"    \:paredit-join-sexps\\n                {\\"(hello)| (world)\\" \\"(hello| world)\\",\\n                 \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\" \\"\\\\\\"Hello, |world\!\\\\\\"\\",\\n                 \\"hello-\\\\n|  world\\" \\"hello-|world\\"\\n                 \\"({\:foo \:bar}| {\:baz \:fooz})\\" \\"({\:foo \:bar| \:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} |{\:baz \:fooz})\\" \\"({\:foo \:bar |\:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} {|\:baz \:fooz})\\" \\"({\:foo \:bar} {|\:baz \:fooz})\\"\\n                 \\"({\:baz \:fooz|} {\:foo \:bar})\\" \\"({\:baz \:fooz|} {\:foo \:bar})\\"\\n                 }]\\n    ]\\n  ])" "(binding [clojure.test/*test-out* *out*] (paredit.tests/pts))" "(def \\n  ^{ \:doc \\"\\n    The format for documenting the commands is simple, and a slight varation of\\n    the original paredit.el format \:\\n    paredit-commands \:\= [ group* ]\\n    group \:\= [ group-name-str command* ]\\n    command \:\= [ default-triggering-keys \\n                 command-name-keyword \\n                 { before-after-documentation-pair* } \\n                 { before-after-non-regression-pair* }* ]\\n    before-after-documentation-pair \:\= before-after-non-regression-pair\\n    before-after-non-regression-pair \:\= before-text-spec after-text-spec\\n    before-text-spec \:\= after-text-spec \:\= text-spec\\n    text-spec \:\= a string, with the caret position indicated by a pipe character |, \\n                 and if there is a selected portion of the text, the end of the text\\n                 selection is marked with another pipe character |\\"}\\n  *paredit-commands*\\n  [\\n    [\\"Basic Insertion Commands\\"\\n\\t    [\\"(\\"         \:paredit-open-round\\n\\t                {\\"(a b |c d)\\"\\n\\t                 \\"(a b (|) c d)\\"\\n\\t                 \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar (|baz\\\\\\" quux)\\"\\n                  }\\n\\t                {\\"|\\" \\"(|)\\"\\n                   \\"(a b|c d)\\" \\"(a b (|) c d)\\"\\n\\t                 \\"(|)\\" \\"((|))\\"\\n\\t                 \\"|\\" \\"(|)\\"\\n\\t                 \\"a|\\" \\"a (|)\\"\\n\\t                 \\"(a |,b)\\" \\"(a (|),b)\\"\\n\\t                 \\"(a,| b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|)\\" \\"(a, (|))\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\(| \\" \\n\\t                 \\"~|\\" \\"~(|)\\"\\n\\t                 \\"~@|\\" \\"~@(|)\\"\\n\\t                 \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ (|) \\"\\n                  }]\\n\\t    [\\")\\"         \:paredit-close-round\\n\\t                {\\"(a |b)\\" \\"(a b)|\\"\\n\\t                 \\"(a |b) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a |b ) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a b |c [])\\" \\"(a b c [])|\\"\\n                   \\"(a b c [|] )\\" \\"(a b c [])|\\"\\n\\t                 \\"(a b |c   )\\" \\"(a b c)|\\"\\n                   \\"( a,  b |[a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"( a,  b [|a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"[ a,  b (|a b )   ]\\" \\"[ a,  b (a b)|   ]\\"\\n\\t                 \\"(a b |c ,  )\\" \\"(a b c)|\\"\\n\\t                 \\"(a b| [d e]\\" \\"(a b)| [d e]\\"\\n\\t                 \\"; Hello,| world\!\\"  \\"; Hello,)| world\!\\"\\n\\t                 \\"(  \\\\\\"Hello,| world\!\\\\\\" foo )\\" \\"(  \\\\\\"Hello,)| world\!\\\\\\" foo )\\"\\n\\t                 \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,)| world\!\\"\\n\\t                 \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\)|\\"\\n                  ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar])|\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo bar)|})\\"\\n                  }]\\n\\t    \#_[\\"M-)\\"       \:paredit-close-round-and-newline\\n\\t                {\\"(defun f (x|  ))\\"\\n\\t                 \\"(defun f (x)\\\\n  |)\\"\\n\\t                 \\"; (Foo.|\\"\\n\\t                 \\"; (Foo.)|\\"}]\\n      [\\"[\\"         \:paredit-open-square\\n                 {\\"(a b |c d)\\"  \\"(a b [|] c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar [|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b [|] c d)\\"\\n                   \\"(|)\\" \\"([|])\\"\\n                   \\"|\\" \\"[|]\\"\\n                   \\"a|\\" \\"a [|]\\"\\n                   \\"(a |,b)\\" \\"(a [|],b)\\"\\n                   \\"(a,| b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|)\\" \\"(a, [|])\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\[| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ [|] \\"}]\\n      [\\"]\\"         \:paredit-close-square\\n                  {\\"(define-key keymap [frob|  ] 'frobnicate)\\"\\n                   \\"(define-key keymap [frob]| 'frobnicate)\\"\\n                   \\"; [Bar.|\\" \\"; [Bar.]|\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,]| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,]| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\]|\\"\\n                   ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar]|)\\"\\n                   \\"({(foo |bar]))\\" \\"({(foo bar]|))\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo ]|bar)})\\"\\n                   \\"[foo (bar [baz {bleh |blah}))]\\" \\"[foo (bar [baz {bleh blah}))]|\\"\\n                   }]\\n      [\\"{\\"         \:paredit-open-curly\\n                 {\\"(a b |c d)\\"  \\"(a b {|} c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar {|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b {|} c d)\\"\\n                   \\"(|)\\" \\"({|})\\"\\n                   \\"|\\" \\"{|}\\"\\n                   \\"a|\\" \\"a {|}\\"\\n                   \\"\#|\\" \\"\#{|}\\" ; specific to clojure sets\\n                   \\"(a |,b)\\" \\"(a {|},b)\\"\\n                   \\"(a,| b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|)\\" \\"(a, {|})\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\{| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ {|} \\"\\n                   }]\\n      [\\"}\\"         \:paredit-close-curly\\n                  {\\"{a b |c   }\\" \\"{a b c}|\\"\\n                   \\"; Hello,| world\!\\"\\n                   \\"; Hello,}| world\!\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,}| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,}| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\}|\\"\\n                   \\"({(foo |bar}))\\" \\"({(foo bar}|))\\"\\n                   }]\\n      [\\"\\\\\\"\\"        \:paredit-doublequote\\n                  { \\"(frob grovel |full lexical)\\" \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\" \\"(frob grovel \\\\\\"\\\\\\"| full lexical)\\",\\n                   \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar \\\\\\\\\\\\\\"|baz\\\\\\" quux)\\",\\n                   \\";|ab\\" \\";\\\\\\"|ab\\", \\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                     \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                   \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|a\\\\\\"\\",\\n                   \\"\\\\\\"fo|o\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;\\"\#\\\\\\"fo|o\\\\\\"\\" \\"\#\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;;;\\"\#\\\\\\"foo\\\\\\"\\" \\"\#\\\\\\"foo\\\\\\"\\"\\n\\n                  ;; \\"\#|\\" \\"\#\\\\\\"|\\\\\\"\\" ; specific to clojure regexs\\n\\n                   }]\\n    ]\\n    [\\"Deleting & Killing\\"\\n      [\\"Del\\"     \:paredit-forward-delete\\n                {\\"(quu|x \\\\\\"zot\\\\\\")\\" \\"(quu| \\\\\\"zot\\\\\\")\\",\\n                 \\"(quux |\\\\\\"zot\\\\\\")\\" \\"(quux \\\\\\"|zot\\\\\\")\\",\\n                 \\"(quux \\\\\\"|zot\\\\\\")\\" \\"(quux \\\\\\"|ot\\\\\\")\\",\\n                 \\"(foo |(a) bar)\\" \\"(foo (|a) bar)\\"\\n                 \\"(foo (|a) bar)\\" \\"(foo (|) bar)\\" \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo [|] bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo {|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo (a|) bar)\\" \\"(foo (a|) bar)\\"\\n                 \\"(foo [a|] bar)\\" \\"(foo [a|] bar)\\"\\n                 \\"(foo {a|} bar)\\" \\"(foo {a|} bar)\\"\\n\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#{a|} bar)\\" \\"(foo \#{a|} bar)\\"\\n                 \\"(foo \#{a |d} bar)\\" \\"(foo \#{a |} bar)\\"\\n                 \\"(|\#{foo bar})\\" \\"(\#{|foo bar})\\"\\n\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#(a|) bar)\\" \\"(foo \#(a|) bar)\\"\\n                 \\"(foo \#(a |d) bar)\\" \\"(foo \#(a |) bar)\\"\\n                 \\"(|\#(foo bar))\\" \\"(\#(|foo bar))\\"\\n\\n                 \\"(foo \#\\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#\\\\\\"a|\\\\\\" bar)\\" \\"(foo \#\\\\\\"a|\\\\\\" bar)\\"\\n                 \\"(foo \#\\\\\\"a |d\\\\\\" bar)\\" \\"(foo \#\\\\\\"a |\\\\\\" bar)\\"\\n                 \\"(|\#\\\\\\"foo bar\\\\\\")\\" \\"(\#\\\\\\"|foo bar\\\\\\")\\"\\n\\n                 \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\n                 \\"(|(foo bar))\\" \\"((|foo bar))\\"\\n                 \\"(|[foo bar])\\" \\"([|foo bar])\\"\\n                 \\"(|{foo bar})\\" \\"({|foo bar})\\"\\n                 \\n                 \\"|\\" \\"|\\"\\n                 }]\\n      [\\"BackDel\\" \:paredit-backward-delete\\n                {\\n                 \\"(\\\\\\"zot\\\\\\" q|uux)\\" \\"(\\\\\\"zot\\\\\\" |uux)\\",\\n                 \\"(\\\\\\"zot\\\\\\"| quux)\\" \\"(\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\\\\\\"zot|\\\\\\" quux)\\" \\"(\\\\\\"zo|\\\\\\" quux)\\",\\n\\n                 \\"(\#\\\\\\"zot\\\\\\"| quux)\\" \\"(\#\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\#\\\\\\"zot|\\\\\\" quux)\\" \\"(\#\\\\\\"zo|\\\\\\" quux)\\",\\n                 \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\",\\n                 \\n                 \\"(foo bar)|\\" \\"(foo bar|)\\",\\n                 \\"(foo bar|)\\" \\"(foo ba|)\\",\\n                 \\n                 \\"|\\" \\"|\\"\\n                 \\n                 \\"\\\\\\"\\\\\\"|\\" \\"\\\\\\"|\\\\\\"\\"\\n                 \\"\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\"\#\\\\\\"\\\\\\"|\\" \\"\#\\\\\\"|\\\\\\"\\"\\n                 \\"\#\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\n                 \\"\#(foo bar)|\\" \\"\#(foo bar|)\\",\\n                 \\"\#(foo bar|)\\" \\"\#(foo ba|)\\",\\n                 \\"\#{foo bar}|\\" \\"\#{foo bar|}\\",\\n                 \\"\#{foo bar|}\\" \\"\#{foo ba|}\\",\\n                 \\"\#(|)\\" \\"|\\",\\n                 \\"\#{|}\\" \\"|\\"\\n                 }]\\n      ;\#_[\\"C-k\\"     \:paredit-kill\\n      ;          {\\"(foo bar)|     ; Useless comment\!\\"\\n      ;           \\"(foo bar)|\\",\\n      ;          \\"(|foo bar)     ; Useful comment\!\\"\\n      ;           \\"(|)     ; Useful comment\!\\",\\n      ;          \\"|(foo bar)     ; Useless line\!\\"\\n      ;           \\"|\\",\\n      ;          \\"(foo \\\\\\"|bar baz\\\\\\"\\\\n     quux)\\"\\n      ;           \\"(foo \\\\\\"|\\\\\\"\\\\n     quux)\\"}]\\n      ]\\n    \\n    [\\"Depth-Changing Commands\\"\\n     [\\"M-(\\"       \:paredit-wrap-round\\n      {\\"(foo |bar baz)\\" \\"(foo (|bar) baz)\\",\\n       \\";hel|lo\\" \\";hel(|lo\\",\\n       \\"a |\\\\\\"hi\\\\\\"\\" \\"a (|\\\\\\"hi\\\\\\")\\",\\n       \\"a |\\\\\\"hi\\\\\\"|\\" \\"a (|\\\\\\"hi\\\\\\"|)\\",\\n       \\"foo |bar| foo\\" \\"foo (|bar|) foo\\",\\n       \\"foo |bar baz| foo\\" \\"foo (|bar baz|) foo\\",\\n       \\"foo (|bar| baz) foo\\" \\"foo ((|bar|) baz) foo\\"\\n       \\"foo (|bar baz|) foo\\" \\"foo ((|bar baz|)) foo\\"\\n       ;; not-yet \\"foo |(bar| baz) foo\\" \\"foo |(bar| baz) foo\\"\\n       ;; not-yet \\"foo (bar| baz)| foo\\" \\"foo (bar| baz)| foo\\"\\n       \\"foo |(bar baz)| foo\\" \\"foo (|(bar baz)|) foo\\"\\n       \\"foo |(bar\\\\n;comment\\\\n baz)| foo\\" \\"foo (|(bar\\\\n;comment\\\\n baz)|) foo\\"\\n       ;; not-yet \\"foo |bar ba|z foo\\" \\"foo |bar ba|z foo\\",\\n       \\"foo \\\\\\"|bar ba|z\\\\\\" foo\\" \\"foo \\\\\\"(|z\\\\\\" foo\\",\\n       ;; not-yet \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\" \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\",\\n       \\"foo |bar|\\" \\"foo (|bar|)\\"\\n       \\"foo |(bar)|\\" \\"foo (|(bar)|)\\"\\n       }]\\n     ;[\\"M-s\\"       \:paredit-splice-sexp\\n     ;           {\\"(foo (bar| baz) quux)\\"\\n     ;            \\"(foo bar| baz quux)\\"}]\\n     ;[(\\"M-<up>\\" \\"ESC <up>\\")\\n     ;           paredit-splice-sexp-killing-backward\\n     ;           (\\"(foo (let ((x 5)) |(sqrt n)) bar)\\"\\n     ;            \\"(foo (sqrt n) bar)\\")]\\n     ;((\\"M-<down>\\" \\"ESC <down>\\")\\n     ;           paredit-splice-sexp-killing-forward\\n     ;           (\\"(a (b c| d e) f)\\"\\n     ;            \\"(a b c f)\\"))\\n     [\\"M-r\\"       \:paredit-raise-sexp\\n                {\\"(dynamic-wind in (lambda () |body|) out)\\" \\"(dynamic-wind in |body out)\\"\\n                 \\"(dynamic-wind in |body| out)\\" \\"|body\\" \\n                 \\"(foo bar|)\\" \\"(foo bar|)\\"\\n                 \\"(foo |bar)\\" \\"|bar\\"\\n                 \\"(foo |(bar))\\" \\"|(bar)\\"\\n                 \\"(foo |(bar]|)\\" \\"|(bar]\\"\\n                 }]\\n     ]\\n    \\n    [\\"Selection\\"\\n     [\\"Shift+Alt+Left\\" \:paredit-expand-left\\n                {\\n                 \\"foo bar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo bar |baz\\" \\"foo bar| |baz\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 bar b|a|z\\" \\"foo1 bar |baz|\\"\\n                 \\"foo2 bar ba|z|\\" \\"foo2 bar |baz|\\"\\n                 \\"foo3 bar |baz|\\" \\"foo3 bar| baz|\\"\\n                 \\"foo bar| baz|\\" \\"foo |bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"foo| bar baz|\\"\\n                 \\"|(foo bar baz)|\\" \\"|(foo bar baz)|\\"\\n                 ;;not-yet \\"|fo|o bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo| bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo b|ar baz\\" \\"|foo bar baz|\\" \\n                 \\"foo (bar| baz)\\" \\"foo (|bar| baz)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 (|bar| baz)\\" \\"foo1 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"(foo bar|)\\" \\"(foo |bar|)\\"\\n                 \\"fooz foo |(bar)| baz\\" \\"fooz foo| (bar)| baz\\"\\n                 \\"fooz foo| (bar)| baz\\" \\"fooz |foo (bar)| baz\\"\\n                 ;with \:chimera\\n                 \\"(foo bar|]\\" \\"(foo |bar|]\\"\\n                 \\"(foo {bar)|]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Right\\" \:paredit-expand-right\\n                {\\n                 \\"foo bar| baz\\" \\"foo bar| |baz\\"\\n                 \\"foo4 bar |baz\\" \\"foo4 bar |baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo5 bar b|a|z\\" \\"foo5 bar |baz|\\"\\n                 \\"foo6 bar ba|z|\\" \\"foo6 bar |baz|\\"\\n                 ;;not-yet \\"foo bar |baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo| bar baz\\";;\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo |bar baz\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar| baz\\"\\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo (bar| baz)\\" \\"foo (bar| |baz)\\"\\n                 \\"foo (bar |baz)\\" \\"foo (bar |baz|)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo2 (bar baz|)\\" \\"foo2 |(bar baz)|\\"\\n                 \\"foo3 (bar |baz|)\\" \\"foo3 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"(foo |bar|]\\"\\n                 \\"(foo |{bar)]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Up\\" \:paredit-expand-up\\n                {\\n                 \\"abc defgh|i \\" \\"abc |defghi| \\"\\n                 \\"|abc| defghi \\" \\"|abc defghi |\\"\\n                 \\"foo bar| baz\\" \\"|foo bar baz|\\"\\n                 \\"foo bar |baz\\" \\"|foo bar baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo7 bar b|a|z\\" \\"foo7 bar |baz|\\"\\n                 \\"foo8 bar ba|z|\\" \\"foo8 bar |baz|\\"\\n                 \\"foo9 bar |baz|\\" \\"|foo9 bar baz|\\"\\n                 \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo4 (bar| baz)\\" \\"foo4 |(bar baz)|\\"\\n                 \\"foo5 (bar |baz)\\" \\"foo5 |(bar baz)|\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo6 (bar baz|)\\" \\"foo6 |(bar baz)|\\"\\n                 \\"foo7 (bar |baz|)\\" \\"foo7 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"foo ([|bar])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo ([b|ar])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([b|a|r])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([|bar|])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo (|[bar]|)\\" \\"foo |([bar])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"|(foo bar]|\\"\\n                 \\"(foo |{bar)]\\" \\"|(foo {bar)]|\\"\\n                 }]\\n     ]\\n    [\\"Miscellaneous\\"             \\n      [\\"Tab\\"     \:paredit-indent-line\\n                {\\"[a\\\\n|b]\\"  \\"[a\\\\n |b]\\"\\n                 \\"([a1\\\\n|b])\\"  \\"([a1\\\\n  |b])\\"\\n                 \\"([a1b\\\\n  |b])\\" \\"([a1b\\\\n  |b])\\"\\n                 \\"(a\\\\n |)\\" \\"(a\\\\n  |)\\"\\n                 \\"(a b c\\\\nd| e)\\" \\"(a b c\\\\n  d| e)\\"\\n                 \\"|(toto)\\" \\"|(toto)\\"\\n                 \\"(a\\\\n  ;sdfdf\\\\n  |b)\\" \\"(a\\\\n  ;sdfdf\\\\n  |b)\\"\\n                 \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\" \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\"\\n                 \\"[a\\\\n|\\\\\\"a\\\\\\"]\\" \\"[a\\\\n |\\\\\\"a\\\\\\"]\\"\\n                 \\"(a\\\\n\\\\t|b)\\" \\"(a\\\\n  |b)\\"\\n                 \\"(\\\\n|\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n  |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n   |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n , |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"  {\\\\n|a}\\" \\"  {\\\\n   |a}\\"\\n                 \\" (\\\\n|    ab c)\\" \\" (\\\\n|   ab c)\\"\\n                 \\" (\\\\n |   ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |  ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\" (\\\\n   | ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n    |ab c)\\" \\" (\\\\n   |ab c)\\" \\n                 \\" (\\\\n    a|b c)\\" \\" (\\\\n   a|b c)\\"  \\n                 \\" (\\\\n    |    ab c)\\" \\" (\\\\n|   ab c)\\" \\n                 \\" (\\\\n      |  ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n| ab c)\\" \\" (\\\\n|   ab c)\\"  \\n                 \\" (\\\\n  | ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\"(a\\\\n |b\\" \\"(a\\\\n  |b\\" \\n                 ;;;\\"foo (let [n (frobbotz)] \\\\n|(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;;;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;;;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;;;   \\"\\\\n        port))\\\\n        bar\\"\\n                 ;;   )\\n                 \\"   a\\\\n       |\\" \\"   a\\\\n   |\\"\\n                 \\")|s\\" \\")|s\\"\\n                 \\")\\\\n|s\\" \\")\\\\n|s\\"\\n                 \\"\#(a\\\\n|)\\" \\"\#(a\\\\n   |)\\"\\n                 ; with chimera\\n                 \\"(a\\\\n|(])\\" \\"(a\\\\n  |(])\\"\\n                 \\"(a\\\\n|\\" \\"(a\\\\n  |\\"\\n                 \\"(a\\\\n|]\\" \\"(a\\\\n  |]\\"\\n                 \\" \#(a\\\\n|]\\" \\" \#(a\\\\n    |]\\"\\n                 }]\\n      [\#\\"C-j\\"     \:paredit-newline\\n                {\\"(ab|cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"(ab|     cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"   a|\\" \\"   a\\\\n   |\\"\\n                 ;\\"foo (let [n (frobbotz)] |(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;   \\"\\\\n        port))\\\\n        bar\\")\\n                 }]\\n      [\\"M-S\\"    \:paredit-split-sexp\\n                {\\"(hello  |  world)\\" \\"(hello)| (world)\\",\\n                 \\"\\\\\\"Hello, |world\!\\\\\\"\\" \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\",\\n                 \\"(hel|lo)\\" \\"(hel)| (lo)\\",\\n                 \\"[hello |world]\\" \\"[hello]| [world]\\",\\n                 \\"{hello brave |new world}\\" \\"{hello brave}| {new world}\\",\\n                 \\"{|}\\" \\"{}| {}\\"\\n                 \\"(foo|)\\" \\"(foo)| ()\\"\\n                 \\"({|})\\" \\"({}| {})\\"\\n                 \\"(defn hello |[world])\\" \\"(defn hello)| ([world])\\"\\n                 }]\\n      [\\"M-J\\"    \:paredit-join-sexps\\n                {\\"(hello)| (world)\\" \\"(hello| world)\\",\\n                 \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\" \\"\\\\\\"Hello, |world\!\\\\\\"\\",\\n                 \\"hello-\\\\n|  world\\" \\"hello-|world\\"\\n                 \\"({\:foo \:bar}| {\:baz \:fooz})\\" \\"({\:foo \:bar| \:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} |{\:baz \:fooz})\\" \\"({\:foo \:bar |\:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} {|\:baz \:fooz})\\" \\"({\:foo \:bar} {|\:baz \:fooz})\\"\\n                 \\"({\:baz \:fooz|} {\:foo \:bar})\\" \\"({\:baz \:fooz|} {\:foo \:bar})\\"\\n                 }]\\n    ]\\n  ])" "(def \\n  ^{ \:doc \\"\\n    The format for documenting the commands is simple, and a slight varation of\\n    the original paredit.el format \:\\n    paredit-commands \:\= [ group* ]\\n    group \:\= [ group-name-str command* ]\\n    command \:\= [ default-triggering-keys \\n                 command-name-keyword \\n                 { before-after-documentation-pair* } \\n                 { before-after-non-regression-pair* }* ]\\n    before-after-documentation-pair \:\= before-after-non-regression-pair\\n    before-after-non-regression-pair \:\= before-text-spec after-text-spec\\n    before-text-spec \:\= after-text-spec \:\= text-spec\\n    text-spec \:\= a string, with the caret position indicated by a pipe character |, \\n                 and if there is a selected portion of the text, the end of the text\\n                 selection is marked with another pipe character |\\"}\\n  *paredit-commands*\\n  [\\n    [\\"Basic Insertion Commands\\"\\n\\t    [\\"(\\"         \:paredit-open-round\\n\\t                {\\"(a b |c d)\\"\\n\\t                 \\"(a b (|) c d)\\"\\n\\t                 \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar (|baz\\\\\\" quux)\\"\\n                  }\\n\\t                {\\"(a b|c d)\\" \\"(a b (|) c d)\\"\\n\\t                 \\"(|)\\" \\"((|))\\"\\n                   \\"|\\" \\"(|)\\"\\n\\t                 \\"|\\" \\"(|)\\"\\n\\t                 \\"a|\\" \\"a (|)\\"\\n\\t                 \\"(a |,b)\\" \\"(a (|),b)\\"\\n\\t                 \\"(a,| b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|b)\\" \\"(a, (|) b)\\"\\n\\t                 \\"(a,|)\\" \\"(a, (|))\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\(| \\" \\n\\t                 \\"~|\\" \\"~(|)\\"\\n\\t                 \\"~@|\\" \\"~@(|)\\"\\n\\t                 \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ (|) \\"\\n                  }]\\n\\t    [\\")\\"         \:paredit-close-round\\n\\t                {\\"(a |b)\\" \\"(a b)|\\"\\n\\t                 \\"(a |b) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a |b ) cd\\" \\"(a b)| cd\\"\\n\\t                 \\"(a b |c [])\\" \\"(a b c [])|\\"\\n                   \\"(a b c [|] )\\" \\"(a b c [])|\\"\\n\\t                 \\"(a b |c   )\\" \\"(a b c)|\\"\\n                   \\"( a,  b |[a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"( a,  b [|a b ]   )\\" \\"( a,  b [a b ])|\\"\\n                   \\"[ a,  b (|a b )   ]\\" \\"[ a,  b (a b)|   ]\\"\\n\\t                 \\"(a b |c ,  )\\" \\"(a b c)|\\"\\n\\t                 \\"(a b| [d e]\\" \\"(a b)| [d e]\\"\\n\\t                 \\"; Hello,| world\!\\"  \\"; Hello,)| world\!\\"\\n\\t                 \\"(  \\\\\\"Hello,| world\!\\\\\\" foo )\\" \\"(  \\\\\\"Hello,)| world\!\\\\\\" foo )\\"\\n\\t                 \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,)| world\!\\"\\n\\t                 \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\)|\\"\\n                  ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar])|\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo bar)|})\\"\\n                  }]\\n\\t    \#_[\\"M-)\\"       \:paredit-close-round-and-newline\\n\\t                {\\"(defun f (x|  ))\\"\\n\\t                 \\"(defun f (x)\\\\n  |)\\"\\n\\t                 \\"; (Foo.|\\"\\n\\t                 \\"; (Foo.)|\\"}]\\n      [\\"[\\"         \:paredit-open-square\\n                 {\\"(a b |c d)\\"  \\"(a b [|] c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar [|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b [|] c d)\\"\\n                   \\"(|)\\" \\"([|])\\"\\n                   \\"|\\" \\"[|]\\"\\n                   \\"a|\\" \\"a [|]\\"\\n                   \\"(a |,b)\\" \\"(a [|],b)\\"\\n                   \\"(a,| b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|b)\\" \\"(a, [|] b)\\"\\n                   \\"(a,|)\\" \\"(a, [|])\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\[| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ [|] \\"}]\\n      [\\"]\\"         \:paredit-close-square\\n                  {\\"(define-key keymap [frob|  ] 'frobnicate)\\"\\n                   \\"(define-key keymap [frob]| 'frobnicate)\\"\\n                   \\"; [Bar.|\\" \\"; [Bar.]|\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,]| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,]| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\]|\\"\\n                   ; tests with the new \:chimera\\n                   \\"({foo |bar])\\" \\"({foo bar]|)\\"\\n                   \\"({(foo |bar]))\\" \\"({(foo bar]|))\\"\\n                   \\"({[foo |bar)})\\" \\"({[foo ]|bar)})\\"\\n                   \\"[foo (bar [baz {bleh |blah}))]\\" \\"[foo (bar [baz {bleh blah}))]|\\"\\n                   }]\\n      [\\"{\\"         \:paredit-open-curly\\n                 {\\"(a b |c d)\\"  \\"(a b {|} c d)\\"\\n                  \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar {|baz\\\\\\" quux)\\" \\n                  }\\n                  {\\"(a b|c d)\\" \\"(a b {|} c d)\\"\\n                   \\"(|)\\" \\"({|})\\"\\n                   \\"|\\" \\"{|}\\"\\n                   \\"a|\\" \\"a {|}\\"\\n                   \\"\#|\\" \\"\#{|}\\" ; specific to clojure sets\\n                   \\"(a |,b)\\" \\"(a {|},b)\\"\\n                   \\"(a,| b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|b)\\" \\"(a, {|} b)\\"\\n                   \\"(a,|)\\" \\"(a, {|})\\"\\n                   \\"\\\\\\\\| \\" \\"\\\\\\\\{| \\" \\n                   \\"\\\\\\\\\\\\\\\\| \\" \\"\\\\\\\\\\\\\\\\ {|} \\"\\n                   }]\\n      [\\"}\\"         \:paredit-close-curly\\n                  {\\"{a b |c   }\\" \\"{a b c}|\\"\\n                   \\"; Hello,| world\!\\"\\n                   \\"; Hello,}| world\!\\"\\n                   \\"  \\\\\\"Hello,| world\!\\\\\\" foo\\" \\"  \\\\\\"Hello,}| world\!\\\\\\" foo\\"\\n                   \\"  \\\\\\"Hello,| world\!\\" \\"  \\\\\\"Hello,}| world\!\\"\\n                   \\"foo \\\\\\\\|\\" \\"foo \\\\\\\\}|\\"\\n                   \\"({(foo |bar}))\\" \\"({(foo bar}|))\\"\\n                   }]\\n      [\\"\\\\\\"\\"        \:paredit-doublequote\\n                  { \\"(frob grovel |full lexical)\\" \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"|\\\\\\" full lexical)\\" \\"(frob grovel \\\\\\"\\\\\\"| full lexical)\\",\\n                   \\"(foo \\\\\\"bar |baz\\\\\\" quux)\\" \\"(foo \\\\\\"bar \\\\\\\\\\\\\\"|baz\\\\\\" quux)\\",\\n                   \\";|ab\\" \\";\\\\\\"|ab\\", \\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\|bar\\\\\\" full lexical)\\"\\n                     \\"(frob grovel \\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\" full lexical)\\",\\n                   \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"o\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                     \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b|ar\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \\\\\\"b\\\\\\\\\\\\\\"|ar\\\\\\"\\",\\n                   \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\"\\" \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|a\\\\\\"\\",\\n                   \\"\\\\\\"fo|o\\\\\\"\\" \\"\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;\\"\#\\\\\\"fo|o\\\\\\"\\" \\"\#\\\\\\"fo\\\\\\\\\\\\\\"|o\\\\\\"\\",\\n                   ;;;\\"\#\\\\\\"foo\\\\\\"\\" \\"\#\\\\\\"foo\\\\\\"\\"\\n\\n                  ;; \\"\#|\\" \\"\#\\\\\\"|\\\\\\"\\" ; specific to clojure regexs\\n\\n                   }]\\n    ]\\n    [\\"Deleting & Killing\\"\\n      [\\"Del\\"     \:paredit-forward-delete\\n                {\\"(quu|x \\\\\\"zot\\\\\\")\\" \\"(quu| \\\\\\"zot\\\\\\")\\",\\n                 \\"(quux |\\\\\\"zot\\\\\\")\\" \\"(quux \\\\\\"|zot\\\\\\")\\",\\n                 \\"(quux \\\\\\"|zot\\\\\\")\\" \\"(quux \\\\\\"|ot\\\\\\")\\",\\n                 \\"(foo |(a) bar)\\" \\"(foo (|a) bar)\\"\\n                 \\"(foo (|a) bar)\\" \\"(foo (|) bar)\\" \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo [|] bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo {|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo (a|) bar)\\" \\"(foo (a|) bar)\\"\\n                 \\"(foo [a|] bar)\\" \\"(foo [a|] bar)\\"\\n                 \\"(foo {a|} bar)\\" \\"(foo {a|} bar)\\"\\n\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#{a|} bar)\\" \\"(foo \#{a|} bar)\\"\\n                 \\"(foo \#{a |d} bar)\\" \\"(foo \#{a |} bar)\\"\\n                 \\"(|\#{foo bar})\\" \\"(\#{|foo bar})\\"\\n\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#(a|) bar)\\" \\"(foo \#(a|) bar)\\"\\n                 \\"(foo \#(a |d) bar)\\" \\"(foo \#(a |) bar)\\"\\n                 \\"(|\#(foo bar))\\" \\"(\#(|foo bar))\\"\\n\\n                 \\"(foo \#\\\\\\"|\\\\\\" bar)\\" \\"(foo | bar)\\"\\n                 \\"(foo \#\\\\\\"a|\\\\\\" bar)\\" \\"(foo \#\\\\\\"a|\\\\\\" bar)\\"\\n                 \\"(foo \#\\\\\\"a |d\\\\\\" bar)\\" \\"(foo \#\\\\\\"a |\\\\\\" bar)\\"\\n                 \\"(|\#\\\\\\"foo bar\\\\\\")\\" \\"(\#\\\\\\"|foo bar\\\\\\")\\"\\n\\n                 \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\"(foo \\\\\\"a|\\\\\\" bar)\\" \\n                 \\"(|(foo bar))\\" \\"((|foo bar))\\"\\n                 \\"(|[foo bar])\\" \\"([|foo bar])\\"\\n                 \\"(|{foo bar})\\" \\"({|foo bar})\\"\\n                 \\n                 \\"|\\" \\"|\\"\\n                 }]\\n      [\\"BackDel\\" \:paredit-backward-delete\\n                {\\n                 \\"(\\\\\\"zot\\\\\\" q|uux)\\" \\"(\\\\\\"zot\\\\\\" |uux)\\",\\n                 \\"(\\\\\\"zot\\\\\\"| quux)\\" \\"(\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\\\\\\"zot|\\\\\\" quux)\\" \\"(\\\\\\"zo|\\\\\\" quux)\\",\\n\\n                 \\"(\#\\\\\\"zot\\\\\\"| quux)\\" \\"(\#\\\\\\"zot|\\\\\\" quux)\\",\\n                 \\"(\#\\\\\\"zot|\\\\\\" quux)\\" \\"(\#\\\\\\"zo|\\\\\\" quux)\\",\\n                 \\n                 \\"(foo (|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#(|) bar)\\" \\"(foo | bar)\\",\\n                 \\"(foo \#{|} bar)\\" \\"(foo | bar)\\",\\n                 \\n                 \\"(foo bar)|\\" \\"(foo bar|)\\",\\n                 \\"(foo bar|)\\" \\"(foo ba|)\\",\\n                 \\n                 \\"|\\" \\"|\\"\\n                 \\n                 \\"\\\\\\"\\\\\\"|\\" \\"\\\\\\"|\\\\\\"\\"\\n                 \\"\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\"\#\\\\\\"\\\\\\"|\\" \\"\#\\\\\\"|\\\\\\"\\"\\n                 \\"\#\\\\\\"|\\\\\\"\\" \\"|\\"\\n                 \\n                 \\"\#(foo bar)|\\" \\"\#(foo bar|)\\",\\n                 \\"\#(foo bar|)\\" \\"\#(foo ba|)\\",\\n                 \\"\#{foo bar}|\\" \\"\#{foo bar|}\\",\\n                 \\"\#{foo bar|}\\" \\"\#{foo ba|}\\",\\n                 \\"\#(|)\\" \\"|\\",\\n                 \\"\#{|}\\" \\"|\\"\\n                 }]\\n      ;\#_[\\"C-k\\"     \:paredit-kill\\n      ;          {\\"(foo bar)|     ; Useless comment\!\\"\\n      ;           \\"(foo bar)|\\",\\n      ;          \\"(|foo bar)     ; Useful comment\!\\"\\n      ;           \\"(|)     ; Useful comment\!\\",\\n      ;          \\"|(foo bar)     ; Useless line\!\\"\\n      ;           \\"|\\",\\n      ;          \\"(foo \\\\\\"|bar baz\\\\\\"\\\\n     quux)\\"\\n      ;           \\"(foo \\\\\\"|\\\\\\"\\\\n     quux)\\"}]\\n      ]\\n    \\n    [\\"Depth-Changing Commands\\"\\n     [\\"M-(\\"       \:paredit-wrap-round\\n      {\\"(foo |bar baz)\\" \\"(foo (|bar) baz)\\",\\n       \\";hel|lo\\" \\";hel(|lo\\",\\n       \\"a |\\\\\\"hi\\\\\\"\\" \\"a (|\\\\\\"hi\\\\\\")\\",\\n       \\"a |\\\\\\"hi\\\\\\"|\\" \\"a (|\\\\\\"hi\\\\\\"|)\\",\\n       \\"foo |bar| foo\\" \\"foo (|bar|) foo\\",\\n       \\"foo |bar baz| foo\\" \\"foo (|bar baz|) foo\\",\\n       \\"foo (|bar| baz) foo\\" \\"foo ((|bar|) baz) foo\\"\\n       \\"foo (|bar baz|) foo\\" \\"foo ((|bar baz|)) foo\\"\\n       ;; not-yet \\"foo |(bar| baz) foo\\" \\"foo |(bar| baz) foo\\"\\n       ;; not-yet \\"foo (bar| baz)| foo\\" \\"foo (bar| baz)| foo\\"\\n       \\"foo |(bar baz)| foo\\" \\"foo (|(bar baz)|) foo\\"\\n       \\"foo |(bar\\\\n;comment\\\\n baz)| foo\\" \\"foo (|(bar\\\\n;comment\\\\n baz)|) foo\\"\\n       ;; not-yet \\"foo |bar ba|z foo\\" \\"foo |bar ba|z foo\\",\\n       \\"foo \\\\\\"|bar ba|z\\\\\\" foo\\" \\"foo \\\\\\"(|z\\\\\\" foo\\",\\n       ;; not-yet \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\" \\"foo |\\\\\\"bar ba|z\\\\\\" foo\\",\\n       \\"foo |bar|\\" \\"foo (|bar|)\\"\\n       \\"foo |(bar)|\\" \\"foo (|(bar)|)\\"\\n       }]\\n     ;[\\"M-s\\"       \:paredit-splice-sexp\\n     ;           {\\"(foo (bar| baz) quux)\\"\\n     ;            \\"(foo bar| baz quux)\\"}]\\n     ;[(\\"M-<up>\\" \\"ESC <up>\\")\\n     ;           paredit-splice-sexp-killing-backward\\n     ;           (\\"(foo (let ((x 5)) |(sqrt n)) bar)\\"\\n     ;            \\"(foo (sqrt n) bar)\\")]\\n     ;((\\"M-<down>\\" \\"ESC <down>\\")\\n     ;           paredit-splice-sexp-killing-forward\\n     ;           (\\"(a (b c| d e) f)\\"\\n     ;            \\"(a b c f)\\"))\\n     [\\"M-r\\"       \:paredit-raise-sexp\\n                {\\"(dynamic-wind in (lambda () |body|) out)\\" \\"(dynamic-wind in |body out)\\"\\n                 \\"(dynamic-wind in |body| out)\\" \\"|body\\" \\n                 \\"(foo bar|)\\" \\"(foo bar|)\\"\\n                 \\"(foo |bar)\\" \\"|bar\\"\\n                 \\"(foo |(bar))\\" \\"|(bar)\\"\\n                 \\"(foo |(bar]|)\\" \\"|(bar]\\"\\n                 }]\\n     ]\\n    \\n    [\\"Selection\\"\\n     [\\"Shift+Alt+Left\\" \:paredit-expand-left\\n                {\\n                 \\"foo bar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo bar |baz\\" \\"foo bar| |baz\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 bar b|a|z\\" \\"foo1 bar |baz|\\"\\n                 \\"foo2 bar ba|z|\\" \\"foo2 bar |baz|\\"\\n                 \\"foo3 bar |baz|\\" \\"foo3 bar| baz|\\"\\n                 \\"foo bar| baz|\\" \\"foo |bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"foo| bar baz|\\"\\n                 \\"|(foo bar baz)|\\" \\"|(foo bar baz)|\\"\\n                 ;;not-yet \\"|fo|o bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo| bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 ;;not-yet \\"|foo b|ar baz\\" \\"|foo bar baz|\\" \\n                 \\"foo (bar| baz)\\" \\"foo (|bar| baz)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo1 (|bar| baz)\\" \\"foo1 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"(foo bar|)\\" \\"(foo |bar|)\\"\\n                 \\"fooz foo |(bar)| baz\\" \\"fooz foo| (bar)| baz\\"\\n                 \\"fooz foo| (bar)| baz\\" \\"fooz |foo (bar)| baz\\"\\n                 ;with \:chimera\\n                 \\"(foo bar|]\\" \\"(foo |bar|]\\"\\n                 \\"(foo {bar)|]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Right\\" \:paredit-expand-right\\n                {\\n                 \\"foo bar| baz\\" \\"foo bar| |baz\\"\\n                 \\"foo4 bar |baz\\" \\"foo4 bar |baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo5 bar b|a|z\\" \\"foo5 bar |baz|\\"\\n                 \\"foo6 bar ba|z|\\" \\"foo6 bar |baz|\\"\\n                 ;;not-yet \\"foo bar |baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 ;;not-yet \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo| bar baz\\";;\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo |bar baz\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar| baz\\"\\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo (bar| baz)\\" \\"foo (bar| |baz)\\"\\n                 \\"foo (bar |baz)\\" \\"foo (bar |baz|)\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo2 (bar baz|)\\" \\"foo2 |(bar baz)|\\"\\n                 \\"foo3 (bar |baz|)\\" \\"foo3 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"(foo |bar|]\\"\\n                 \\"(foo |{bar)]\\" \\"(foo |{bar)|]\\"\\n                 }]\\n     [\\"Shift+Alt+Up\\" \:paredit-expand-up\\n                {\\n                 \\"abc defgh|i \\" \\"abc |defghi| \\"\\n                 \\"|abc| defghi \\" \\"|abc defghi |\\"\\n                 \\"foo bar| baz\\" \\"|foo bar baz|\\"\\n                 \\"foo bar |baz\\" \\"|foo bar baz|\\"\\n                 \\"foo ba|r baz\\" \\"foo |bar| baz\\"\\n                 \\"foo7 bar b|a|z\\" \\"foo7 bar |baz|\\"\\n                 \\"foo8 bar ba|z|\\" \\"foo8 bar |baz|\\"\\n                 \\"foo9 bar |baz|\\" \\"|foo9 bar baz|\\"\\n                 \\"foo bar| baz|\\" \\"|foo bar baz|\\"\\n                 \\"foo |bar baz|\\" \\"|foo bar baz|\\"\\n                 \\"|foo bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|f|oo bar baz\\" \\"|foo| bar baz\\"\\n                 \\"|foo| bar baz\\" \\"|foo bar baz|\\"\\n                 \\"|foo |bar baz\\" \\"|foo bar baz|\\" \\n                 \\"|foo b|ar baz\\" \\"|foo bar| baz\\"\\n                 \\"foo4 (bar| baz)\\" \\"foo4 |(bar baz)|\\"\\n                 \\"foo5 (bar |baz)\\" \\"foo5 |(bar baz)|\\"\\n                 \\"foo b|ar| baz\\" \\"foo |bar| baz\\"\\n                 \\"foo6 (bar baz|)\\" \\"foo6 |(bar baz)|\\"\\n                 \\"foo7 (bar |baz|)\\" \\"foo7 |(bar baz)|\\"\\n                 \\"foo \\\\\\"bar |baz\\\\\\"\\" \\"foo |\\\\\\"bar baz\\\\\\"|\\"\\n                 \\"foo;ba|r\\\\nbaz\\" \\"foo|;bar|\\\\nbaz\\"\\n                 \\"foo (bar [ba|z] |foo)\\" \\"foo (bar |[baz] |foo)\\"\\n                 \\"foo (bar [ba|z]) (foo [bar (b|az)])\\" \\"foo |(bar [baz]) (foo [bar (baz)])|\\"\\n                 \\"foo |(bar [baz (b|am)])\\" \\"foo |(bar [baz (bam)])|\\"\\n                 \\"foo ([|bar])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo ([b|ar])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([b|a|r])\\" \\"foo ([|bar|])\\"\\n                 \\"foo ([|bar|])\\" \\"foo (|[bar]|)\\"\\n                 \\"foo (|[bar]|)\\" \\"foo |([bar])|\\"\\n                 ;with \:chimera\\n                 \\"(foo |bar]\\" \\"|(foo bar]|\\"\\n                 \\"(foo |{bar)]\\" \\"|(foo {bar)]|\\"\\n                 }]\\n     ]\\n    [\\"Miscellaneous\\"             \\n      [\\"Tab\\"     \:paredit-indent-line\\n                {\\"[a\\\\n|b]\\"  \\"[a\\\\n |b]\\"\\n                 \\"([a1\\\\n|b])\\"  \\"([a1\\\\n  |b])\\"\\n                 \\"([a1b\\\\n  |b])\\" \\"([a1b\\\\n  |b])\\"\\n                 \\"(a\\\\n |)\\" \\"(a\\\\n  |)\\"\\n                 \\"(a b c\\\\nd| e)\\" \\"(a b c\\\\n  d| e)\\"\\n                 \\"|(toto)\\" \\"|(toto)\\"\\n                 \\"(a\\\\n  ;sdfdf\\\\n  |b)\\" \\"(a\\\\n  ;sdfdf\\\\n  |b)\\"\\n                 \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\" \\"[a\\\\n \\\\\\"b\\\\n |\\\\\\"]\\"\\n                 \\"[a\\\\n|\\\\\\"a\\\\\\"]\\" \\"[a\\\\n |\\\\\\"a\\\\\\"]\\"\\n                 \\"(a\\\\n\\\\t|b)\\" \\"(a\\\\n  |b)\\"\\n                 \\"(\\\\n|\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n  |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n   |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"(\\\\n , |\\\\n)\\" \\"(\\\\n  |\\\\n)\\"\\n                 \\"  {\\\\n|a}\\" \\"  {\\\\n   |a}\\"\\n                 \\" (\\\\n|    ab c)\\" \\" (\\\\n|   ab c)\\"\\n                 \\" (\\\\n |   ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |  ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\" (\\\\n   | ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n    |ab c)\\" \\" (\\\\n   |ab c)\\" \\n                 \\" (\\\\n    a|b c)\\" \\" (\\\\n   a|b c)\\"  \\n                 \\" (\\\\n    |    ab c)\\" \\" (\\\\n|   ab c)\\" \\n                 \\" (\\\\n      |  ab c)\\" \\" (\\\\n |  ab c)\\"\\n                 \\" (\\\\n  |ab c)\\" \\" (\\\\n   |ab c)\\"\\n                 \\" (\\\\n| ab c)\\" \\" (\\\\n|   ab c)\\"  \\n                 \\" (\\\\n  | ab c)\\" \\" (\\\\n  | ab c)\\"\\n                 \\"(a\\\\n |b\\" \\"(a\\\\n  |b\\" \\n                 ;;;\\"foo (let [n (frobbotz)] \\\\n|(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;;;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;;;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;;;   \\"\\\\n        port))\\\\n        bar\\"\\n                 ;;   )\\n                 \\"   a\\\\n       |\\" \\"   a\\\\n   |\\"\\n                 \\")|s\\" \\")|s\\"\\n                 \\")\\\\n|s\\" \\")\\\\n|s\\"\\n                 \\"\#(a\\\\n|)\\" \\"\#(a\\\\n   |)\\"\\n                 ; with chimera\\n                 \\"(a\\\\n|(])\\" \\"(a\\\\n  |(])\\"\\n                 \\"(a\\\\n|\\" \\"(a\\\\n  |\\"\\n                 \\"(a\\\\n|]\\" \\"(a\\\\n  |]\\"\\n                 \\" \#(a\\\\n|]\\" \\" \#(a\\\\n    |]\\"\\n                 }]\\n      [\#\\"C-j\\"     \:paredit-newline\\n                {\\"(ab|cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"(ab|     cd)\\" \\"(ab\\\\n  |cd)\\"\\n                 \\"   a|\\" \\"   a\\\\n   |\\"\\n                 ;\\"foo (let [n (frobbotz)] |(display (+ n 1)\\\\nport))\\\\n        bar\\"\\n                 ;(str \\"foo (let [n (frobbotz)]\\"\\n                 ;   \\"\\\\n      |(display (+ n 1)\\"\\n                 ;   \\"\\\\n        port))\\\\n        bar\\")\\n                 }]\\n      [\\"M-S\\"    \:paredit-split-sexp\\n                {\\"(hello  |  world)\\" \\"(hello)| (world)\\",\\n                 \\"\\\\\\"Hello, |world\!\\\\\\"\\" \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\",\\n                 \\"(hel|lo)\\" \\"(hel)| (lo)\\",\\n                 \\"[hello |world]\\" \\"[hello]| [world]\\",\\n                 \\"{hello brave |new world}\\" \\"{hello brave}| {new world}\\",\\n                 \\"{|}\\" \\"{}| {}\\"\\n                 \\"(foo|)\\" \\"(foo)| ()\\"\\n                 \\"({|})\\" \\"({}| {})\\"\\n                 \\"(defn hello |[world])\\" \\"(defn hello)| ([world])\\"\\n                 }]\\n      [\\"M-J\\"    \:paredit-join-sexps\\n                {\\"(hello)| (world)\\" \\"(hello| world)\\",\\n                 \\"\\\\\\"Hello, \\\\\\"| \\\\\\"world\!\\\\\\"\\" \\"\\\\\\"Hello, |world\!\\\\\\"\\",\\n                 \\"hello-\\\\n|  world\\" \\"hello-|world\\"\\n                 \\"({\:foo \:bar}| {\:baz \:fooz})\\" \\"({\:foo \:bar| \:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} |{\:baz \:fooz})\\" \\"({\:foo \:bar |\:baz \:fooz})\\"\\n                 \\"({\:foo \:bar} {|\:baz \:fooz})\\" \\"({\:foo \:bar} {|\:baz \:fooz})\\"\\n                 \\"({\:baz \:fooz|} {\:foo \:bar})\\" \\"({\:baz \:fooz|} {\:foo \:bar})\\"\\n                 }]\\n    ]\\n  ])" "(binding [clojure.test/*test-out* *out*] (paredit.tests/pts))" "(defn -customizeDocumentCommand \\n  [\#^ccw.editors.antlrbased.PareditAutoEditStrategy this, \#^IDocument document, \#^DocumentCommand command]\\n  (let [^IClojureEditor editor (-> this .state deref \:editor)]\\n    (when (and (.doit command) \\n               (not (.isInEscapeSequence editor)) \\n               (.isStructuralEditionPossible editor))\\n      (println \\"yo\!\\")\\n      (let [signed-selection (bean (.getSignedSelection editor))\\n            ;_ (println (str \\"signed-selection\:\\" signed-selection))\\n            document-text {\:text (.get document) \\n                           \:caret-offset (+ (\:offset signed-selection) (\:length signed-selection)) \\n                           \:selection-length (\:length signed-selection)}\\n            par-command {\:text (.text command) \:offset (.offset command) \:length (.length command)}\\n            ;_ (println (str \\"par-command\:\\" par-command))\\n            [par-command par-text] (paredit-args par-command document-text)\\n            ;_ (println \\"here is the par-command\:\\" par-command)\\n            result (and \\n                     par-command \\n                     (do-command? editor par-command)\\n                     (paredit par-command (.getParsed editor) par-text))]\\n        (when (and result (not\= \:ko (-> result \:parser-state)))\\n          (if-let [modif (-?> result \:modifs first)]\\n            (do\\n              (set\! (.offset command) (-> result \:modifs first \:offset))\\n              (set\! (.length command) (-> result \:modifs first \:length))\\n              (set\! (.text command) (-> result \:modifs first \:text))\\n              (doseq [{\:keys [offset length text]} (rest (-> result \:modifs))]\\n                (.addCommand command offset length text nil)))\\n            (do\\n              (set\! (.offset command) (\:offset result))\\n              (set\! (.length command) 0)\\n              (set\! (.text command) \\"\\")\\n              (set\! (.doit command) false)))\\n          (set\! (.shiftsCaret command) false)\\n          (set\! (.caretOffset command) (\:offset result))\\n          (when-not (zero? (\:length result)) \\n            ;(println (str \\"result\:\\" result))\\n          (.selectAndReveal editor (\:offset result) (\:length result))))\\n        \#_(.setStructuralEditingPossible editor (true? (and result (not\= \:ko (-> result \:parser-state)))))))))" "(require 'paredit.parser)" "(in-ns 'paredit.parser)" "(sexp  \\"too\\")" "(sexp \\"(ns ^\:foo ^\:bar baz)\\")" "(require 'clojure.contrib.pprint)" "(use 'clojure.contrib.pprint)" "(pprint (sexp \\"(ns ^\:foo ^\:bar baz)\\"))" "(doc join)" "(require 'clojure.string)" "(doc clojure.string/join)" "(source clojure.string/join)" "(clojure.string/join \\",\\" [])" "(clojure.string/join \\",\\" [1])" "(clojure.string/join \\",\\" [1 2 3 4])" "(clojure.string/join \\", \\" [1 2 3 4])" "(use 'paredit.parser)" " (sexp \\"(ns foo)\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n;             \:odd-map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             ;\:unexpected-close\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                ;(unspaced \\\\\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])*+\\" eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:map [\\"{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n;    \:map [\\"{\\" [\:expr \:expr]\:* \\"}\\"]\\n ;   \:odd-map [\\"{\\" [\:expr \:expr]\:* \:expr \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#\\"(?\:\\\\.|\\\\/|\\\\&|(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*)(?\:\\\\/(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*))?)\\"\\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n              ; other characters will be allowed eventually, but not all macro characters have been determined\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n              ; \\".\\" \: multiple successive points is allowed by the reader (but will break at evaluation)\\n              ; \\"\#\\" \: normally \# is allowed only in syntax quote forms, in last position\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n        ;\:symbol- \#\\"[\:]?([\\\\D&&[^/]].*/)?([\\\\D&&[^/]][^/]*)\\"  \\n    ; from old definition of symbol \:symbol- \#\\"[\\\\%|\\\\&||\\\\.|\\\\/|.*\\"\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\" ; (?\![_|\\\\(])\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\#\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_][a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_|\\\\\#]*\\"\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_].*\\"\\n    ;;;; CAS DU +toto+ -toto-\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ;\:unexpected-close \#{\#\\"}\\" \#\\"\\\\)\\" \#\\"]\\"}\\n    ))" "(def gspaces \#{\:whitespace \:comment \:discard})" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n;             \:odd-map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             ;\:unexpected-close\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                ;(unspaced \\\\\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])*+\\" eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:map [\\"{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n;    \:map [\\"{\\" [\:expr \:expr]\:* \\"}\\"]\\n ;   \:odd-map [\\"{\\" [\:expr \:expr]\:* \:expr \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#\\"(?\:\\\\.|\\\\/|\\\\&|(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*)(?\:\\\\/(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*))?)\\"\\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n              ; other characters will be allowed eventually, but not all macro characters have been determined\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n              ; \\".\\" \: multiple successive points is allowed by the reader (but will break at evaluation)\\n              ; \\"\#\\" \: normally \# is allowed only in syntax quote forms, in last position\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n        ;\:symbol- \#\\"[\:]?([\\\\D&&[^/]].*/)?([\\\\D&&[^/]][^/]*)\\"  \\n    ; from old definition of symbol \:symbol- \#\\"[\\\\%|\\\\&||\\\\.|\\\\/|.*\\"\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\" ; (?\![_|\\\\(])\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\#\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_][a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_|\\\\\#]*\\"\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_].*\\"\\n    ;;;; CAS DU +toto+ -toto-\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ;\:unexpected-close \#{\#\\"}\\" \#\\"\\\\)\\" \#\\"]\\"}\\n    ))" ";; Switching to paredit.parser namespace" "(clojure.core/in-ns 'paredit.parser)" "(def gspaces \#{\:whitespace \:comment \:discard})" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n;             \:odd-map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             ;\:unexpected-close\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                ;(unspaced \\\\\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])*+\\" eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:map [\\"{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n;    \:map [\\"{\\" [\:expr \:expr]\:* \\"}\\"]\\n ;   \:odd-map [\\"{\\" [\:expr \:expr]\:* \:expr \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#\\"(?\:\\\\.|\\\\/|\\\\&|(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*)(?\:\\\\/(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*))?)\\"\\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n              ; other characters will be allowed eventually, but not all macro characters have been determined\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n              ; \\".\\" \: multiple successive points is allowed by the reader (but will break at evaluation)\\n              ; \\"\#\\" \: normally \# is allowed only in syntax quote forms, in last position\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n        ;\:symbol- \#\\"[\:]?([\\\\D&&[^/]].*/)?([\\\\D&&[^/]][^/]*)\\"  \\n    ; from old definition of symbol \:symbol- \#\\"[\\\\%|\\\\&||\\\\.|\\\\/|.*\\"\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\" ; (?\![_|\\\\(])\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\#\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_][a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_|\\\\\#]*\\"\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_].*\\"\\n    ;;;; CAS DU +toto+ -toto-\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ;\:unexpected-close \#{\#\\"}\\" \#\\"\\\\)\\" \#\\"]\\"}\\n    ))" "(sexp \\"(ns name)\\")" " (def n (sexp \\"(ns name)\\"))" "n" "(->> n \:content (remove \#(gspaces (\:tag %))))" "(->> n \:content \\n  (remove \#(gspaces (\:tag %))))" "(doc get)" "(->> n \:content \#(get % 0) (remove \#(gspaces (\:tag %))))" " (remove \#(gspaces (\:tag %)) (get-in n [\:content 0 \:content]))" "n" "(def m (sexp \\"( ns ^\:s ^\:t bar baz)\\"))" "m" "(get-in m [\:content 0])" "(pprint (get-in m [\:content 0]))" "(require 'paredit.parser)" "(in-ns 'paredit.parser)" "(require net.cgrand.enlive.html \:as html)" "(require net.cgrand.enlive-html \:as html)" "(require 'net.cgrand.enlive-html \:as 'html)" "(require 'net.cgrand.xml \:as 'exml)" "(require ['net.cgrand.xml \:as 'cxml])" "(require '[net.cgrand.enlive-html \:as html])" "(require '[net.cgrand.enlive-html \:as html] \:reload)" "(html/html-resource \\"http\://www.google.com\\")" "(html/but \:space)" "(def n (sexp \\"( ns name)\\"))" "(html/select n [\:content])" "n" "(html/select n [\:list])" "(html/select n [\:list (html/but \:whitespace)])" "(html/select n [\:list (html/but \:whitespace) \:symbol])" "(html/select n [\:list [(html/but \:whitespace) \:symbol]])" " (def n (sexp \\"( ns ^{foo bar} ^baz name)\\"))" "(html/select n [\:list [(html/but \:whitespace) \:symbol]])" "(html/select n [\:list [(html/but \:whitespace) (html/nth-last-of-type \:symbol)]])" "(html/select n [\:list (html/nth-last-of-type \:symbol)])" "(html/select n [\:list (html/nth-last-of-type 0 \:symbol)])" "(html/select n [\:list (html/nth-last-of-type \\n                        \:symbol 0)])" "(html/select n [\:list (html/nth-last-of-type \:symbol 0)])" "(html/select n [(html/nth-last-of-type \:symbol)])" "n" "(html/select n [(html/nth-last-child)])" "(html/select n [(html/nth-last-child 0)])" "(html/select n [\:list (html/nth-last-child 1)])" "(html/select n [\:list (html/nth-last-of-type 1) \:symbol])" "(html/select n [\:list (html/nth-last-of-type 0) \:symbol])" "(html/select n [                      (html/union [\:meta \:> \:symbol] [\:list \:> \:symbol])]" "(html/select n [                      (html/union [\:meta \:> \:symbol] [\:list \:> \:symbol])])" "(doc html/union)" "(html/select n [                      (html/union [[\:meta \:> \:symbol] [\:list \:> \:symbol]])])" "(html/select n [ [[\:meta \:> \:symbol] [\:list \:> \:symbol]] ])" "(html/select n [ [[\:meta \:> \:symbol]] ])" "(html/select n [ \:list [\:meta \:> \:symbol] ])" "n" "(pprint n)" "(html/select n [ \:list [\:meta  \:symbol] ])" "(html/select n [ \:list \:meta \:> \:symbol ])" "m" "(def m (sexp \\"( ns foo)\\"))" "(html/select n [ \:list \:meta \:> \:symbol ])" "(html/select m [ \:list \:meta \:> \:symbol ])" "(html/select m [ \:root \:list \:meta \:> \:symbol ])" "(html/select n [ \:list \:meta \:> \:symbol ])" "(html/select n [ \:root \:list \:meta \:> \:symbol ])" "(html/select n [ \:root \:list (html/union [\:meta \:> \:symbol]) ])" "(binding [clojure.test/*test-out* (System/out)] (paredit.tests/pts))" "(html/select n [ \:root \:list (html/union [[\:meta \:> \:symbol]]) ])" "(html/select n [ \:root \:list \:meta \:> \:symbol ])" "(require 'paredit.parser)" "(in-ns 'paredit.parser)" " (require '[net.cgrand.enlive-html \:as e])" " (def n (sexp \\"(ns ^a ^b to\\"))" "(e/select n [\:root \:list])" " (def ns-call (x/pred (fn [e] (and (\#{\:list} (\:tag e)) (\#{\\"ns\\"} (get-in e [\:content 1]))))))" " (def ns-call (e/pred (fn [e] (and (\#{\:list} (\:tag e)) (\#{\\"ns\\"} (get-in e [\:content 1]))))))" "(e/select n [\:root ns-call])" "(e/select n [\:root])" "(e/select n [])" "n" "(sexp \\"(ns foo)\\")" "(def n (sexp \\"(ns ^bar ^bar foo)\\"))" "n" "(e/select n [\:root])" "(e/select n [ns-call])" " (def ns-call (e/pred (fn [e] true)))" "(e/select n [ns-call])" " (def ns-call (e/pred (fn [e] (println e) (and (\#{\:list} (\:tag e)) (\#{\\"ns\\"} (get-in e [\:content 1]))))))" "(e/select n [ns-call])" " (def ns-call (e/pred (fn [e] (println e) (and (\#{\:list} (\:tag e)) (\#{\\"ns\\"} (get-in e [\:content 1]))))))" "n" "(def s [s-name] (pred \#(and (\#{\:symbol} (\:tag %)) (\#{s-name} (get-in % [\:content 0])))))" "(defn s [s-name] (pred \#(and (\#{\:symbol} (\:tag %)) (\#{s-name} (get-in % [\:content 0])))))" "(defn s [s-name] (e/pred \#(and (\#{\:symbol} (\:tag %)) (\#{s-name} (get-in % [\:content 0])))))" "(e/select n [(s \\"ns\\")])" " (defn call (e/pred \#({\:list} (\:tag %))))" " (def call (e/pred \#({\:list} (\:tag %))))" " (def call (e/pred \#(\#{\:list} (\:tag %))))" "(defn match-sym [s-name] (e/pred \#(and (\#{\:symbol} (\:tag %)) (\#{s-name} (get-in % [\:content 0])))))" "(def match-call\\n  [called] (e/pred \#(and (\#{\:list} (\:tag %)) ((match-sym called) (get-in % [\:content 1])))))" "(defn match-call\\n  [called] (e/pred \#(and (\#{\:list} (\:tag %)) ((match-sym called) (get-in % [\:content 1])))))" "n" "(e/select n [(match-call \\"ns\\")])" "(e/select n [\:root])" "(e/select n [\:root (match-sym \\"ns\\")])" "(e/select n [\:root (match-call \\"ns\\")])" "(get-in {} [\:content 0])" "(binding [*out* *err*] (if-not *e (println \\"No prior exception bound to *e.\\") (clojure.tools.nrepl/*print-error-detail* *e)))" "n" "(match-call)" "(match-call \\"foo\\")" "((match-call \\"foo\\") {\:tag \:list \:content [\\"coucou\\" \\"kiki\\"]})" "(match-call \\"foo\\")" "(\:tag {\:tag \:list \:content [\\"coucou\\" \\"kiki\\"]})" "(match-sym \\"foo\\")" "(get-in {\:tag \:list \:content [\\"coucou\\" \\"kiki\\"]} [\:content 1])" "(match-sym \\"kiki\\")" "((match-sym \\"kiki\\") {\:tag list \:content [\\"coucou\\" \\"kiki\\"]})" "(defn match-call\\n  [called] (e/pred (fn [e] (println e) (and (\#{\:list} (\:tag e)) ((match-sym called) (get-in e [\:content 1]))))))" "y" "(defn match-call\\n  [called] (e/pred (fn [e] (println e) (and (\#{\:list} (\:tag e)) ((match-sym called) (get-in e [\:content 1]))))))" "((match-sym \\"kiki\\") {\:tag list \:content [\\"coucou\\" \\"kiki\\"]})" "((match-call \\"kiki\\") {\:tag list \:content [\\"coucou\\" \\"kiki\\"]})" "(defn match-call\\n  [called] (e/pred (fn [e] (println e) (and (\#{\:list} (\:tag e)) ((match-sym called) (get-in e [\:content 1]))))))" "(defn match-sym [s-name] (e/pred \#(and (\#{\:symbol} (\:tag %)) (\#{s-name} (get-in % [\:content 0])))))" "(defn match-call\\n  [called] (e/pred (fn [e] (println e) (and (\#{\:list} (\:tag e)) ((match-sym called) (get-in e [\:content 1]))))))" "((match-call \\"kiki\\") {\:tag list \:content [\\"coucou\\" \\"kiki\\"]})" "(match-call \\"kiki\\"" "(match-call \\"kiki\\")" "((match-call \\"kiki\\") \\"kiki\\")" "((match-call \\"kiki\\") n)" "(e/select n [(match-call \\"ns\\")])" "(e/select n [\:root (match-call \\"ns\\")])" "(doc e/selec)" "(doc e/select)" "(first (e/select n [\:root (match-call \\"ns\\")]))" "(first (e/select n [\:root ]))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:map\\n;             \:odd-map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             ;\:unexpected-close\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                ;(unspaced \\\\\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])*+\\" eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:map [\\"{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n;    \:map [\\"{\\" [\:expr \:expr]\:* \\"}\\"]\\n ;   \:odd-map [\\"{\\" [\:expr \:expr]\:* \:expr \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"] ;\#{\\")\\" \\"]\\" \\"}\\" eof}]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#\\"(?\:\\\\.|\\\\/|\\\\&|(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*)(?\:\\\\/(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))*(?\:\\\\\:(?\:(?\:(?\:[a-z|A-Z|\\\\*|\\\\\!|\\\\-(?\![0-9])|\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))|[0-9]|\\\\.|\\\\\#(?\!\\\\()))+)*))?)\\"\\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n              ; other characters will be allowed eventually, but not all macro characters have been determined\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n              ; \\".\\" \: multiple successive points is allowed by the reader (but will break at evaluation)\\n              ; \\"\#\\" \: normally \# is allowed only in syntax quote forms, in last position\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n        ;\:symbol- \#\\"[\:]?([\\\\D&&[^/]].*/)?([\\\\D&&[^/]][^/]*)\\"  \\n    ; from old definition of symbol \:symbol- \#\\"[\\\\%|\\\\&||\\\\.|\\\\/|.*\\"\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\" ; (?\![_|\\\\(])\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\#\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_][a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_|\\\\\#]*\\"\\n            ;\:atom \#\\"[a-z|A-Z|0-9|\\\\\!|\\\\$|\\\\%|\\\\&|\\\\*|\\\\+|\\\\-|\\\\.|\\\\/|\\\\\:|\\\\<|\\\\\=|\\\\>|\\\\?|\\\\_].*\\"\\n    ;;;; CAS DU +toto+ -toto-\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ;\:unexpected-close \#{\#\\"}\\" \#\\"\\\\)\\" \#\\"]\\"}\\n    ))" "(def only-code (partial remove gspaces))" "(only-code [{\:tag \:whitespace} {\:tag \:symbol}])" "(get-in \\"coucou\\" [\:content 1])" "(get-in nil [\:content 1])" "(\#{\:list} (\:tag \\"coucou\\"))" "(\#{\:foo} (get-in \\"coucou\\" [\:content 0]))" "(\#{\\"toto\\n\\"} (get-in \\"coucou\\" [\:content 0]))" "(match-sym \\"foo\\")" "(nil nil)" "(def only-code (partial remove gspaces))" "(only-code  [{\:tag \:whitespace} \\"foo\\" {\:tag \:list}])" "(def only-code (partial remove (comp gspaces \:tag)))" "(only-code  [{\:tag \:whitespace} \\"foo\\" {\:tag \:list}])" "n" "(only-code n)" "(only-code (\:content n))" "(\:content n)" "(pprint (\:content n))" "(pprint (get-in n [\:content 0]))" "(pprint (get-in n [\:content 0 \:content]))" "(pprint (only-code (get-in n [\:content 0 \:content])))" "(def only-code (partial remove (comp gspaces \:tag)))" "(defn sym? [e s] (and (\#{\:symbol} (\:tag e)) (\#{s} (apply str (\:content e)))))" "(sym? {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]} \\"lesym\\")" "(apply str (\:content e))" "(defn sym [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))" "(sym {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]} \\"lesym\\")" "(sym {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]} )" "(sym \\"goto\\" )" "(defn call-of? [e c] (and (\#{\:list} (\:tag e)) (\#{c} (sym (get-in e [\:content 1])))))" "(call-of? {\:tag list \:content [\\"(\\" {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]}]} \\"lesym\\")" "(defn call-of? [e c] (and (\#{\\"(\\"} (get-in e [\:content 0])) (\#{c} (sym (get-in e [\:content 1])))))" "(defn sym [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))" "(defn call-of? [e c] (and (\#{\\"(\\"} (get-in e [\:content 0])) (\#{c} (sym (get-in e [\:content 1])))))" "(call-of? {\:tag list \:content [\\"(\\" {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]}]} \\"lesym\\")" "(call-of? {\:tag list \:content [\\"(\\" {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]}]} \\"lesymf\\")" "(call-of? {\:tag list \:content [\\"(\\" {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]}]} \\"lesym\\")" "(call-of? {\:tag list \:content [\\"\#{\\" {\:tag \:symbol \:content [\\"le\\" \\"sym\\"]}]} \\"lesym\\")" "(some \#(call-of? % \\"ns\\") n)" "n" "(some \#(call-of? % \\"ns\\") (-> n \:content))" "(defn call-of? [e c] (and (\#{\\"(\\"} (get-in e [\:content 0])) (\#{c} (sym-name (get-in e [\:content 1])) e)))" "(defn sym-name\\n  \\"returns the symbol name\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))" "(defn call-of? [e c] (and (\#{\\"(\\"} (get-in e [\:content 0])) (\#{c} (sym-name (get-in e [\:content 1])) e)))" "(some \#(call-of? % \\"ns\\") (-> n \:content))" "(defn call-of? [e c] (and (\#{\\"(\\"} (get-in e [\:content 0])) (\#{c} (sym-name (get-in e [\:content 1]))) e))" "(some \#(call-of? % \\"ns\\") (-> n \:content))" "(def call-args [e] (-> e (get-in [\:content]) rest but-last only-code))" "(defn call-args [e] (-> e (get-in [\:content]) rest but-last only-code))" "(defn call-args [e] (-> e (get-in [\:content]) rest butlast only-code))" "(call-args (some \#(call-of? % \\"ns\\") (-> n \:content)))" "(defn call-args [e] (-> e (get-in [\:content]) only-code nnext butlast ))" "(call-args (some \#(call-of? % \\"ns\\") (-> n \:content)))" "(first (call-args (some \#(call-of? % \\"ns\\") (-> n \:content))))" "(doc nth)" "(nth (list 0 2 3) 1)" "(defn form \\n  \\"removes the meta(s) to get to the form\\" \\n  [e]\\n  (if-not (\#{\:meta} (\:tag e))\\n    e\\n    (nth (only-code (\:content e)) 2)))" "(first (call-args (some \#(call-of? % \\"ns\\") (-> n \:content))))" "(form (first (call-args (some \#(call-of? % \\"ns\\") (-> n \:content)))))" "(defn form \\n  \\"removes the meta(s) to get to the form\\" \\n  [e]\\n  (if-not (\#{\:meta} (\:tag e))\\n    e\\n    (recur (nth (only-code (\:content e)) 2))))" "(form (first (call-args (some \#(call-of? % \\"ns\\") (-> n \:content)))))" "(sym-name (form (first (call-args (some \#(call-of? % \\"ns\\") (-> n \:content))))))" "(defn find-namespace \\n  [tree] (sym-name (form (first (call-args (some \#(call-of? % \\"ns\\") (-> tree \:content)))))))" "(def n (sexp \\";hello\\\\n;hella\\\\n   (;foo\\\\nns ^{\:a \:b \:c 'd} ^Integer baz (\:require bas))\\"))" "(find-namespace n)" "(def n (sexp \\"(ns ^{\:a \:b \:c 'd} ^Integer baz (\:require bas))\\"))" "(find-namespace n)" "(defn form \\n  \\"removes the meta(s) to get to the form\\" \\n  [e]\\n  (if-not (\#{\:meta} (\:tag e))\\n    e\\n    (recur (nth (only-code (\:content e)) 2))))" "(find-namespace n)" "n" "(text n)" "(find-namespace n)" "(defn find-namespace \\n  [tree] (first (call-args (some \#(call-of? % \\"ns\\") (-> tree \:content)))))" "(find-namespace n)" "(defn find-namespace \\n  [tree] (form (first (call-args (some \#(call-of? % \\"ns\\") (-> tree \:content))))))" "(find-namespace n)" "(pprint n)" "(def n (sexp \\";hello\\\\n;hella\\\\n   (;foo\\\\nns ^{\:a \:b \:c 'd} ^Integer baz (\:require bas))\\"))" "(find-namespace n)" "(def n (sexp \\"(ns ^{\:a \:b \:c 'd} ^Integer baz (\:require bas))\\"))" "(find-namespace n)" "(defn find-namespace \\n  [tree] (sym-name (form (first (call-args (some \#(call-of? % \\"ns\\") (-> tree \:content)))))))" "(find-namespace n)" "(def n (sexp \\"()(ns ^{\:a \:b \:c 'd} ^Integer baz (\:require bas))\\"))" "(find-namespace n)" "(def n (sexp \\";toto\\\\n()(ns ^{\:a \:b \:c 'd} ^Integer baz (\:require bas))\\"))" "(find-namespace n)" "(def n (sexp \\";toto\\\\n()(ns ^{\:a \:b \:c 'd} ^Integer ;fuzz\\\\nbaz (\:require bas))\\"))" "(find-namespace n)" "(def n (sexp \\";toto\\\\n()  ( ns ^{\:a \:b \:c 'd} ^Integer ;fuzz\\\\nbaz (\:require bas))\\"))" "(find-namespace n)" "(defn call-of [e c] (and (\#{\\"(\\"} (-> e (get-in [\:content]) only-code (get 0))) (\#{c} (sym-name (get-in e [\:content 1]))) e))" "(find-namespace n)" "(defn call-args [e] (-> e (get-in [\:content]) only-code nnext butlast))" "(defn form \\n  \\"removes the meta(s) to get to the form\\" \\n  [e]\\n  (if-not (\#{\:meta} (\:tag e))\\n    e\\n    (recur (nth (only-code (\:content e)) 2))))" "(defn find-namespace \\n  [tree] (sym-name (form (first (call-args (some \#(call-of? % \\"ns\\") (-> tree \:content)))))))" "(find-namespace n)" "(defn code-children [e] (-> e (get-in [\:content]) only-code))" "(def only-code (partial remove (comp gspaces \:tag)))" "(defn code-children [e] (only-code (\:content e)))" "(defn sym-name\\n  \\"returns the symbol name\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))" "(defn call-of [e c] (and (\#{\\"(\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))" "(defn call-args [e] (-> (code-children e) nnext butlast))" "(defn form \\n  \\"removes the meta(s) to get to the form\\" \\n  [e]\\n  (if-not (\#{\:meta} (\:tag e))\\n    e\\n    (recur (nth (code-children e) 2))))" "(defn find-namespace \\n  [tree] (sym-name (form (first (call-args (some \#(call-of? % \\"ns\\") (-> tree \:content)))))))" "(defn find-namespace \\n  [tree] (sym-name (form (first (call-args (some \#(call-of? % \\"ns\\") (code-children tree)))))))" "(find-namespace children)" "(find-namespace n)" "n" "(defn n (sexp \\"(ns foo)\\"))" "(def n (sexp \\"(ns foo)\\"))" "(find-namespace n)" "(def n (sexp \\"(ns ^\:true ^\:false foo)\\"))" "(find-namespace n)" "(def n (sexp \\"(ns ^\:true ^\:false foo bar)\\"))" "(find-namespace n)" "(def n (sexp \\";toto \\\\n (ns ^\:true ^\:false foo \#_(baz) bar)\\"))" "(find-namespace n)" "(def n (sexp \\";toto \\\\n (ns ^\:true ^\:false \#_(baz)foo  bar)\\"))" "(find-namespace n)" "(def n (sexp \\";toto \\\\n (ns \#_(baz) ^\:true \#_(baz) ^\:false \#_(baz) foo  bar)\\"))" "(find-namespace n)" "(def n (sexp \\";toto \\\\n ( ns \#_(baz) ^\:true \#_(baz) ^\:false \#_(baz) foo  bar)\\"))" "(find-namespace n)" "(defn find-namespace \\n  [tree] (sym-name (form (first (call-args (some \#(call-of % \\"ns\\") (code-children tree)))))))" "(find-namespace n)" "(time (dotimes [_ 1000] (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)))" "(doc dotimes)" "(dotimes [_ 1] 1)" "(time (dotimes [_ 1000] (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)))" "(-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)" "(time (dotimes [_ 1000] (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)))" "(time (dotimes [_ 10000] (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)))" "(def n (sexp \\"(ns foo)\\"))" "(find-namespace n)" "(time dotimes [_ 10000] (find-namespace n))" "(time (dotimes [_ 10000] (find-namespace n)))" "(time (dotimes [_ 1000] (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)))" "(time (dotimes [_ 100000] (find-namespace n)))" "(time (dotimes [_ 100000] (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\") .find)))" "(time (dotimes [_ 100000] (let [matcher (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\"))] (when (.find matcher) (.group matcher 1)))))" "(time (dotimes [_ 1000000] (let [matcher (-> \#\\"\\\\(\\\\s*(?\:in-)?ns\\\\s+([^\\\\s\\\\)\#\\\\[\\\\'\\\\{]+)\\" (.matcher \\"(ns foo)\\"))] (when (.find matcher) (.group matcher 1)))))" "(time (dotimes [_ 1000000] (find-namespace n)))" "(find-namespace n)" "(find-namespace (sexp \\"(ns foo\\"))" "(sexp \\"(ns foo\\")" "(sexp \\" (ns foo\\")" "(find-namespace (sexp \\" (ns foo\\"))" "(sexp \\"(ns foo\\")" "(sexp \\"(ns foo) (\\")" "(binding [clojure.test/*test-out* *out*] (pst))" "(binding [clojure.test/*test-out* *out*] (pts))" "(in-ns 'tests.clj\\n  )" "(binding [clojure.test/*test-out* *out*] (pts))" "(in-ns 'paredit.tests\\n  )" "(binding [clojure.test/*test-out* *out*] (pts))" "(in-ns 'paredit.tests)" "(pts)" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core_commands.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.core-commands\\\\n  (\:use clojure.contrib.def))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; -*- Mode\: Emacs-Lisp; outline-regexp\: \\\\\\"\\\\\\\\n;;;;+\\\\\\" -*-\\\\n\\\\n;;;;;; Paredit\: Parenthesis-Editing Minor Mode\\\\n;;;;;; Version 21\\\\n\\\\n;;; Copyright (c) 2008, Taylor R. Campbell\\\\n;;;\\\\n;;; Redistribution and use in source and binary forms, with or without\\\\n;;; modification, are permitted provided that the following conditions\\\\n;;; are met\:\\\\n;;;\\\\n;;; * Redistributions of source code must retain the above copyright\\\\n;;;   notice, this list of conditions and the following disclaimer.\\\\n;;;\\\\n;;; * Redistributions in binary form must reproduce the above copyright\\\\n;;;   notice, this list of conditions and the following disclaimer in\\\\n;;;   the documentation and/or other materials provided with the\\\\n;;;   distribution.\\\\n;;;\\\\n;;; * Neither the names of the authors nor the names of contributors\\\\n;;;   may be used to endorse or promote products derived from this\\\\n;;;   software without specific prior written permission.\\\\n;;;\\\\n;;; THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\\\\n;;; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\\\n;;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\\\\n;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\\\\n;;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\\\n;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\\\\n;;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\\\\n;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\\\\n;;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\\\\n;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\\\\n;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\\\n\\\\n;;; This file is permanently stored at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit-21.el>.\\\\n;;;\\\\n;;; The currently released version of paredit is available at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit.el>.\\\\n;;;\\\\n;;; The latest beta version of paredit is available at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit-beta.el>.\\\\n;;;\\\\n;;; Release notes are available at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit.release>.\\\\n\\\\n;;; Install paredit by placing `paredit.el' in `/path/to/elisp', a\\\\n;;; directory of your choice, and adding to your .emacs file\:\\\\n;;;\\\\n;;;   (add-to-list 'load-path \\\\\\"/path/to/elisp\\\\\\")\\\\n;;;   (autoload 'paredit-mode \\\\\\"paredit\\\\\\"\\\\n;;;     \\\\\\"Minor mode for pseudo-structurally editing Lisp code.\\\\\\"\\\\n;;;     t)\\\\n;;;\\\\n;;; Toggle Paredit Mode with `M-x paredit-mode RET', or enable it\\\\n;;; always in a major mode `M' (e.g., `lisp' or `scheme') with\:\\\\n;;;\\\\n;;;   (add-hook M-mode-hook (lambda () (paredit-mode +1)))\\\\n;;;\\\\n;;; Customize paredit using `eval-after-load'\:\\\\n;;;\\\\n;;;   (eval-after-load 'paredit\\\\n;;;     '(progn ...redefine keys, &c....))\\\\n;;;\\\\n;;; Paredit should run in GNU Emacs 21 or later and XEmacs 21.5 or\\\\n;;; later.  Paredit is highly unlikely to work in earlier versions of\\\\n;;; GNU Emacs, and it may have obscure problems in earlier versions of\\\\n;;; XEmacs due to the way its syntax parser reports conditions, as a\\\\n;;; result of which the code that uses the syntax parser must mask all\\\\n;;; error conditions, not just those generated by the syntax parser.\\\\n;;;\\\\n;;; Questions, bug reports, comments, feature suggestions, &c., may be\\\\n;;; addressed via email to the author's surname at mumble.net or via\\\\n;;; IRC to the user named Riastradh on irc.freenode.net in the \#paredit\\\\n;;; channel.\\\\n;;;\\\\n;;; Please contact the author rather than forking your own versions, to\\\\n;;; prevent the dissemination of random variants floating about the\\\\n;;; internet unbeknownst to the author.  Laziness is not an excuse\:\\\\n;;; your laziness costs me confusion and time trying to support\\\\n;;; paredit, so if you fork paredit, you make the world a worse place.\\\\n;;;\\\\n;;; *** WARNING *** IMPORTANT *** DO NOT SUBMIT BUGS BEFORE READING ***\\\\n;;;\\\\n;;; If you plan to submit a bug report, where some sequence of keys in\\\\n;;; Paredit Mode, or some sequence of paredit commands, doesn't do what\\\\n;;; you wanted, then it is helpful to isolate an example in a very\\\\n;;; small buffer, and it is **ABSOLUTELY**ESSENTIAL** that you supply,\\\\n;;; along with the sequence of keys or commands,\\\\n;;;\\\\n;;;   (1) the version of Emacs,\\\\n;;;   (2) the version of paredit.el[*], and\\\\n;;;   (3) the **COMPLETE** state of the buffer used to reproduce the\\\\n;;;       problem, including major mode, minor modes, local key\\\\n;;;       bindings, entire contents of the buffer, leading line breaks\\\\n;;;       or spaces, &c.\\\\n;;;\\\\n;;; It is often extremely difficult to reproduce problems, especially\\\\n;;; with commands like `paredit-kill'.  If you do not supply **ALL** of\\\\n;;; this information, then it is highly probable that I cannot\\\\n;;; reproduce your problem no matter how hard I try, and the effect of\\\\n;;; submitting a bug without this information is only to waste your\\\\n;;; time and mine.  So, please, include all of the above information.\\\\n;;;\\\\n;;; [*] If you are using a beta version of paredit, be sure that you\\\\n;;;     are using the *latest* edition of the beta version, available\\\\n;;;     at <http\://mumble.net/~campbell/emacs/paredit-beta.el>.  If you\\\\n;;;     are not using a beta version, then upgrade either to that or to\\\\n;;;     the latest release version; I cannot support older versions,\\\\n;;;     and I can't fathom any reason why you might be using them.  So\\\\n;;;     the answer to item (2) should be either `release' or `beta'.\\\\n\\\\n;;; The paredit minor mode, Paredit Mode, binds a number of simple\\\\n;;; keys, notably `(', `)', `\\\\\\"', and `\\\\\\\\', to commands that more\\\\n;;; carefully insert S-expression structures in the buffer.  The\\\\n;;; parenthesis delimiter keys (round or square) are defined to insert\\\\n;;; parenthesis pairs and move past the closing delimiter,\\\\n;;; respectively; the double-quote key is multiplexed to do both, and\\\\n;;; also to insert an escape if within a string; and backslashes prompt\\\\n;;; the user for the next character to input, because a lone backslash\\\\n;;; can break structure inadvertently.  These all have their ordinary\\\\n;;; behaviour when inside comments, and, outside comments, if truly\\\\n;;; necessary, you can insert them literally with `C-q'.\\\\n;;;\\\\n;;; The key bindings are designed so that when typing new code in\\\\n;;; Paredit Mode, you can generally use exactly the same keystrokes as\\\\n;;; you would have used without Paredit Mode.  Earlier versions of\\\\n;;; paredit.el did not conform to this, because Paredit Mode bound `)'\\\\n;;; to a command that would insert a newline.  Now `)' is bound to a\\\\n;;; command that does not insert a newline, and `M-)' is bound to the\\\\n;;; command that inserts a newline.  To revert to the former behaviour,\\\\n;;; add the following forms to an `eval-after-load' form for paredit.el\\\\n;;; in your .emacs file\:\\\\n;;;\\\\n;;;   (define-key paredit-mode-map (kbd \\\\\\")\\\\\\")\\\\n;;;     'paredit-close-round-and-newline)\\\\n;;;   (define-key paredit-mode-map (kbd \\\\\\"M-)\\\\\\")\\\\n;;;     'paredit-close-round)\\\\n;;;\\\\n;;; Paredit Mode also binds the usual keys for deleting and killing, so\\\\n;;; that they will not destroy any S-expression structure by killing or\\\\n;;; deleting only one side of a parenthesis or quote pair.  If the\\\\n;;; point is on a closing delimiter, `DEL' will move left over it; if\\\\n;;; it is on an opening delimiter, `C-d' will move right over it.  Only\\\\n;;; if the point is between a pair of delimiters will `C-d' or `DEL'\\\\n;;; delete them, and in that case it will delete both simultaneously.\\\\n;;; `M-d' and `M-DEL' kill words, but skip over any S-expression\\\\n;;; structure.  `C-k' kills from the start of the line, either to the\\\\n;;; line's end, if it contains only balanced expressions; to the first\\\\n;;; closing delimiter, if the point is within a form that ends on the\\\\n;;; line; or up to the end of the last expression that starts on the\\\\n;;; line after the point.\\\\n;;;\\\\n;;; The behaviour of the commands for deleting and killing can be\\\\n;;; overridden by passing a `C-u' prefix argument\: `C-u DEL' will\\\\n;;; delete a character backward, `C-u C-d' will delete a character\\\\n;;; forward, and `C-u C-k' will kill text from the point to the end of\\\\n;;; the line, irrespective of the S-expression structure in the buffer.\\\\n;;; This can be used to fix mistakes in a buffer, but should generally\\\\n;;; be avoided.\\\\n;;;\\\\n;;; Paredit performs automatic reindentation as locally as possible, to\\\\n;;; avoid interfering with custom indentation used elsewhere in some\\\\n;;; S-expression.  Only the advanced S-expression manipulation commands\\\\n;;; automatically reindent, and only the forms that were immediately\\\\n;;; operated upon (and their subforms).\\\\n;;;\\\\n;;; This code is written for clarity, not efficiency.  It frequently\\\\n;;; walks over S-expressions redundantly.  If you have problems with\\\\n;;; the time it takes to execute some of the commands, let me know, but\\\\n;;; first be sure that what you're doing is reasonable\: it is\\\\n;;; preferable to avoid immense S-expressions in code anyway.\\\\n\\\\n;;; This assumes Unix-style LF line endings.\\\\n\\\\n(defmacro defconst [& body] `(clojure.contrib.def/defvar ~@body))\\\\n\\\\n(defconst paredit-version 21)\\\\n(defconst paredit-beta-p nil)\\\\n\\\\n(defvar  \\\\n  paredit-mode-map {} \\\\n  \\\\\\"Keymap for the paredit minor mode.\\\\\\")\\\\n\\\\n(defn check-parens \\\\\\"TODO LAP\: implement it \!\\\\\\" [text] true)\\\\n(defn can-enable-paredit? [text] (check-parens text))\\\\n\\\\n(def \\\\n  ^{ \:doc \\\\\\"\\\\n    The format for documenting the commands is simple, and a slight varation of\\\\n    the original paredit.el format \:\\\\n    paredit-commands \:\= [ group* ]\\\\n    group \:\= [ group-name-str command* ]\\\\n    command \:\= [ default-triggering-keys \\\\n                 command-name-keyword \\\\n                 { before-after-documentation-pair* } \\\\n                 { before-after-non-regression-pair* }* ]\\\\n    before-after-documentation-pair \:\= before-after-non-regression-pair\\\\n    before-after-non-regression-pair \:\= before-text-spec after-text-spec\\\\n    before-text-spec \:\= after-text-spec \:\= text-spec\\\\n    text-spec \:\= a string, with the caret position indicated by a pipe character |, \\\\n                 and if there is a selected portion of the text, the end of the text\\\\n                 selection is marked with another pipe character |\\\\\\"}\\\\n  *paredit-commands*\\\\n  [\\\\n    [\\\\\\"Basic Insertion Commands\\\\\\"\\\\n\\\\t    [\\\\\\"(\\\\\\"         \:paredit-open-round\\\\n\\\\t                {\\\\\\"(a b |c d)\\\\\\"\\\\n\\\\t                 \\\\\\"(a b (|) c d)\\\\\\"\\\\n\\\\t                 \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar (|baz\\\\\\\\\\\\\\" quux)\\\\\\"\\\\n                  }\\\\n\\\\t                {\\\\\\"(a b|c d)\\\\\\" \\\\\\"(a b (|) c d)\\\\\\"\\\\n\\\\t                 \\\\\\"(|)\\\\\\" \\\\\\"((|))\\\\\\"\\\\n\\\\t                 \\\\\\"|\\\\\\" \\\\\\"(|)\\\\\\"\\\\n\\\\t                 \\\\\\"a|\\\\\\" \\\\\\"a (|)\\\\\\"\\\\n\\\\t                 \\\\\\"(a |,b)\\\\\\" \\\\\\"(a (|),b)\\\\\\"\\\\n\\\\t                 \\\\\\"(a,| b)\\\\\\" \\\\\\"(a, (|) b)\\\\\\"\\\\n\\\\t                 \\\\\\"(a,|b)\\\\\\" \\\\\\"(a, (|) b)\\\\\\"\\\\n\\\\t                 \\\\\\"(a,|)\\\\\\" \\\\\\"(a, (|))\\\\\\"\\\\n                   \\\\\\"\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\(| \\\\\\" \\\\n\\\\t                 \\\\\\"~|\\\\\\" \\\\\\"~(|)\\\\\\"\\\\n\\\\t                 \\\\\\"~@|\\\\\\" \\\\\\"~@(|)\\\\\\"\\\\n\\\\t                 \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ (|) \\\\\\"\\\\n                  }]\\\\n\\\\t    [\\\\\\")\\\\\\"         \:paredit-close-round\\\\n\\\\t                {\\\\\\"(a |b)\\\\\\" \\\\\\"(a b)|\\\\\\"\\\\n\\\\t                 \\\\\\"(a |b) cd\\\\\\" \\\\\\"(a b)| cd\\\\\\"\\\\n\\\\t                 \\\\\\"(a |b ) cd\\\\\\" \\\\\\"(a b)| cd\\\\\\"\\\\n\\\\t                 \\\\\\"(a b |c [])\\\\\\" \\\\\\"(a b c [])|\\\\\\"\\\\n                   \\\\\\"(a b c [|] )\\\\\\" \\\\\\"(a b c [])|\\\\\\"\\\\n\\\\t                 \\\\\\"(a b |c   )\\\\\\" \\\\\\"(a b c)|\\\\\\"\\\\n                   \\\\\\"( a,  b |[a b ]   )\\\\\\" \\\\\\"( a,  b [a b ])|\\\\\\"\\\\n                   \\\\\\"( a,  b [|a b ]   )\\\\\\" \\\\\\"( a,  b [a b ])|\\\\\\"\\\\n                   \\\\\\"[ a,  b (|a b )   ]\\\\\\" \\\\\\"[ a,  b (a b)|   ]\\\\\\"\\\\n\\\\t                 \\\\\\"(a b |c ,  )\\\\\\" \\\\\\"(a b c)|\\\\\\"\\\\n\\\\t                 \\\\\\"(a b| [d e]\\\\\\" \\\\\\"(a b)| [d e]\\\\\\"\\\\n\\\\t                 \\\\\\"; Hello,| world\!\\\\\\"  \\\\\\"; Hello,)| world\!\\\\\\"\\\\n\\\\t                 \\\\\\"(  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\\\\\\\\\" foo )\\\\\\" \\\\\\"(  \\\\\\\\\\\\\\"Hello,)| world\!\\\\\\\\\\\\\\" foo )\\\\\\"\\\\n\\\\t                 \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,)| world\!\\\\\\"\\\\n\\\\t                 \\\\\\"foo \\\\\\\\\\\\\\\\|\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\\\)|\\\\\\"\\\\n                  ; tests with the new \:chimera\\\\n                   \\\\\\"({foo |bar])\\\\\\" \\\\\\"({foo bar])|\\\\\\"\\\\n                   \\\\\\"({[foo |bar)})\\\\\\" \\\\\\"({[foo bar)|})\\\\\\"\\\\n                  }]\\\\n\\\\t    \#_[\\\\\\"M-)\\\\\\"       \:paredit-close-round-and-newline\\\\n\\\\t                {\\\\\\"(defun f (x|  ))\\\\\\"\\\\n\\\\t                 \\\\\\"(defun f (x)\\\\\\\\n  |)\\\\\\"\\\\n\\\\t                 \\\\\\"; (Foo.|\\\\\\"\\\\n\\\\t                 \\\\\\"; (Foo.)|\\\\\\"}]\\\\n      [\\\\\\"[\\\\\\"         \:paredit-open-square\\\\n                 {\\\\\\"(a b |c d)\\\\\\"  \\\\\\"(a b [|] c d)\\\\\\"\\\\n                  \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar [|baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\n                  }\\\\n                  {\\\\\\"(a b|c d)\\\\\\" \\\\\\"(a b [|] c d)\\\\\\"\\\\n                   \\\\\\"(|)\\\\\\" \\\\\\"([|])\\\\\\"\\\\n                   \\\\\\"|\\\\\\" \\\\\\"[|]\\\\\\"\\\\n                   \\\\\\"a|\\\\\\" \\\\\\"a [|]\\\\\\"\\\\n                   \\\\\\"(a |,b)\\\\\\" \\\\\\"(a [|],b)\\\\\\"\\\\n                   \\\\\\"(a,| b)\\\\\\" \\\\\\"(a, [|] b)\\\\\\"\\\\n                   \\\\\\"(a,|b)\\\\\\" \\\\\\"(a, [|] b)\\\\\\"\\\\n                   \\\\\\"(a,|)\\\\\\" \\\\\\"(a, [|])\\\\\\"\\\\n                   \\\\\\"\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\[| \\\\\\" \\\\n                   \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ [|] \\\\\\"}]\\\\n      [\\\\\\"]\\\\\\"         \:paredit-close-square\\\\n                  {\\\\\\"(define-key keymap [frob|  ] 'frobnicate)\\\\\\"\\\\n                   \\\\\\"(define-key keymap [frob]| 'frobnicate)\\\\\\"\\\\n                   \\\\\\"; [Bar.|\\\\\\" \\\\\\"; [Bar.]|\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,]| world\!\\\\\\\\\\\\\\" foo\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,]| world\!\\\\\\"\\\\n                   \\\\\\"foo \\\\\\\\\\\\\\\\|\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\\\]|\\\\\\"\\\\n                   ; tests with the new \:chimera\\\\n                   \\\\\\"({foo |bar])\\\\\\" \\\\\\"({foo bar]|)\\\\\\"\\\\n                   \\\\\\"({(foo |bar]))\\\\\\" \\\\\\"({(foo bar]|))\\\\\\"\\\\n                   \\\\\\"({[foo |bar)})\\\\\\" \\\\\\"({[foo ]|bar)})\\\\\\"\\\\n                   \\\\\\"[foo (bar [baz {bleh |blah}))]\\\\\\" \\\\\\"[foo (bar [baz {bleh blah}))]|\\\\\\"\\\\n                   }]\\\\n      [\\\\\\"{\\\\\\"         \:paredit-open-curly\\\\n                 {\\\\\\"(a b |c d)\\\\\\"  \\\\\\"(a b {|} c d)\\\\\\"\\\\n                  \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar {|baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\n                  }\\\\n                  {\\\\\\"(a b|c d)\\\\\\" \\\\\\"(a b {|} c d)\\\\\\"\\\\n                   \\\\\\"(|)\\\\\\" \\\\\\"({|})\\\\\\"\\\\n                   \\\\\\"|\\\\\\" \\\\\\"{|}\\\\\\"\\\\n                   \\\\\\"a|\\\\\\" \\\\\\"a {|}\\\\\\"\\\\n                   \\\\\\"\#|\\\\\\" \\\\\\"\#{|}\\\\\\" ; specific to clojure sets\\\\n                   \\\\\\"(a |,b)\\\\\\" \\\\\\"(a {|},b)\\\\\\"\\\\n                   \\\\\\"(a,| b)\\\\\\" \\\\\\"(a, {|} b)\\\\\\"\\\\n                   \\\\\\"(a,|b)\\\\\\" \\\\\\"(a, {|} b)\\\\\\"\\\\n                   \\\\\\"(a,|)\\\\\\" \\\\\\"(a, {|})\\\\\\"\\\\n                   \\\\\\"\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\{| \\\\\\" \\\\n                   \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ {|} \\\\\\"\\\\n                   }]\\\\n      [\\\\\\"}\\\\\\"         \:paredit-close-curly\\\\n                  {\\\\\\"{a b |c   }\\\\\\" \\\\\\"{a b c}|\\\\\\"\\\\n                   \\\\\\"; Hello,| world\!\\\\\\"\\\\n                   \\\\\\"; Hello,}| world\!\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,}| world\!\\\\\\\\\\\\\\" foo\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,}| world\!\\\\\\"\\\\n                   \\\\\\"foo \\\\\\\\\\\\\\\\|\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\\\}|\\\\\\"\\\\n                   \\\\\\"({(foo |bar}))\\\\\\" \\\\\\"({(foo bar}|))\\\\\\"\\\\n                   }]\\\\n      [\\\\\\"\\\\\\\\\\\\\\"\\\\\\"        \:paredit-doublequote\\\\n                  { \\\\\\"(frob grovel |full lexical)\\\\\\" \\\\\\"(frob grovel \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" full lexical)\\\\\\",\\\\n                   \\\\\\"(frob grovel \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" full lexical)\\\\\\" \\\\\\"(frob grovel \\\\\\\\\\\\\\"\\\\\\\\\\\\\\"| full lexical)\\\\\\",\\\\n                   \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|baz\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                   \\\\\\";|ab\\\\\\" \\\\\\";\\\\\\\\\\\\\\"|ab\\\\\\", \\\\n                   \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\|bar\\\\\\\\\\\\\\" full lexical)\\\\\\"\\\\n                     \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\\\\\\\\\" full lexical)\\\\\\",\\\\n                   \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|bar\\\\\\\\\\\\\\" full lexical)\\\\\\"\\\\n                     \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\\\\\\\\\" full lexical)\\\\\\",\\\\n                   \\\\\\"\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b|ar\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|ar\\\\\\\\\\\\\\"\\\\\\",\\\\n                     \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b|ar\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|ar\\\\\\\\\\\\\\"\\\\\\",\\\\n                   \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\\\\\\\\\"\\\\\\",\\\\n                   \\\\\\"\\\\\\\\\\\\\\"fo|o\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|o\\\\\\\\\\\\\\"\\\\\\",\\\\n                   ;\\\\\\"\#\\\\\\\\\\\\\\"fo|o\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|o\\\\\\\\\\\\\\"\\\\\\",\\\\n                   ;;;\\\\\\"\#\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\"\\\\\\"\\\\n\\\\n                  ;; \\\\\\"\#|\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\" ; specific to clojure regexs\\\\n\\\\n                   }]\\\\n    ]\\\\n    [\\\\\\"Deleting & Killing\\\\\\"\\\\n      [\\\\\\"Del\\\\\\"     \:paredit-forward-delete\\\\n                {\\\\\\"(quu|x \\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(quu| \\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\")\\\\\\",\\\\n                 \\\\\\"(quux |\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(quux \\\\\\\\\\\\\\"|zot\\\\\\\\\\\\\\")\\\\\\",\\\\n                 \\\\\\"(quux \\\\\\\\\\\\\\"|zot\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(quux \\\\\\\\\\\\\\"|ot\\\\\\\\\\\\\\")\\\\\\",\\\\n                 \\\\\\"(foo |(a) bar)\\\\\\" \\\\\\"(foo (|a) bar)\\\\\\"\\\\n                 \\\\\\"(foo (|a) bar)\\\\\\" \\\\\\"(foo (|) bar)\\\\\\" \\\\n                 \\\\\\"(foo (|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo [|] bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo {|} bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo (a|) bar)\\\\\\" \\\\\\"(foo (a|) bar)\\\\\\"\\\\n                 \\\\\\"(foo [a|] bar)\\\\\\" \\\\\\"(foo [a|] bar)\\\\\\"\\\\n                 \\\\\\"(foo {a|} bar)\\\\\\" \\\\\\"(foo {a|} bar)\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \#{|} bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \#{a|} bar)\\\\\\" \\\\\\"(foo \#{a|} bar)\\\\\\"\\\\n                 \\\\\\"(foo \#{a |d} bar)\\\\\\" \\\\\\"(foo \#{a |} bar)\\\\\\"\\\\n                 \\\\\\"(|\#{foo bar})\\\\\\" \\\\\\"(\#{|foo bar})\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \#(|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \#(a|) bar)\\\\\\" \\\\\\"(foo \#(a|) bar)\\\\\\"\\\\n                 \\\\\\"(foo \#(a |d) bar)\\\\\\" \\\\\\"(foo \#(a |) bar)\\\\\\"\\\\n                 \\\\\\"(|\#(foo bar))\\\\\\" \\\\\\"(\#(|foo bar))\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \#\\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo \#\\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\"\\\\n                 \\\\\\"(foo \#\\\\\\\\\\\\\\"a |d\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo \#\\\\\\\\\\\\\\"a |\\\\\\\\\\\\\\" bar)\\\\\\"\\\\n                 \\\\\\"(|\#\\\\\\\\\\\\\\"foo bar\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(\#\\\\\\\\\\\\\\"|foo bar\\\\\\\\\\\\\\")\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\n                 \\\\\\"(|(foo bar))\\\\\\" \\\\\\"((|foo bar))\\\\\\"\\\\n                 \\\\\\"(|[foo bar])\\\\\\" \\\\\\"([|foo bar])\\\\\\"\\\\n                 \\\\\\"(|{foo bar})\\\\\\" \\\\\\"({|foo bar})\\\\\\"\\\\n                 \\\\n                 \\\\\\"|\\\\\\" \\\\\\"|\\\\\\"\\\\n                 }]\\\\n      [\\\\\\"BackDel\\\\\\" \:paredit-backward-delete\\\\n                {\\\\n                 \\\\\\"(\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\" q|uux)\\\\\\" \\\\\\"(\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\" |uux)\\\\\\",\\\\n                 \\\\\\"(\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\"| quux)\\\\\\" \\\\\\"(\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                 \\\\\\"(\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(\\\\\\\\\\\\\\"zo|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n\\\\n                 \\\\\\"(\#\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\"| quux)\\\\\\" \\\\\\"(\#\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                 \\\\\\"(\#\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(\#\\\\\\\\\\\\\\"zo|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                 \\\\n                 \\\\\\"(foo (|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\",\\\\n                 \\\\\\"(foo \#(|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\",\\\\n                 \\\\\\"(foo \#{|} bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\",\\\\n                 \\\\n                 \\\\\\"(foo bar)|\\\\\\" \\\\\\"(foo bar|)\\\\\\",\\\\n                 \\\\\\"(foo bar|)\\\\\\" \\\\\\"(foo ba|)\\\\\\",\\\\n                 \\\\n                 \\\\\\"|\\\\\\" \\\\\\"|\\\\\\"\\\\n                 \\\\n                 \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|\\\\\\" \\\\\\"\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\"\\\\n                 \\\\\\"\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\" \\\\\\"|\\\\\\"\\\\n                 \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\"\\\\n                 \\\\\\"\#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\" \\\\\\"|\\\\\\"\\\\n                 \\\\n                 \\\\\\"\#(foo bar)|\\\\\\" \\\\\\"\#(foo bar|)\\\\\\",\\\\n                 \\\\\\"\#(foo bar|)\\\\\\" \\\\\\"\#(foo ba|)\\\\\\",\\\\n                 \\\\\\"\#{foo bar}|\\\\\\" \\\\\\"\#{foo bar|}\\\\\\",\\\\n                 \\\\\\"\#{foo bar|}\\\\\\" \\\\\\"\#{foo ba|}\\\\\\",\\\\n                 \\\\\\"\#(|)\\\\\\" \\\\\\"|\\\\\\",\\\\n                 \\\\\\"\#{|}\\\\\\" \\\\\\"|\\\\\\"\\\\n                 }]\\\\n      ;\#_[\\\\\\"C-k\\\\\\"     \:paredit-kill\\\\n      ;          {\\\\\\"(foo bar)|     ; Useless comment\!\\\\\\"\\\\n      ;           \\\\\\"(foo bar)|\\\\\\",\\\\n      ;          \\\\\\"(|foo bar)     ; Useful comment\!\\\\\\"\\\\n      ;           \\\\\\"(|)     ; Useful comment\!\\\\\\",\\\\n      ;          \\\\\\"|(foo bar)     ; Useless line\!\\\\\\"\\\\n      ;           \\\\\\"|\\\\\\",\\\\n      ;          \\\\\\"(foo \\\\\\\\\\\\\\"|bar baz\\\\\\\\\\\\\\"\\\\\\\\n     quux)\\\\\\"\\\\n      ;           \\\\\\"(foo \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\\\n     quux)\\\\\\"}]\\\\n      ]\\\\n    \\\\n    [\\\\\\"Depth-Changing Commands\\\\\\"\\\\n     [\\\\\\"M-(\\\\\\"       \:paredit-wrap-round\\\\n      {\\\\\\"(foo |bar baz)\\\\\\" \\\\\\"(foo (|bar) baz)\\\\\\",\\\\n       \\\\\\";hel|lo\\\\\\" \\\\\\";hel(|lo\\\\\\",\\\\n       \\\\\\"a |\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\"\\\\\\" \\\\\\"a (|\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\")\\\\\\",\\\\n       \\\\\\"a |\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\"|\\\\\\" \\\\\\"a (|\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\"|)\\\\\\",\\\\n       \\\\\\"foo |bar| foo\\\\\\" \\\\\\"foo (|bar|) foo\\\\\\",\\\\n       \\\\\\"foo |bar baz| foo\\\\\\" \\\\\\"foo (|bar baz|) foo\\\\\\",\\\\n       \\\\\\"foo (|bar| baz) foo\\\\\\" \\\\\\"foo ((|bar|) baz) foo\\\\\\"\\\\n       \\\\\\"foo (|bar baz|) foo\\\\\\" \\\\\\"foo ((|bar baz|)) foo\\\\\\"\\\\n       ;; not-yet \\\\\\"foo |(bar| baz) foo\\\\\\" \\\\\\"foo |(bar| baz) foo\\\\\\"\\\\n       ;; not-yet \\\\\\"foo (bar| baz)| foo\\\\\\" \\\\\\"foo (bar| baz)| foo\\\\\\"\\\\n       \\\\\\"foo |(bar baz)| foo\\\\\\" \\\\\\"foo (|(bar baz)|) foo\\\\\\"\\\\n       \\\\\\"foo |(bar\\\\\\\\n;comment\\\\\\\\n baz)| foo\\\\\\" \\\\\\"foo (|(bar\\\\\\\\n;comment\\\\\\\\n baz)|) foo\\\\\\"\\\\n       ;; not-yet \\\\\\"foo |bar ba|z foo\\\\\\" \\\\\\"foo |bar ba|z foo\\\\\\",\\\\n       \\\\\\"foo \\\\\\\\\\\\\\"|bar ba|z\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\"(|z\\\\\\\\\\\\\\" foo\\\\\\",\\\\n       ;; not-yet \\\\\\"foo |\\\\\\\\\\\\\\"bar ba|z\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar ba|z\\\\\\\\\\\\\\" foo\\\\\\",\\\\n       \\\\\\"foo |bar|\\\\\\" \\\\\\"foo (|bar|)\\\\\\"\\\\n       \\\\\\"foo |(bar)|\\\\\\" \\\\\\"foo (|(bar)|)\\\\\\"\\\\n       \\\\\\"|`foo|\\\\\\" \\\\\\"(|`foo|)\\\\\\"\\\\n       }]\\\\n     ;[\\\\\\"M-s\\\\\\"       \:paredit-splice-sexp\\\\n     ;           {\\\\\\"(foo (bar| baz) quux)\\\\\\"\\\\n     ;            \\\\\\"(foo bar| baz quux)\\\\\\"}]\\\\n     ;[(\\\\\\"M-<up>\\\\\\" \\\\\\"ESC <up>\\\\\\")\\\\n     ;           paredit-splice-sexp-killing-backward\\\\n     ;           (\\\\\\"(foo (let ((x 5)) |(sqrt n)) bar)\\\\\\"\\\\n     ;            \\\\\\"(foo (sqrt n) bar)\\\\\\")]\\\\n     ;((\\\\\\"M-<down>\\\\\\" \\\\\\"ESC <down>\\\\\\")\\\\n     ;           paredit-splice-sexp-killing-forward\\\\n     ;           (\\\\\\"(a (b c| d e) f)\\\\\\"\\\\n     ;            \\\\\\"(a b c f)\\\\\\"))\\\\n     [\\\\\\"M-r\\\\\\"       \:paredit-raise-sexp\\\\n                {\\\\\\"(dynamic-wind in (lambda () |body|) out)\\\\\\" \\\\\\"(dynamic-wind in |body out)\\\\\\"\\\\n                 \\\\\\"(dynamic-wind in |body| out)\\\\\\" \\\\\\"|body\\\\\\" \\\\n                 \\\\\\"(foo bar|)\\\\\\" \\\\\\"(foo bar|)\\\\\\"\\\\n                 \\\\\\"(foo |bar)\\\\\\" \\\\\\"|bar\\\\\\"\\\\n                 \\\\\\"(foo |(bar))\\\\\\" \\\\\\"|(bar)\\\\\\"\\\\n                 \\\\\\"(foo |(bar]|)\\\\\\" \\\\\\"|(bar]\\\\\\"\\\\n                 }]\\\\n     ]\\\\n    \\\\n    [\\\\\\"Selection\\\\\\"\\\\n     [\\\\\\"Shift+Alt+Left\\\\\\" \:paredit-expand-left\\\\n                {\\\\n                 \\\\\\"foo bar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo bar |baz\\\\\\" \\\\\\"foo bar| |baz\\\\\\"\\\\n                 \\\\\\"foo ba|r baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo1 bar b|a|z\\\\\\" \\\\\\"foo1 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo2 bar ba|z|\\\\\\" \\\\\\"foo2 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo3 bar |baz|\\\\\\" \\\\\\"foo3 bar| baz|\\\\\\"\\\\n                 \\\\\\"foo bar| baz|\\\\\\" \\\\\\"foo |bar baz|\\\\\\"\\\\n                 \\\\\\"foo |bar baz|\\\\\\" \\\\\\"foo| bar baz|\\\\\\"\\\\n                 \\\\\\"|(foo bar baz)|\\\\\\" \\\\\\"|(foo bar baz)|\\\\\\"\\\\n                 ;;not-yet \\\\\\"|fo|o bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 ;;not-yet \\\\\\"|foo| bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 ;;not-yet \\\\\\"|foo |bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 ;;not-yet \\\\\\"|foo b|ar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 \\\\\\"foo (bar| baz)\\\\\\" \\\\\\"foo (|bar| baz)\\\\\\"\\\\n                 \\\\\\"foo b|ar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo1 (|bar| baz)\\\\\\" \\\\\\"foo1 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\"\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar baz\\\\\\\\\\\\\\"|\\\\\\"\\\\n                 \\\\\\"foo;ba|r\\\\\\\\nbaz\\\\\\" \\\\\\"foo|;bar|\\\\\\\\nbaz\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z] |foo)\\\\\\" \\\\\\"foo (bar |[baz] |foo)\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z]) (foo [bar (b|az)])\\\\\\" \\\\\\"foo |(bar [baz]) (foo [bar (baz)])|\\\\\\"\\\\n                 \\\\\\"foo |(bar [baz (b|am)])\\\\\\" \\\\\\"foo |(bar [baz (bam)])|\\\\\\"\\\\n                 \\\\\\"(foo bar|)\\\\\\" \\\\\\"(foo |bar|)\\\\\\"\\\\n                 \\\\\\"fooz foo |(bar)| baz\\\\\\" \\\\\\"fooz foo| (bar)| baz\\\\\\"\\\\n                 \\\\\\"fooz foo| (bar)| baz\\\\\\" \\\\\\"fooz |foo (bar)| baz\\\\\\"\\\\n                 ;with \:chimera\\\\n                 \\\\\\"(foo bar|]\\\\\\" \\\\\\"(foo |bar|]\\\\\\"\\\\n                 \\\\\\"(foo {bar)|]\\\\\\" \\\\\\"(foo |{bar)|]\\\\\\"\\\\n                 }]\\\\n     [\\\\\\"Shift+Alt+Right\\\\\\" \:paredit-expand-right\\\\n                {\\\\n                 \\\\\\"foo bar| baz\\\\\\" \\\\\\"foo bar| |baz\\\\\\"\\\\n                 \\\\\\"foo4 bar |baz\\\\\\" \\\\\\"foo4 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo ba|r baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo5 bar b|a|z\\\\\\" \\\\\\"foo5 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo6 bar ba|z|\\\\\\" \\\\\\"foo6 bar |baz|\\\\\\"\\\\n                 ;;not-yet \\\\\\"foo bar |baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 ;;not-yet \\\\\\"foo bar| baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 ;;not-yet \\\\\\"foo |bar baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|foo bar baz\\\\\\" \\\\\\"|foo| bar baz\\\\\\";;\\\\n                 \\\\\\"|f|oo bar baz\\\\\\" \\\\\\"|foo| bar baz\\\\\\"\\\\n                 \\\\\\"|foo| bar baz\\\\\\" \\\\\\"|foo |bar baz\\\\\\"\\\\n                 \\\\\\"|foo |bar baz\\\\\\" \\\\\\"|foo bar| baz\\\\\\"\\\\n                 \\\\\\"|foo b|ar baz\\\\\\" \\\\\\"|foo bar| baz\\\\\\"\\\\n                 \\\\\\"foo (bar| baz)\\\\\\" \\\\\\"foo (bar| |baz)\\\\\\"\\\\n                 \\\\\\"foo (bar |baz)\\\\\\" \\\\\\"foo (bar |baz|)\\\\\\"\\\\n                 \\\\\\"foo b|ar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo2 (bar baz|)\\\\\\" \\\\\\"foo2 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo3 (bar |baz|)\\\\\\" \\\\\\"foo3 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\"\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar baz\\\\\\\\\\\\\\"|\\\\\\"\\\\n                 \\\\\\"foo;ba|r\\\\\\\\nbaz\\\\\\" \\\\\\"foo|;bar|\\\\\\\\nbaz\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z] |foo)\\\\\\" \\\\\\"foo (bar |[baz] |foo)\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z]) (foo [bar (b|az)])\\\\\\" \\\\\\"foo |(bar [baz]) (foo [bar (baz)])|\\\\\\"\\\\n                 \\\\\\"foo |(bar [baz (b|am)])\\\\\\" \\\\\\"foo |(bar [baz (bam)])|\\\\\\"\\\\n                 ;with \:chimera\\\\n                 \\\\\\"(foo |bar]\\\\\\" \\\\\\"(foo |bar|]\\\\\\"\\\\n                 \\\\\\"(foo |{bar)]\\\\\\" \\\\\\"(foo |{bar)|]\\\\\\"\\\\n                 }]\\\\n     [\\\\\\"Shift+Alt+Up\\\\\\" \:paredit-expand-up\\\\n                {\\\\n                 \\\\\\"abc defgh|i \\\\\\" \\\\\\"abc |defghi| \\\\\\"\\\\n                 \\\\\\"|abc| defghi \\\\\\" \\\\\\"|abc defghi |\\\\\\"\\\\n                 \\\\\\"foo bar| baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"foo bar |baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"foo ba|r baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo7 bar b|a|z\\\\\\" \\\\\\"foo7 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo8 bar ba|z|\\\\\\" \\\\\\"foo8 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo9 bar |baz|\\\\\\" \\\\\\"|foo9 bar baz|\\\\\\"\\\\n                 \\\\\\"foo bar| baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"foo |bar baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|foo bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|f|oo bar baz\\\\\\" \\\\\\"|foo| bar baz\\\\\\"\\\\n                 \\\\\\"|foo| bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|foo |bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 \\\\\\"|foo b|ar baz\\\\\\" \\\\\\"|foo bar| baz\\\\\\"\\\\n                 \\\\\\"foo4 (bar| baz)\\\\\\" \\\\\\"foo4 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo5 (bar |baz)\\\\\\" \\\\\\"foo5 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo b|ar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo6 (bar baz|)\\\\\\" \\\\\\"foo6 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo7 (bar |baz|)\\\\\\" \\\\\\"foo7 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\"\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar baz\\\\\\\\\\\\\\"|\\\\\\"\\\\n                 \\\\\\"foo;ba|r\\\\\\\\nbaz\\\\\\" \\\\\\"foo|;bar|\\\\\\\\nbaz\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z] |foo)\\\\\\" \\\\\\"foo (bar |[baz] |foo)\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z]) (foo [bar (b|az)])\\\\\\" \\\\\\"foo |(bar [baz]) (foo [bar (baz)])|\\\\\\"\\\\n                 \\\\\\"foo |(bar [baz (b|am)])\\\\\\" \\\\\\"foo |(bar [baz (bam)])|\\\\\\"\\\\n                 \\\\\\"foo ([|bar])\\\\\\" \\\\\\"foo (|[bar]|)\\\\\\"\\\\n                 \\\\\\"foo ([b|ar])\\\\\\" \\\\\\"foo ([|bar|])\\\\\\"\\\\n                 \\\\\\"foo ([b|a|r])\\\\\\" \\\\\\"foo ([|bar|])\\\\\\"\\\\n                 \\\\\\"foo ([|bar|])\\\\\\" \\\\\\"foo (|[bar]|)\\\\\\"\\\\n                 \\\\\\"foo (|[bar]|)\\\\\\" \\\\\\"foo |([bar])|\\\\\\"\\\\n                 ;with \:chimera\\\\n                 \\\\\\"(foo |bar]\\\\\\" \\\\\\"|(foo bar]|\\\\\\"\\\\n                 \\\\\\"(foo |{bar)]\\\\\\" \\\\\\"|(foo {bar)]|\\\\\\"\\\\n                 }]\\\\n     ]\\\\n    [\\\\\\"Miscellaneous\\\\\\"             \\\\n      [\\\\\\"Tab\\\\\\"     \:paredit-indent-line\\\\n                {\\\\\\"[a\\\\\\\\n|b]\\\\\\"  \\\\\\"[a\\\\\\\\n |b]\\\\\\"\\\\n                 \\\\\\"([a1\\\\\\\\n|b])\\\\\\"  \\\\\\"([a1\\\\\\\\n  |b])\\\\\\"\\\\n                 \\\\\\"([a1b\\\\\\\\n  |b])\\\\\\" \\\\\\"([a1b\\\\\\\\n  |b])\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n |)\\\\\\" \\\\\\"(a\\\\\\\\n  |)\\\\\\"\\\\n                 \\\\\\"(a b c\\\\\\\\nd| e)\\\\\\" \\\\\\"(a b c\\\\\\\\n  d| e)\\\\\\"\\\\n                 \\\\\\"|(toto)\\\\\\" \\\\\\"|(toto)\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n  ;sdfdf\\\\\\\\n  |b)\\\\\\" \\\\\\"(a\\\\\\\\n  ;sdfdf\\\\\\\\n  |b)\\\\\\"\\\\n                 \\\\\\"[a\\\\\\\\n \\\\\\\\\\\\\\"b\\\\\\\\n |\\\\\\\\\\\\\\"]\\\\\\" \\\\\\"[a\\\\\\\\n \\\\\\\\\\\\\\"b\\\\\\\\n |\\\\\\\\\\\\\\"]\\\\\\"\\\\n                 \\\\\\"[a\\\\\\\\n|\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\"]\\\\\\" \\\\\\"[a\\\\\\\\n |\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\"]\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n\\\\\\\\t|b)\\\\\\" \\\\\\"(a\\\\\\\\n  |b)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n|\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n   |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n , |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"  {\\\\\\\\n|a}\\\\\\" \\\\\\"  {\\\\\\\\n   |a}\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n|    ab c)\\\\\\" \\\\\\" (\\\\\\\\n|   ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n |   ab c)\\\\\\" \\\\\\" (\\\\\\\\n |  ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n  |  ab c)\\\\\\" \\\\\\" (\\\\\\\\n  | ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n   | ab c)\\\\\\" \\\\\\" (\\\\\\\\n   |ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n    |ab c)\\\\\\" \\\\\\" (\\\\\\\\n   |ab c)\\\\\\" \\\\n                 \\\\\\" (\\\\\\\\n    a|b c)\\\\\\" \\\\\\" (\\\\\\\\n   a|b c)\\\\\\"  \\\\n                 \\\\\\" (\\\\\\\\n    |    ab c)\\\\\\" \\\\\\" (\\\\\\\\n|   ab c)\\\\\\" \\\\n                 \\\\\\" (\\\\\\\\n      |  ab c)\\\\\\" \\\\\\" (\\\\\\\\n |  ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n  |ab c)\\\\\\" \\\\\\" (\\\\\\\\n   |ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n| ab c)\\\\\\" \\\\\\" (\\\\\\\\n|   ab c)\\\\\\"  \\\\n                 \\\\\\" (\\\\\\\\n  | ab c)\\\\\\" \\\\\\" (\\\\\\\\n  | ab c)\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n |b\\\\\\" \\\\\\"(a\\\\\\\\n  |b\\\\\\" \\\\n                 ;;;\\\\\\"foo (let [n (frobbotz)] \\\\\\\\n|(display (+ n 1)\\\\\\\\nport))\\\\\\\\n        bar\\\\\\"\\\\n                 ;;;(str \\\\\\"foo (let [n (frobbotz)]\\\\\\"\\\\n                 ;;;   \\\\\\"\\\\\\\\n      |(display (+ n 1)\\\\\\"\\\\n                 ;;;   \\\\\\"\\\\\\\\n        port))\\\\\\\\n        bar\\\\\\"\\\\n                 ;;   )\\\\n                 \\\\\\"   a\\\\\\\\n       |\\\\\\" \\\\\\"   a\\\\\\\\n   |\\\\\\"\\\\n                 \\\\\\")|s\\\\\\" \\\\\\")|s\\\\\\"\\\\n                 \\\\\\")\\\\\\\\n|s\\\\\\" \\\\\\")\\\\\\\\n|s\\\\\\"\\\\n                 \\\\\\"\#(a\\\\\\\\n|)\\\\\\" \\\\\\"\#(a\\\\\\\\n   |)\\\\\\"\\\\n                 ; with chimera\\\\n                 \\\\\\"(a\\\\\\\\n|(])\\\\\\" \\\\\\"(a\\\\\\\\n  |(])\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n|\\\\\\" \\\\\\"(a\\\\\\\\n  |\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n|]\\\\\\" \\\\\\"(a\\\\\\\\n  |]\\\\\\"\\\\n                 \\\\\\" \#(a\\\\\\\\n|]\\\\\\" \\\\\\" \#(a\\\\\\\\n    |]\\\\\\"\\\\n                 }]\\\\n      [\#\\\\\\"C-j\\\\\\"     \:paredit-newline\\\\n                {\\\\\\"(ab|cd)\\\\\\" \\\\\\"(ab\\\\\\\\n  |cd)\\\\\\"\\\\n                 \\\\\\"(ab|     cd)\\\\\\" \\\\\\"(ab\\\\\\\\n  |cd)\\\\\\"\\\\n                 \\\\\\"   a|\\\\\\" \\\\\\"   a\\\\\\\\n   |\\\\\\"\\\\n                 ;\\\\\\"foo (let [n (frobbotz)] |(display (+ n 1)\\\\\\\\nport))\\\\\\\\n        bar\\\\\\"\\\\n                 ;(str \\\\\\"foo (let [n (frobbotz)]\\\\\\"\\\\n                 ;   \\\\\\"\\\\\\\\n      |(display (+ n 1)\\\\\\"\\\\n                 ;   \\\\\\"\\\\\\\\n        port))\\\\\\\\n        bar\\\\\\")\\\\n                 }]\\\\n      [\\\\\\"M-S\\\\\\"    \:paredit-split-sexp\\\\n                {\\\\\\"(hello  |  world)\\\\\\" \\\\\\"(hello)| (world)\\\\\\",\\\\n                 \\\\\\"\\\\\\\\\\\\\\"Hello, |world\!\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"Hello, \\\\\\\\\\\\\\"| \\\\\\\\\\\\\\"world\!\\\\\\\\\\\\\\"\\\\\\",\\\\n                 \\\\\\"(hel|lo)\\\\\\" \\\\\\"(hel)| (lo)\\\\\\",\\\\n                 \\\\\\"[hello |world]\\\\\\" \\\\\\"[hello]| [world]\\\\\\",\\\\n                 \\\\\\"{hello brave |new world}\\\\\\" \\\\\\"{hello brave}| {new world}\\\\\\",\\\\n                 \\\\\\"{|}\\\\\\" \\\\\\"{}| {}\\\\\\"\\\\n                 \\\\\\"(foo|)\\\\\\" \\\\\\"(foo)| ()\\\\\\"\\\\n                 \\\\\\"({|})\\\\\\" \\\\\\"({}| {})\\\\\\"\\\\n                 \\\\\\"(defn hello |[world])\\\\\\" \\\\\\"(defn hello)| ([world])\\\\\\"\\\\n                 }]\\\\n      [\\\\\\"M-J\\\\\\"    \:paredit-join-sexps\\\\n                {\\\\\\"(hello)| (world)\\\\\\" \\\\\\"(hello| world)\\\\\\",\\\\n                 \\\\\\"\\\\\\\\\\\\\\"Hello, \\\\\\\\\\\\\\"| \\\\\\\\\\\\\\"world\!\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"Hello, |world\!\\\\\\\\\\\\\\"\\\\\\",\\\\n                 \\\\\\"hello-\\\\\\\\n|  world\\\\\\" \\\\\\"hello-|world\\\\\\"\\\\n                 \\\\\\"({\:foo \:bar}| {\:baz \:fooz})\\\\\\" \\\\\\"({\:foo \:bar| \:baz \:fooz})\\\\\\"\\\\n                 \\\\\\"({\:foo \:bar} |{\:baz \:fooz})\\\\\\" \\\\\\"({\:foo \:bar |\:baz \:fooz})\\\\\\"\\\\n                 \\\\\\"({\:foo \:bar} {|\:baz \:fooz})\\\\\\" \\\\\\"({\:foo \:bar} {|\:baz \:fooz})\\\\\\"\\\\n                 \\\\\\"({\:baz \:fooz|} {\:foo \:bar})\\\\\\" \\\\\\"({\:baz \:fooz|} {\:foo \:bar})\\\\\\"\\\\n                 }]\\\\n    ]\\\\n  ])\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core_commands.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" "(sexp \\"`foo\\")" ";; Loading file src/paredit/core_commands.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.core-commands\\\\n  (\:use clojure.contrib.def))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; -*- Mode\: Emacs-Lisp; outline-regexp\: \\\\\\"\\\\\\\\n;;;;+\\\\\\" -*-\\\\n\\\\n;;;;;; Paredit\: Parenthesis-Editing Minor Mode\\\\n;;;;;; Version 21\\\\n\\\\n;;; Copyright (c) 2008, Taylor R. Campbell\\\\n;;;\\\\n;;; Redistribution and use in source and binary forms, with or without\\\\n;;; modification, are permitted provided that the following conditions\\\\n;;; are met\:\\\\n;;;\\\\n;;; * Redistributions of source code must retain the above copyright\\\\n;;;   notice, this list of conditions and the following disclaimer.\\\\n;;;\\\\n;;; * Redistributions in binary form must reproduce the above copyright\\\\n;;;   notice, this list of conditions and the following disclaimer in\\\\n;;;   the documentation and/or other materials provided with the\\\\n;;;   distribution.\\\\n;;;\\\\n;;; * Neither the names of the authors nor the names of contributors\\\\n;;;   may be used to endorse or promote products derived from this\\\\n;;;   software without specific prior written permission.\\\\n;;;\\\\n;;; THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\\\\n;;; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\\\n;;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\\\\n;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\\\\n;;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\\\n;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\\\\n;;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\\\\n;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\\\\n;;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\\\\n;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\\\\n;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\\\n\\\\n;;; This file is permanently stored at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit-21.el>.\\\\n;;;\\\\n;;; The currently released version of paredit is available at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit.el>.\\\\n;;;\\\\n;;; The latest beta version of paredit is available at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit-beta.el>.\\\\n;;;\\\\n;;; Release notes are available at\\\\n;;;   <http\://mumble.net/~campbell/emacs/paredit.release>.\\\\n\\\\n;;; Install paredit by placing `paredit.el' in `/path/to/elisp', a\\\\n;;; directory of your choice, and adding to your .emacs file\:\\\\n;;;\\\\n;;;   (add-to-list 'load-path \\\\\\"/path/to/elisp\\\\\\")\\\\n;;;   (autoload 'paredit-mode \\\\\\"paredit\\\\\\"\\\\n;;;     \\\\\\"Minor mode for pseudo-structurally editing Lisp code.\\\\\\"\\\\n;;;     t)\\\\n;;;\\\\n;;; Toggle Paredit Mode with `M-x paredit-mode RET', or enable it\\\\n;;; always in a major mode `M' (e.g., `lisp' or `scheme') with\:\\\\n;;;\\\\n;;;   (add-hook M-mode-hook (lambda () (paredit-mode +1)))\\\\n;;;\\\\n;;; Customize paredit using `eval-after-load'\:\\\\n;;;\\\\n;;;   (eval-after-load 'paredit\\\\n;;;     '(progn ...redefine keys, &c....))\\\\n;;;\\\\n;;; Paredit should run in GNU Emacs 21 or later and XEmacs 21.5 or\\\\n;;; later.  Paredit is highly unlikely to work in earlier versions of\\\\n;;; GNU Emacs, and it may have obscure problems in earlier versions of\\\\n;;; XEmacs due to the way its syntax parser reports conditions, as a\\\\n;;; result of which the code that uses the syntax parser must mask all\\\\n;;; error conditions, not just those generated by the syntax parser.\\\\n;;;\\\\n;;; Questions, bug reports, comments, feature suggestions, &c., may be\\\\n;;; addressed via email to the author's surname at mumble.net or via\\\\n;;; IRC to the user named Riastradh on irc.freenode.net in the \#paredit\\\\n;;; channel.\\\\n;;;\\\\n;;; Please contact the author rather than forking your own versions, to\\\\n;;; prevent the dissemination of random variants floating about the\\\\n;;; internet unbeknownst to the author.  Laziness is not an excuse\:\\\\n;;; your laziness costs me confusion and time trying to support\\\\n;;; paredit, so if you fork paredit, you make the world a worse place.\\\\n;;;\\\\n;;; *** WARNING *** IMPORTANT *** DO NOT SUBMIT BUGS BEFORE READING ***\\\\n;;;\\\\n;;; If you plan to submit a bug report, where some sequence of keys in\\\\n;;; Paredit Mode, or some sequence of paredit commands, doesn't do what\\\\n;;; you wanted, then it is helpful to isolate an example in a very\\\\n;;; small buffer, and it is **ABSOLUTELY**ESSENTIAL** that you supply,\\\\n;;; along with the sequence of keys or commands,\\\\n;;;\\\\n;;;   (1) the version of Emacs,\\\\n;;;   (2) the version of paredit.el[*], and\\\\n;;;   (3) the **COMPLETE** state of the buffer used to reproduce the\\\\n;;;       problem, including major mode, minor modes, local key\\\\n;;;       bindings, entire contents of the buffer, leading line breaks\\\\n;;;       or spaces, &c.\\\\n;;;\\\\n;;; It is often extremely difficult to reproduce problems, especially\\\\n;;; with commands like `paredit-kill'.  If you do not supply **ALL** of\\\\n;;; this information, then it is highly probable that I cannot\\\\n;;; reproduce your problem no matter how hard I try, and the effect of\\\\n;;; submitting a bug without this information is only to waste your\\\\n;;; time and mine.  So, please, include all of the above information.\\\\n;;;\\\\n;;; [*] If you are using a beta version of paredit, be sure that you\\\\n;;;     are using the *latest* edition of the beta version, available\\\\n;;;     at <http\://mumble.net/~campbell/emacs/paredit-beta.el>.  If you\\\\n;;;     are not using a beta version, then upgrade either to that or to\\\\n;;;     the latest release version; I cannot support older versions,\\\\n;;;     and I can't fathom any reason why you might be using them.  So\\\\n;;;     the answer to item (2) should be either `release' or `beta'.\\\\n\\\\n;;; The paredit minor mode, Paredit Mode, binds a number of simple\\\\n;;; keys, notably `(', `)', `\\\\\\"', and `\\\\\\\\', to commands that more\\\\n;;; carefully insert S-expression structures in the buffer.  The\\\\n;;; parenthesis delimiter keys (round or square) are defined to insert\\\\n;;; parenthesis pairs and move past the closing delimiter,\\\\n;;; respectively; the double-quote key is multiplexed to do both, and\\\\n;;; also to insert an escape if within a string; and backslashes prompt\\\\n;;; the user for the next character to input, because a lone backslash\\\\n;;; can break structure inadvertently.  These all have their ordinary\\\\n;;; behaviour when inside comments, and, outside comments, if truly\\\\n;;; necessary, you can insert them literally with `C-q'.\\\\n;;;\\\\n;;; The key bindings are designed so that when typing new code in\\\\n;;; Paredit Mode, you can generally use exactly the same keystrokes as\\\\n;;; you would have used without Paredit Mode.  Earlier versions of\\\\n;;; paredit.el did not conform to this, because Paredit Mode bound `)'\\\\n;;; to a command that would insert a newline.  Now `)' is bound to a\\\\n;;; command that does not insert a newline, and `M-)' is bound to the\\\\n;;; command that inserts a newline.  To revert to the former behaviour,\\\\n;;; add the following forms to an `eval-after-load' form for paredit.el\\\\n;;; in your .emacs file\:\\\\n;;;\\\\n;;;   (define-key paredit-mode-map (kbd \\\\\\")\\\\\\")\\\\n;;;     'paredit-close-round-and-newline)\\\\n;;;   (define-key paredit-mode-map (kbd \\\\\\"M-)\\\\\\")\\\\n;;;     'paredit-close-round)\\\\n;;;\\\\n;;; Paredit Mode also binds the usual keys for deleting and killing, so\\\\n;;; that they will not destroy any S-expression structure by killing or\\\\n;;; deleting only one side of a parenthesis or quote pair.  If the\\\\n;;; point is on a closing delimiter, `DEL' will move left over it; if\\\\n;;; it is on an opening delimiter, `C-d' will move right over it.  Only\\\\n;;; if the point is between a pair of delimiters will `C-d' or `DEL'\\\\n;;; delete them, and in that case it will delete both simultaneously.\\\\n;;; `M-d' and `M-DEL' kill words, but skip over any S-expression\\\\n;;; structure.  `C-k' kills from the start of the line, either to the\\\\n;;; line's end, if it contains only balanced expressions; to the first\\\\n;;; closing delimiter, if the point is within a form that ends on the\\\\n;;; line; or up to the end of the last expression that starts on the\\\\n;;; line after the point.\\\\n;;;\\\\n;;; The behaviour of the commands for deleting and killing can be\\\\n;;; overridden by passing a `C-u' prefix argument\: `C-u DEL' will\\\\n;;; delete a character backward, `C-u C-d' will delete a character\\\\n;;; forward, and `C-u C-k' will kill text from the point to the end of\\\\n;;; the line, irrespective of the S-expression structure in the buffer.\\\\n;;; This can be used to fix mistakes in a buffer, but should generally\\\\n;;; be avoided.\\\\n;;;\\\\n;;; Paredit performs automatic reindentation as locally as possible, to\\\\n;;; avoid interfering with custom indentation used elsewhere in some\\\\n;;; S-expression.  Only the advanced S-expression manipulation commands\\\\n;;; automatically reindent, and only the forms that were immediately\\\\n;;; operated upon (and their subforms).\\\\n;;;\\\\n;;; This code is written for clarity, not efficiency.  It frequently\\\\n;;; walks over S-expressions redundantly.  If you have problems with\\\\n;;; the time it takes to execute some of the commands, let me know, but\\\\n;;; first be sure that what you're doing is reasonable\: it is\\\\n;;; preferable to avoid immense S-expressions in code anyway.\\\\n\\\\n;;; This assumes Unix-style LF line endings.\\\\n\\\\n(defmacro defconst [& body] `(clojure.contrib.def/defvar ~@body))\\\\n\\\\n(defconst paredit-version 21)\\\\n(defconst paredit-beta-p nil)\\\\n\\\\n(defvar  \\\\n  paredit-mode-map {} \\\\n  \\\\\\"Keymap for the paredit minor mode.\\\\\\")\\\\n\\\\n(defn check-parens \\\\\\"TODO LAP\: implement it \!\\\\\\" [text] true)\\\\n(defn can-enable-paredit? [text] (check-parens text))\\\\n\\\\n(def \\\\n  ^{ \:doc \\\\\\"\\\\n    The format for documenting the commands is simple, and a slight varation of\\\\n    the original paredit.el format \:\\\\n    paredit-commands \:\= [ group* ]\\\\n    group \:\= [ group-name-str command* ]\\\\n    command \:\= [ default-triggering-keys \\\\n                 command-name-keyword \\\\n                 { before-after-documentation-pair* } \\\\n                 { before-after-non-regression-pair* }* ]\\\\n    before-after-documentation-pair \:\= before-after-non-regression-pair\\\\n    before-after-non-regression-pair \:\= before-text-spec after-text-spec\\\\n    before-text-spec \:\= after-text-spec \:\= text-spec\\\\n    text-spec \:\= a string, with the caret position indicated by a pipe character |, \\\\n                 and if there is a selected portion of the text, the end of the text\\\\n                 selection is marked with another pipe character |\\\\\\"}\\\\n  *paredit-commands*\\\\n  [\\\\n    [\\\\\\"Basic Insertion Commands\\\\\\"\\\\n\\\\t    [\\\\\\"(\\\\\\"         \:paredit-open-round\\\\n\\\\t                {\\\\\\"(a b |c d)\\\\\\"\\\\n\\\\t                 \\\\\\"(a b (|) c d)\\\\\\"\\\\n\\\\t                 \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar (|baz\\\\\\\\\\\\\\" quux)\\\\\\"\\\\n                  }\\\\n\\\\t                {\\\\\\"(a b|c d)\\\\\\" \\\\\\"(a b (|) c d)\\\\\\"\\\\n\\\\t                 \\\\\\"(|)\\\\\\" \\\\\\"((|))\\\\\\"\\\\n\\\\t                 \\\\\\"|\\\\\\" \\\\\\"(|)\\\\\\"\\\\n\\\\t                 \\\\\\"a|\\\\\\" \\\\\\"a (|)\\\\\\"\\\\n\\\\t                 \\\\\\"(a |,b)\\\\\\" \\\\\\"(a (|),b)\\\\\\"\\\\n\\\\t                 \\\\\\"(a,| b)\\\\\\" \\\\\\"(a, (|) b)\\\\\\"\\\\n\\\\t                 \\\\\\"(a,|b)\\\\\\" \\\\\\"(a, (|) b)\\\\\\"\\\\n\\\\t                 \\\\\\"(a,|)\\\\\\" \\\\\\"(a, (|))\\\\\\"\\\\n                   \\\\\\"\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\(| \\\\\\" \\\\n\\\\t                 \\\\\\"~|\\\\\\" \\\\\\"~(|)\\\\\\"\\\\n\\\\t                 \\\\\\"~@|\\\\\\" \\\\\\"~@(|)\\\\\\"\\\\n\\\\t                 \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ (|) \\\\\\"\\\\n                  }]\\\\n\\\\t    [\\\\\\")\\\\\\"         \:paredit-close-round\\\\n\\\\t                {\\\\\\"(a |b)\\\\\\" \\\\\\"(a b)|\\\\\\"\\\\n\\\\t                 \\\\\\"(a |b) cd\\\\\\" \\\\\\"(a b)| cd\\\\\\"\\\\n\\\\t                 \\\\\\"(a |b ) cd\\\\\\" \\\\\\"(a b)| cd\\\\\\"\\\\n\\\\t                 \\\\\\"(a b |c [])\\\\\\" \\\\\\"(a b c [])|\\\\\\"\\\\n                   \\\\\\"(a b c [|] )\\\\\\" \\\\\\"(a b c [])|\\\\\\"\\\\n\\\\t                 \\\\\\"(a b |c   )\\\\\\" \\\\\\"(a b c)|\\\\\\"\\\\n                   \\\\\\"( a,  b |[a b ]   )\\\\\\" \\\\\\"( a,  b [a b ])|\\\\\\"\\\\n                   \\\\\\"( a,  b [|a b ]   )\\\\\\" \\\\\\"( a,  b [a b ])|\\\\\\"\\\\n                   \\\\\\"[ a,  b (|a b )   ]\\\\\\" \\\\\\"[ a,  b (a b)|   ]\\\\\\"\\\\n\\\\t                 \\\\\\"(a b |c ,  )\\\\\\" \\\\\\"(a b c)|\\\\\\"\\\\n\\\\t                 \\\\\\"(a b| [d e]\\\\\\" \\\\\\"(a b)| [d e]\\\\\\"\\\\n\\\\t                 \\\\\\"; Hello,| world\!\\\\\\"  \\\\\\"; Hello,)| world\!\\\\\\"\\\\n\\\\t                 \\\\\\"(  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\\\\\\\\\" foo )\\\\\\" \\\\\\"(  \\\\\\\\\\\\\\"Hello,)| world\!\\\\\\\\\\\\\\" foo )\\\\\\"\\\\n\\\\t                 \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,)| world\!\\\\\\"\\\\n\\\\t                 \\\\\\"foo \\\\\\\\\\\\\\\\|\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\\\)|\\\\\\"\\\\n                  ; tests with the new \:chimera\\\\n                   \\\\\\"({foo |bar])\\\\\\" \\\\\\"({foo bar])|\\\\\\"\\\\n                   \\\\\\"({[foo |bar)})\\\\\\" \\\\\\"({[foo bar)|})\\\\\\"\\\\n                  }]\\\\n\\\\t    \#_[\\\\\\"M-)\\\\\\"       \:paredit-close-round-and-newline\\\\n\\\\t                {\\\\\\"(defun f (x|  ))\\\\\\"\\\\n\\\\t                 \\\\\\"(defun f (x)\\\\\\\\n  |)\\\\\\"\\\\n\\\\t                 \\\\\\"; (Foo.|\\\\\\"\\\\n\\\\t                 \\\\\\"; (Foo.)|\\\\\\"}]\\\\n      [\\\\\\"[\\\\\\"         \:paredit-open-square\\\\n                 {\\\\\\"(a b |c d)\\\\\\"  \\\\\\"(a b [|] c d)\\\\\\"\\\\n                  \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar [|baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\n                  }\\\\n                  {\\\\\\"(a b|c d)\\\\\\" \\\\\\"(a b [|] c d)\\\\\\"\\\\n                   \\\\\\"(|)\\\\\\" \\\\\\"([|])\\\\\\"\\\\n                   \\\\\\"|\\\\\\" \\\\\\"[|]\\\\\\"\\\\n                   \\\\\\"a|\\\\\\" \\\\\\"a [|]\\\\\\"\\\\n                   \\\\\\"(a |,b)\\\\\\" \\\\\\"(a [|],b)\\\\\\"\\\\n                   \\\\\\"(a,| b)\\\\\\" \\\\\\"(a, [|] b)\\\\\\"\\\\n                   \\\\\\"(a,|b)\\\\\\" \\\\\\"(a, [|] b)\\\\\\"\\\\n                   \\\\\\"(a,|)\\\\\\" \\\\\\"(a, [|])\\\\\\"\\\\n                   \\\\\\"\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\[| \\\\\\" \\\\n                   \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ [|] \\\\\\"}]\\\\n      [\\\\\\"]\\\\\\"         \:paredit-close-square\\\\n                  {\\\\\\"(define-key keymap [frob|  ] 'frobnicate)\\\\\\"\\\\n                   \\\\\\"(define-key keymap [frob]| 'frobnicate)\\\\\\"\\\\n                   \\\\\\"; [Bar.|\\\\\\" \\\\\\"; [Bar.]|\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,]| world\!\\\\\\\\\\\\\\" foo\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,]| world\!\\\\\\"\\\\n                   \\\\\\"foo \\\\\\\\\\\\\\\\|\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\\\]|\\\\\\"\\\\n                   ; tests with the new \:chimera\\\\n                   \\\\\\"({foo |bar])\\\\\\" \\\\\\"({foo bar]|)\\\\\\"\\\\n                   \\\\\\"({(foo |bar]))\\\\\\" \\\\\\"({(foo bar]|))\\\\\\"\\\\n                   \\\\\\"({[foo |bar)})\\\\\\" \\\\\\"({[foo ]|bar)})\\\\\\"\\\\n                   \\\\\\"[foo (bar [baz {bleh |blah}))]\\\\\\" \\\\\\"[foo (bar [baz {bleh blah}))]|\\\\\\"\\\\n                   }]\\\\n      [\\\\\\"{\\\\\\"         \:paredit-open-curly\\\\n                 {\\\\\\"(a b |c d)\\\\\\"  \\\\\\"(a b {|} c d)\\\\\\"\\\\n                  \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar {|baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\n                  }\\\\n                  {\\\\\\"(a b|c d)\\\\\\" \\\\\\"(a b {|} c d)\\\\\\"\\\\n                   \\\\\\"(|)\\\\\\" \\\\\\"({|})\\\\\\"\\\\n                   \\\\\\"|\\\\\\" \\\\\\"{|}\\\\\\"\\\\n                   \\\\\\"a|\\\\\\" \\\\\\"a {|}\\\\\\"\\\\n                   \\\\\\"\#|\\\\\\" \\\\\\"\#{|}\\\\\\" ; specific to clojure sets\\\\n                   \\\\\\"(a |,b)\\\\\\" \\\\\\"(a {|},b)\\\\\\"\\\\n                   \\\\\\"(a,| b)\\\\\\" \\\\\\"(a, {|} b)\\\\\\"\\\\n                   \\\\\\"(a,|b)\\\\\\" \\\\\\"(a, {|} b)\\\\\\"\\\\n                   \\\\\\"(a,|)\\\\\\" \\\\\\"(a, {|})\\\\\\"\\\\n                   \\\\\\"\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\{| \\\\\\" \\\\n                   \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\| \\\\\\" \\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ {|} \\\\\\"\\\\n                   }]\\\\n      [\\\\\\"}\\\\\\"         \:paredit-close-curly\\\\n                  {\\\\\\"{a b |c   }\\\\\\" \\\\\\"{a b c}|\\\\\\"\\\\n                   \\\\\\"; Hello,| world\!\\\\\\"\\\\n                   \\\\\\"; Hello,}| world\!\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,}| world\!\\\\\\\\\\\\\\" foo\\\\\\"\\\\n                   \\\\\\"  \\\\\\\\\\\\\\"Hello,| world\!\\\\\\" \\\\\\"  \\\\\\\\\\\\\\"Hello,}| world\!\\\\\\"\\\\n                   \\\\\\"foo \\\\\\\\\\\\\\\\|\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\\\}|\\\\\\"\\\\n                   \\\\\\"({(foo |bar}))\\\\\\" \\\\\\"({(foo bar}|))\\\\\\"\\\\n                   }]\\\\n      [\\\\\\"\\\\\\\\\\\\\\"\\\\\\"        \:paredit-doublequote\\\\n                  { \\\\\\"(frob grovel |full lexical)\\\\\\" \\\\\\"(frob grovel \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" full lexical)\\\\\\",\\\\n                   \\\\\\"(frob grovel \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" full lexical)\\\\\\" \\\\\\"(frob grovel \\\\\\\\\\\\\\"\\\\\\\\\\\\\\"| full lexical)\\\\\\",\\\\n                   \\\\\\"(foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"bar \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|baz\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                   \\\\\\";|ab\\\\\\" \\\\\\";\\\\\\\\\\\\\\"|ab\\\\\\", \\\\n                   \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\|bar\\\\\\\\\\\\\\" full lexical)\\\\\\"\\\\n                     \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\\\\\\\\\" full lexical)\\\\\\",\\\\n                   \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|bar\\\\\\\\\\\\\\" full lexical)\\\\\\"\\\\n                     \\\\\\"(frob grovel \\\\\\\\\\\\\\"foo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|bar\\\\\\\\\\\\\\" full lexical)\\\\\\",\\\\n                   \\\\\\"\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b|ar\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|ar\\\\\\\\\\\\\\"\\\\\\",\\\\n                     \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b|ar\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|ar\\\\\\\\\\\\\\"\\\\\\",\\\\n                   \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|a\\\\\\\\\\\\\\"\\\\\\",\\\\n                   \\\\\\"\\\\\\\\\\\\\\"fo|o\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|o\\\\\\\\\\\\\\"\\\\\\",\\\\n                   ;\\\\\\"\#\\\\\\\\\\\\\\"fo|o\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"fo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"|o\\\\\\\\\\\\\\"\\\\\\",\\\\n                   ;;;\\\\\\"\#\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\"\\\\\\"\\\\n\\\\n                  ;; \\\\\\"\#|\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\" ; specific to clojure regexs\\\\n\\\\n                   }]\\\\n    ]\\\\n    [\\\\\\"Deleting & Killing\\\\\\"\\\\n      [\\\\\\"Del\\\\\\"     \:paredit-forward-delete\\\\n                {\\\\\\"(quu|x \\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(quu| \\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\")\\\\\\",\\\\n                 \\\\\\"(quux |\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(quux \\\\\\\\\\\\\\"|zot\\\\\\\\\\\\\\")\\\\\\",\\\\n                 \\\\\\"(quux \\\\\\\\\\\\\\"|zot\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(quux \\\\\\\\\\\\\\"|ot\\\\\\\\\\\\\\")\\\\\\",\\\\n                 \\\\\\"(foo |(a) bar)\\\\\\" \\\\\\"(foo (|a) bar)\\\\\\"\\\\n                 \\\\\\"(foo (|a) bar)\\\\\\" \\\\\\"(foo (|) bar)\\\\\\" \\\\n                 \\\\\\"(foo (|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo [|] bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo {|} bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo (a|) bar)\\\\\\" \\\\\\"(foo (a|) bar)\\\\\\"\\\\n                 \\\\\\"(foo [a|] bar)\\\\\\" \\\\\\"(foo [a|] bar)\\\\\\"\\\\n                 \\\\\\"(foo {a|} bar)\\\\\\" \\\\\\"(foo {a|} bar)\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \#{|} bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \#{a|} bar)\\\\\\" \\\\\\"(foo \#{a|} bar)\\\\\\"\\\\n                 \\\\\\"(foo \#{a |d} bar)\\\\\\" \\\\\\"(foo \#{a |} bar)\\\\\\"\\\\n                 \\\\\\"(|\#{foo bar})\\\\\\" \\\\\\"(\#{|foo bar})\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \#(|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \#(a|) bar)\\\\\\" \\\\\\"(foo \#(a|) bar)\\\\\\"\\\\n                 \\\\\\"(foo \#(a |d) bar)\\\\\\" \\\\\\"(foo \#(a |) bar)\\\\\\"\\\\n                 \\\\\\"(|\#(foo bar))\\\\\\" \\\\\\"(\#(|foo bar))\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\"\\\\n                 \\\\\\"(foo \#\\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo \#\\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\"\\\\n                 \\\\\\"(foo \#\\\\\\\\\\\\\\"a |d\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo \#\\\\\\\\\\\\\\"a |\\\\\\\\\\\\\\" bar)\\\\\\"\\\\n                 \\\\\\"(|\#\\\\\\\\\\\\\\"foo bar\\\\\\\\\\\\\\")\\\\\\" \\\\\\"(\#\\\\\\\\\\\\\\"|foo bar\\\\\\\\\\\\\\")\\\\\\"\\\\n\\\\n                 \\\\\\"(foo \\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\\\"(foo \\\\\\\\\\\\\\"a|\\\\\\\\\\\\\\" bar)\\\\\\" \\\\n                 \\\\\\"(|(foo bar))\\\\\\" \\\\\\"((|foo bar))\\\\\\"\\\\n                 \\\\\\"(|[foo bar])\\\\\\" \\\\\\"([|foo bar])\\\\\\"\\\\n                 \\\\\\"(|{foo bar})\\\\\\" \\\\\\"({|foo bar})\\\\\\"\\\\n                 \\\\n                 \\\\\\"|\\\\\\" \\\\\\"|\\\\\\"\\\\n                 }]\\\\n      [\\\\\\"BackDel\\\\\\" \:paredit-backward-delete\\\\n                {\\\\n                 \\\\\\"(\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\" q|uux)\\\\\\" \\\\\\"(\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\" |uux)\\\\\\",\\\\n                 \\\\\\"(\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\"| quux)\\\\\\" \\\\\\"(\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                 \\\\\\"(\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(\\\\\\\\\\\\\\"zo|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n\\\\n                 \\\\\\"(\#\\\\\\\\\\\\\\"zot\\\\\\\\\\\\\\"| quux)\\\\\\" \\\\\\"(\#\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                 \\\\\\"(\#\\\\\\\\\\\\\\"zot|\\\\\\\\\\\\\\" quux)\\\\\\" \\\\\\"(\#\\\\\\\\\\\\\\"zo|\\\\\\\\\\\\\\" quux)\\\\\\",\\\\n                 \\\\n                 \\\\\\"(foo (|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\",\\\\n                 \\\\\\"(foo \#(|) bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\",\\\\n                 \\\\\\"(foo \#{|} bar)\\\\\\" \\\\\\"(foo | bar)\\\\\\",\\\\n                 \\\\n                 \\\\\\"(foo bar)|\\\\\\" \\\\\\"(foo bar|)\\\\\\",\\\\n                 \\\\\\"(foo bar|)\\\\\\" \\\\\\"(foo ba|)\\\\\\",\\\\n                 \\\\n                 \\\\\\"|\\\\\\" \\\\\\"|\\\\\\"\\\\n                 \\\\n                 \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|\\\\\\" \\\\\\"\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\"\\\\n                 \\\\\\"\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\" \\\\\\"|\\\\\\"\\\\n                 \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\\\\\\\\\"|\\\\\\" \\\\\\"\#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\"\\\\n                 \\\\\\"\#\\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\" \\\\\\"|\\\\\\"\\\\n                 \\\\n                 \\\\\\"\#(foo bar)|\\\\\\" \\\\\\"\#(foo bar|)\\\\\\",\\\\n                 \\\\\\"\#(foo bar|)\\\\\\" \\\\\\"\#(foo ba|)\\\\\\",\\\\n                 \\\\\\"\#{foo bar}|\\\\\\" \\\\\\"\#{foo bar|}\\\\\\",\\\\n                 \\\\\\"\#{foo bar|}\\\\\\" \\\\\\"\#{foo ba|}\\\\\\",\\\\n                 \\\\\\"\#(|)\\\\\\" \\\\\\"|\\\\\\",\\\\n                 \\\\\\"\#{|}\\\\\\" \\\\\\"|\\\\\\"\\\\n                 }]\\\\n      ;\#_[\\\\\\"C-k\\\\\\"     \:paredit-kill\\\\n      ;          {\\\\\\"(foo bar)|     ; Useless comment\!\\\\\\"\\\\n      ;           \\\\\\"(foo bar)|\\\\\\",\\\\n      ;          \\\\\\"(|foo bar)     ; Useful comment\!\\\\\\"\\\\n      ;           \\\\\\"(|)     ; Useful comment\!\\\\\\",\\\\n      ;          \\\\\\"|(foo bar)     ; Useless line\!\\\\\\"\\\\n      ;           \\\\\\"|\\\\\\",\\\\n      ;          \\\\\\"(foo \\\\\\\\\\\\\\"|bar baz\\\\\\\\\\\\\\"\\\\\\\\n     quux)\\\\\\"\\\\n      ;           \\\\\\"(foo \\\\\\\\\\\\\\"|\\\\\\\\\\\\\\"\\\\\\\\n     quux)\\\\\\"}]\\\\n      ]\\\\n    \\\\n    [\\\\\\"Depth-Changing Commands\\\\\\"\\\\n     [\\\\\\"M-(\\\\\\"       \:paredit-wrap-round\\\\n      {\\\\\\"(foo |bar baz)\\\\\\" \\\\\\"(foo (|bar) baz)\\\\\\",\\\\n       \\\\\\";hel|lo\\\\\\" \\\\\\";hel(|lo\\\\\\",\\\\n       \\\\\\"a |\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\"\\\\\\" \\\\\\"a (|\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\")\\\\\\",\\\\n       \\\\\\"a |\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\"|\\\\\\" \\\\\\"a (|\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\"|)\\\\\\",\\\\n       \\\\\\"foo |bar| foo\\\\\\" \\\\\\"foo (|bar|) foo\\\\\\",\\\\n       \\\\\\"foo |bar baz| foo\\\\\\" \\\\\\"foo (|bar baz|) foo\\\\\\",\\\\n       \\\\\\"foo (|bar| baz) foo\\\\\\" \\\\\\"foo ((|bar|) baz) foo\\\\\\"\\\\n       \\\\\\"foo (|bar baz|) foo\\\\\\" \\\\\\"foo ((|bar baz|)) foo\\\\\\"\\\\n       ;; not-yet \\\\\\"foo |(bar| baz) foo\\\\\\" \\\\\\"foo |(bar| baz) foo\\\\\\"\\\\n       ;; not-yet \\\\\\"foo (bar| baz)| foo\\\\\\" \\\\\\"foo (bar| baz)| foo\\\\\\"\\\\n       \\\\\\"foo |(bar baz)| foo\\\\\\" \\\\\\"foo (|(bar baz)|) foo\\\\\\"\\\\n       \\\\\\"foo |(bar\\\\\\\\n;comment\\\\\\\\n baz)| foo\\\\\\" \\\\\\"foo (|(bar\\\\\\\\n;comment\\\\\\\\n baz)|) foo\\\\\\"\\\\n       ;; not-yet \\\\\\"foo |bar ba|z foo\\\\\\" \\\\\\"foo |bar ba|z foo\\\\\\",\\\\n       \\\\\\"foo \\\\\\\\\\\\\\"|bar ba|z\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"foo \\\\\\\\\\\\\\"(|z\\\\\\\\\\\\\\" foo\\\\\\",\\\\n       ;; not-yet \\\\\\"foo |\\\\\\\\\\\\\\"bar ba|z\\\\\\\\\\\\\\" foo\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar ba|z\\\\\\\\\\\\\\" foo\\\\\\",\\\\n       \\\\\\"foo |bar|\\\\\\" \\\\\\"foo (|bar|)\\\\\\"\\\\n       \\\\\\"foo |(bar)|\\\\\\" \\\\\\"foo (|(bar)|)\\\\\\"\\\\n       \\\\\\"bar |`foo| baz\\\\\\" \\\\\\"bar (|`foo|) baz\\\\\\"\\\\n       }]\\\\n     ;[\\\\\\"M-s\\\\\\"       \:paredit-splice-sexp\\\\n     ;           {\\\\\\"(foo (bar| baz) quux)\\\\\\"\\\\n     ;            \\\\\\"(foo bar| baz quux)\\\\\\"}]\\\\n     ;[(\\\\\\"M-<up>\\\\\\" \\\\\\"ESC <up>\\\\\\")\\\\n     ;           paredit-splice-sexp-killing-backward\\\\n     ;           (\\\\\\"(foo (let ((x 5)) |(sqrt n)) bar)\\\\\\"\\\\n     ;            \\\\\\"(foo (sqrt n) bar)\\\\\\")]\\\\n     ;((\\\\\\"M-<down>\\\\\\" \\\\\\"ESC <down>\\\\\\")\\\\n     ;           paredit-splice-sexp-killing-forward\\\\n     ;           (\\\\\\"(a (b c| d e) f)\\\\\\"\\\\n     ;            \\\\\\"(a b c f)\\\\\\"))\\\\n     [\\\\\\"M-r\\\\\\"       \:paredit-raise-sexp\\\\n                {\\\\\\"(dynamic-wind in (lambda () |body|) out)\\\\\\" \\\\\\"(dynamic-wind in |body out)\\\\\\"\\\\n                 \\\\\\"(dynamic-wind in |body| out)\\\\\\" \\\\\\"|body\\\\\\" \\\\n                 \\\\\\"(foo bar|)\\\\\\" \\\\\\"(foo bar|)\\\\\\"\\\\n                 \\\\\\"(foo |bar)\\\\\\" \\\\\\"|bar\\\\\\"\\\\n                 \\\\\\"(foo |(bar))\\\\\\" \\\\\\"|(bar)\\\\\\"\\\\n                 \\\\\\"(foo |(bar]|)\\\\\\" \\\\\\"|(bar]\\\\\\"\\\\n                 }]\\\\n     ]\\\\n    \\\\n    [\\\\\\"Selection\\\\\\"\\\\n     [\\\\\\"Shift+Alt+Left\\\\\\" \:paredit-expand-left\\\\n                {\\\\n                 \\\\\\"foo bar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo bar |baz\\\\\\" \\\\\\"foo bar| |baz\\\\\\"\\\\n                 \\\\\\"foo ba|r baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo1 bar b|a|z\\\\\\" \\\\\\"foo1 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo2 bar ba|z|\\\\\\" \\\\\\"foo2 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo3 bar |baz|\\\\\\" \\\\\\"foo3 bar| baz|\\\\\\"\\\\n                 \\\\\\"foo bar| baz|\\\\\\" \\\\\\"foo |bar baz|\\\\\\"\\\\n                 \\\\\\"foo |bar baz|\\\\\\" \\\\\\"foo| bar baz|\\\\\\"\\\\n                 \\\\\\"|(foo bar baz)|\\\\\\" \\\\\\"|(foo bar baz)|\\\\\\"\\\\n                 ;;not-yet \\\\\\"|fo|o bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 ;;not-yet \\\\\\"|foo| bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 ;;not-yet \\\\\\"|foo |bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 ;;not-yet \\\\\\"|foo b|ar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 \\\\\\"foo (bar| baz)\\\\\\" \\\\\\"foo (|bar| baz)\\\\\\"\\\\n                 \\\\\\"foo b|ar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo1 (|bar| baz)\\\\\\" \\\\\\"foo1 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\"\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar baz\\\\\\\\\\\\\\"|\\\\\\"\\\\n                 \\\\\\"foo;ba|r\\\\\\\\nbaz\\\\\\" \\\\\\"foo|;bar|\\\\\\\\nbaz\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z] |foo)\\\\\\" \\\\\\"foo (bar |[baz] |foo)\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z]) (foo [bar (b|az)])\\\\\\" \\\\\\"foo |(bar [baz]) (foo [bar (baz)])|\\\\\\"\\\\n                 \\\\\\"foo |(bar [baz (b|am)])\\\\\\" \\\\\\"foo |(bar [baz (bam)])|\\\\\\"\\\\n                 \\\\\\"(foo bar|)\\\\\\" \\\\\\"(foo |bar|)\\\\\\"\\\\n                 \\\\\\"fooz foo |(bar)| baz\\\\\\" \\\\\\"fooz foo| (bar)| baz\\\\\\"\\\\n                 \\\\\\"fooz foo| (bar)| baz\\\\\\" \\\\\\"fooz |foo (bar)| baz\\\\\\"\\\\n                 ;with \:chimera\\\\n                 \\\\\\"(foo bar|]\\\\\\" \\\\\\"(foo |bar|]\\\\\\"\\\\n                 \\\\\\"(foo {bar)|]\\\\\\" \\\\\\"(foo |{bar)|]\\\\\\"\\\\n                 }]\\\\n     [\\\\\\"Shift+Alt+Right\\\\\\" \:paredit-expand-right\\\\n                {\\\\n                 \\\\\\"foo bar| baz\\\\\\" \\\\\\"foo bar| |baz\\\\\\"\\\\n                 \\\\\\"foo4 bar |baz\\\\\\" \\\\\\"foo4 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo ba|r baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo5 bar b|a|z\\\\\\" \\\\\\"foo5 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo6 bar ba|z|\\\\\\" \\\\\\"foo6 bar |baz|\\\\\\"\\\\n                 ;;not-yet \\\\\\"foo bar |baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 ;;not-yet \\\\\\"foo bar| baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 ;;not-yet \\\\\\"foo |bar baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|foo bar baz\\\\\\" \\\\\\"|foo| bar baz\\\\\\";;\\\\n                 \\\\\\"|f|oo bar baz\\\\\\" \\\\\\"|foo| bar baz\\\\\\"\\\\n                 \\\\\\"|foo| bar baz\\\\\\" \\\\\\"|foo |bar baz\\\\\\"\\\\n                 \\\\\\"|foo |bar baz\\\\\\" \\\\\\"|foo bar| baz\\\\\\"\\\\n                 \\\\\\"|foo b|ar baz\\\\\\" \\\\\\"|foo bar| baz\\\\\\"\\\\n                 \\\\\\"foo (bar| baz)\\\\\\" \\\\\\"foo (bar| |baz)\\\\\\"\\\\n                 \\\\\\"foo (bar |baz)\\\\\\" \\\\\\"foo (bar |baz|)\\\\\\"\\\\n                 \\\\\\"foo b|ar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo2 (bar baz|)\\\\\\" \\\\\\"foo2 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo3 (bar |baz|)\\\\\\" \\\\\\"foo3 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\"\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar baz\\\\\\\\\\\\\\"|\\\\\\"\\\\n                 \\\\\\"foo;ba|r\\\\\\\\nbaz\\\\\\" \\\\\\"foo|;bar|\\\\\\\\nbaz\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z] |foo)\\\\\\" \\\\\\"foo (bar |[baz] |foo)\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z]) (foo [bar (b|az)])\\\\\\" \\\\\\"foo |(bar [baz]) (foo [bar (baz)])|\\\\\\"\\\\n                 \\\\\\"foo |(bar [baz (b|am)])\\\\\\" \\\\\\"foo |(bar [baz (bam)])|\\\\\\"\\\\n                 ;with \:chimera\\\\n                 \\\\\\"(foo |bar]\\\\\\" \\\\\\"(foo |bar|]\\\\\\"\\\\n                 \\\\\\"(foo |{bar)]\\\\\\" \\\\\\"(foo |{bar)|]\\\\\\"\\\\n                 }]\\\\n     [\\\\\\"Shift+Alt+Up\\\\\\" \:paredit-expand-up\\\\n                {\\\\n                 \\\\\\"abc defgh|i \\\\\\" \\\\\\"abc |defghi| \\\\\\"\\\\n                 \\\\\\"|abc| defghi \\\\\\" \\\\\\"|abc defghi |\\\\\\"\\\\n                 \\\\\\"foo bar| baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"foo bar |baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"foo ba|r baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo7 bar b|a|z\\\\\\" \\\\\\"foo7 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo8 bar ba|z|\\\\\\" \\\\\\"foo8 bar |baz|\\\\\\"\\\\n                 \\\\\\"foo9 bar |baz|\\\\\\" \\\\\\"|foo9 bar baz|\\\\\\"\\\\n                 \\\\\\"foo bar| baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"foo |bar baz|\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|foo bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|f|oo bar baz\\\\\\" \\\\\\"|foo| bar baz\\\\\\"\\\\n                 \\\\\\"|foo| bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\"\\\\n                 \\\\\\"|foo |bar baz\\\\\\" \\\\\\"|foo bar baz|\\\\\\" \\\\n                 \\\\\\"|foo b|ar baz\\\\\\" \\\\\\"|foo bar| baz\\\\\\"\\\\n                 \\\\\\"foo4 (bar| baz)\\\\\\" \\\\\\"foo4 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo5 (bar |baz)\\\\\\" \\\\\\"foo5 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo b|ar| baz\\\\\\" \\\\\\"foo |bar| baz\\\\\\"\\\\n                 \\\\\\"foo6 (bar baz|)\\\\\\" \\\\\\"foo6 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo7 (bar |baz|)\\\\\\" \\\\\\"foo7 |(bar baz)|\\\\\\"\\\\n                 \\\\\\"foo \\\\\\\\\\\\\\"bar |baz\\\\\\\\\\\\\\"\\\\\\" \\\\\\"foo |\\\\\\\\\\\\\\"bar baz\\\\\\\\\\\\\\"|\\\\\\"\\\\n                 \\\\\\"foo;ba|r\\\\\\\\nbaz\\\\\\" \\\\\\"foo|;bar|\\\\\\\\nbaz\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z] |foo)\\\\\\" \\\\\\"foo (bar |[baz] |foo)\\\\\\"\\\\n                 \\\\\\"foo (bar [ba|z]) (foo [bar (b|az)])\\\\\\" \\\\\\"foo |(bar [baz]) (foo [bar (baz)])|\\\\\\"\\\\n                 \\\\\\"foo |(bar [baz (b|am)])\\\\\\" \\\\\\"foo |(bar [baz (bam)])|\\\\\\"\\\\n                 \\\\\\"foo ([|bar])\\\\\\" \\\\\\"foo (|[bar]|)\\\\\\"\\\\n                 \\\\\\"foo ([b|ar])\\\\\\" \\\\\\"foo ([|bar|])\\\\\\"\\\\n                 \\\\\\"foo ([b|a|r])\\\\\\" \\\\\\"foo ([|bar|])\\\\\\"\\\\n                 \\\\\\"foo ([|bar|])\\\\\\" \\\\\\"foo (|[bar]|)\\\\\\"\\\\n                 \\\\\\"foo (|[bar]|)\\\\\\" \\\\\\"foo |([bar])|\\\\\\"\\\\n                 ;with \:chimera\\\\n                 \\\\\\"(foo |bar]\\\\\\" \\\\\\"|(foo bar]|\\\\\\"\\\\n                 \\\\\\"(foo |{bar)]\\\\\\" \\\\\\"|(foo {bar)]|\\\\\\"\\\\n                 }]\\\\n     ]\\\\n    [\\\\\\"Miscellaneous\\\\\\"             \\\\n      [\\\\\\"Tab\\\\\\"     \:paredit-indent-line\\\\n                {\\\\\\"[a\\\\\\\\n|b]\\\\\\"  \\\\\\"[a\\\\\\\\n |b]\\\\\\"\\\\n                 \\\\\\"([a1\\\\\\\\n|b])\\\\\\"  \\\\\\"([a1\\\\\\\\n  |b])\\\\\\"\\\\n                 \\\\\\"([a1b\\\\\\\\n  |b])\\\\\\" \\\\\\"([a1b\\\\\\\\n  |b])\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n |)\\\\\\" \\\\\\"(a\\\\\\\\n  |)\\\\\\"\\\\n                 \\\\\\"(a b c\\\\\\\\nd| e)\\\\\\" \\\\\\"(a b c\\\\\\\\n  d| e)\\\\\\"\\\\n                 \\\\\\"|(toto)\\\\\\" \\\\\\"|(toto)\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n  ;sdfdf\\\\\\\\n  |b)\\\\\\" \\\\\\"(a\\\\\\\\n  ;sdfdf\\\\\\\\n  |b)\\\\\\"\\\\n                 \\\\\\"[a\\\\\\\\n \\\\\\\\\\\\\\"b\\\\\\\\n |\\\\\\\\\\\\\\"]\\\\\\" \\\\\\"[a\\\\\\\\n \\\\\\\\\\\\\\"b\\\\\\\\n |\\\\\\\\\\\\\\"]\\\\\\"\\\\n                 \\\\\\"[a\\\\\\\\n|\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\"]\\\\\\" \\\\\\"[a\\\\\\\\n |\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\"]\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n\\\\\\\\t|b)\\\\\\" \\\\\\"(a\\\\\\\\n  |b)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n|\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n   |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"(\\\\\\\\n , |\\\\\\\\n)\\\\\\" \\\\\\"(\\\\\\\\n  |\\\\\\\\n)\\\\\\"\\\\n                 \\\\\\"  {\\\\\\\\n|a}\\\\\\" \\\\\\"  {\\\\\\\\n   |a}\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n|    ab c)\\\\\\" \\\\\\" (\\\\\\\\n|   ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n |   ab c)\\\\\\" \\\\\\" (\\\\\\\\n |  ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n  |  ab c)\\\\\\" \\\\\\" (\\\\\\\\n  | ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n   | ab c)\\\\\\" \\\\\\" (\\\\\\\\n   |ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n    |ab c)\\\\\\" \\\\\\" (\\\\\\\\n   |ab c)\\\\\\" \\\\n                 \\\\\\" (\\\\\\\\n    a|b c)\\\\\\" \\\\\\" (\\\\\\\\n   a|b c)\\\\\\"  \\\\n                 \\\\\\" (\\\\\\\\n    |    ab c)\\\\\\" \\\\\\" (\\\\\\\\n|   ab c)\\\\\\" \\\\n                 \\\\\\" (\\\\\\\\n      |  ab c)\\\\\\" \\\\\\" (\\\\\\\\n |  ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n  |ab c)\\\\\\" \\\\\\" (\\\\\\\\n   |ab c)\\\\\\"\\\\n                 \\\\\\" (\\\\\\\\n| ab c)\\\\\\" \\\\\\" (\\\\\\\\n|   ab c)\\\\\\"  \\\\n                 \\\\\\" (\\\\\\\\n  | ab c)\\\\\\" \\\\\\" (\\\\\\\\n  | ab c)\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n |b\\\\\\" \\\\\\"(a\\\\\\\\n  |b\\\\\\" \\\\n                 ;;;\\\\\\"foo (let [n (frobbotz)] \\\\\\\\n|(display (+ n 1)\\\\\\\\nport))\\\\\\\\n        bar\\\\\\"\\\\n                 ;;;(str \\\\\\"foo (let [n (frobbotz)]\\\\\\"\\\\n                 ;;;   \\\\\\"\\\\\\\\n      |(display (+ n 1)\\\\\\"\\\\n                 ;;;   \\\\\\"\\\\\\\\n        port))\\\\\\\\n        bar\\\\\\"\\\\n                 ;;   )\\\\n                 \\\\\\"   a\\\\\\\\n       |\\\\\\" \\\\\\"   a\\\\\\\\n   |\\\\\\"\\\\n                 \\\\\\")|s\\\\\\" \\\\\\")|s\\\\\\"\\\\n                 \\\\\\")\\\\\\\\n|s\\\\\\" \\\\\\")\\\\\\\\n|s\\\\\\"\\\\n                 \\\\\\"\#(a\\\\\\\\n|)\\\\\\" \\\\\\"\#(a\\\\\\\\n   |)\\\\\\"\\\\n                 ; with chimera\\\\n                 \\\\\\"(a\\\\\\\\n|(])\\\\\\" \\\\\\"(a\\\\\\\\n  |(])\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n|\\\\\\" \\\\\\"(a\\\\\\\\n  |\\\\\\"\\\\n                 \\\\\\"(a\\\\\\\\n|]\\\\\\" \\\\\\"(a\\\\\\\\n  |]\\\\\\"\\\\n                 \\\\\\" \#(a\\\\\\\\n|]\\\\\\" \\\\\\" \#(a\\\\\\\\n    |]\\\\\\"\\\\n                 }]\\\\n      [\#\\\\\\"C-j\\\\\\"     \:paredit-newline\\\\n                {\\\\\\"(ab|cd)\\\\\\" \\\\\\"(ab\\\\\\\\n  |cd)\\\\\\"\\\\n                 \\\\\\"(ab|     cd)\\\\\\" \\\\\\"(ab\\\\\\\\n  |cd)\\\\\\"\\\\n                 \\\\\\"   a|\\\\\\" \\\\\\"   a\\\\\\\\n   |\\\\\\"\\\\n                 ;\\\\\\"foo (let [n (frobbotz)] |(display (+ n 1)\\\\\\\\nport))\\\\\\\\n        bar\\\\\\"\\\\n                 ;(str \\\\\\"foo (let [n (frobbotz)]\\\\\\"\\\\n                 ;   \\\\\\"\\\\\\\\n      |(display (+ n 1)\\\\\\"\\\\n                 ;   \\\\\\"\\\\\\\\n        port))\\\\\\\\n        bar\\\\\\")\\\\n                 }]\\\\n      [\\\\\\"M-S\\\\\\"    \:paredit-split-sexp\\\\n                {\\\\\\"(hello  |  world)\\\\\\" \\\\\\"(hello)| (world)\\\\\\",\\\\n                 \\\\\\"\\\\\\\\\\\\\\"Hello, |world\!\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"Hello, \\\\\\\\\\\\\\"| \\\\\\\\\\\\\\"world\!\\\\\\\\\\\\\\"\\\\\\",\\\\n                 \\\\\\"(hel|lo)\\\\\\" \\\\\\"(hel)| (lo)\\\\\\",\\\\n                 \\\\\\"[hello |world]\\\\\\" \\\\\\"[hello]| [world]\\\\\\",\\\\n                 \\\\\\"{hello brave |new world}\\\\\\" \\\\\\"{hello brave}| {new world}\\\\\\",\\\\n                 \\\\\\"{|}\\\\\\" \\\\\\"{}| {}\\\\\\"\\\\n                 \\\\\\"(foo|)\\\\\\" \\\\\\"(foo)| ()\\\\\\"\\\\n                 \\\\\\"({|})\\\\\\" \\\\\\"({}| {})\\\\\\"\\\\n                 \\\\\\"(defn hello |[world])\\\\\\" \\\\\\"(defn hello)| ([world])\\\\\\"\\\\n                 }]\\\\n      [\\\\\\"M-J\\\\\\"    \:paredit-join-sexps\\\\n                {\\\\\\"(hello)| (world)\\\\\\" \\\\\\"(hello| world)\\\\\\",\\\\n                 \\\\\\"\\\\\\\\\\\\\\"Hello, \\\\\\\\\\\\\\"| \\\\\\\\\\\\\\"world\!\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"Hello, |world\!\\\\\\\\\\\\\\"\\\\\\",\\\\n                 \\\\\\"hello-\\\\\\\\n|  world\\\\\\" \\\\\\"hello-|world\\\\\\"\\\\n                 \\\\\\"({\:foo \:bar}| {\:baz \:fooz})\\\\\\" \\\\\\"({\:foo \:bar| \:baz \:fooz})\\\\\\"\\\\n                 \\\\\\"({\:foo \:bar} |{\:baz \:fooz})\\\\\\" \\\\\\"({\:foo \:bar |\:baz \:fooz})\\\\\\"\\\\n                 \\\\\\"({\:foo \:bar} {|\:baz \:fooz})\\\\\\" \\\\\\"({\:foo \:bar} {|\:baz \:fooz})\\\\\\"\\\\n                 \\\\\\"({\:baz \:fooz|} {\:foo \:bar})\\\\\\" \\\\\\"({\:baz \:fooz|} {\:foo \:bar})\\\\\\"\\\\n                 }]\\\\n    ]\\\\n  ])\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core_commands.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println \\\\\\"left-leave\: node\:\\\\\\" (z/node leaft-leave))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println \\\\\\"left-leave\: node\:\\\\\\" (z/node left-leave))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println \\\\\\"left-leave\: node\:\\\\\\" left-leave)\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" right-leave)\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" right-leave)\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println \\\\\\"left-leave\: node\:\\\\\\" (z/node left-leave))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:\\\\\\" (z/node left-leave)))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave)))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:\\\\\\" (z/node right-leave)))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" "(in-ns 'paredit.tests)" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println \\\\\\"o\: \\\\\\" o, \\\\\\"c\: \\\\\\" c)\\\\n  (println \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length)\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:\\\\\\" (-?> left-leave z/node)))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:\\\\\\" (-?> right-leave z/node)))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:\\\\\\" (-?> right-leave z/node)))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:\\\\\\" (-?> left-leave z/node)))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:\\\\\\" (-?> right-leave z/node)))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:\\\\\\" (-?> right-leave z/node)))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#((do\\\\n                   (println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length}))))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(do\\\\n                   (println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length})))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                           (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(do\\\\n                   (println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length})))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (spy (not (in-code? (loc-containing-offset rloc offset))))\\\\n              (spy (not (in-code? (loc-containing-offset rloc (+ offset length)))))\\\\n              (spy (> offset (start-offset left-leave)))\\\\n              (and (spy (not\= 0 length)) (spy (or (spy (< (+ offset length) (end-offset right-leave)))\\\\n                                           (spy (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave))))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" "(paredit.parser/start-spy)" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(do\\\\n                   (println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length})))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                     (and (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave)))\\\\n                                       (not (contains? (z/parents right-leave) (z/node (loc-parse-node left-leave))))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(do\\\\n                   (println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length})))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                     (and (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave)))\\\\n                                       (not (contains? (z/path right-leave) (z/node (loc-parse-node left-leave))))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" "(paredit.parser/stop-spy)" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  (println \\\\\\"+++++++++++++++\\\\\\")\\\\n  (println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  (println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  (println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(do\\\\n                   (println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length})))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            _ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            _ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                     (and (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave)))\\\\n                                       (not (some \#{(z/node (loc-parse-node left-leave))} (z/path right-leave)))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" ";; Loading file src/paredit/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"; todo \\\\n; done 1. emit text deltas, not plain text replacement (or IDEs will not like it)\\\\n; done 2. have a story for invalid parsetrees \: just do nothing \: currently \= paredit deactivated if error from start-of-file to area of paredit's work\\\\n; 3. use restartable version of the parser\\\\n; 4. make paredit optional in ccw\\\\n; 5. prepare a new release of ccw\\\\n; 6. write with clojure.zip functions the close-* stuff\\\\n; 7. write the string related stuff\\\\n; ... ?\\\\n; . add support for more clojure-related source code ( \#{}, \#\\\\\\"\\\\\\"... )\\\\n; ... and all the other paredit stuff ...\\\\n\\\\n(ns paredit.core\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:use clojure.set)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require clojure.contrib.pprint)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:require [clojure.zip \:as z])\\\\n  (\:use paredit.loc-utils)) ; TODO avoir un require \:as l\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n;;; adaptable paredit configuration\\\\n(def ^String *newline* \\\\\\"\\\\\\\\n\\\\\\")\\\\n;;; adaptable paredit configuration\\\\n\\\\n(def *real-spaces* \#{(str \\\\\\\\newline) (str \\\\\\\\tab) (str \\\\\\\\space)})\\\\n(def *extended-spaces* (conj *real-spaces* (str \\\\\\\\,)))\\\\n(def *open-brackets* (conj \#{\\\\\\"(\\\\\\" \\\\\\"[\\\\\\" \\\\\\"{\\\\\\"} nil)) ; we add nil to the list to also match beginning of text \\\\n(def *close-brackets* (conj \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\"} nil)) ; we add nil to the list to also match end of text\\\\n(def *form-macro-chars* \#{(str \\\\\\\\\#) (str \\\\\\\\~) \\\\\\"~@\\\\\\" (str \\\\\\\\') (str \\\\\\\\`) (str \\\\\\\\@) \\\\\\"^\\\\\\" \\\\\\"\#'\\\\\\" \\\\\\"\#_\\\\\\" \\\\\\"\#\!\\\\\\"})\\\\n(def *not-in-code* \#{\:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\" \:comment \:char \:regex})\\\\n\\\\n(defmacro with-memoized [func-names & body]\\\\n  `(binding [~@(mapcat \\\\n                 (fn [func-name] [func-name `(memoize ~func-name)]) \\\\n                 func-names)]\\\\n     ~@body))\\\\n\\\\n(defmacro with-important-memoized [& body]\\\\n  `(with-memoized \\\\n     [start-offset\\\\n      end-offset\\\\n      loc-text\\\\n      loc-col\\\\n      loc-for-offset\\\\n      leave-for-offset\\\\n      loc-containing-offset\\\\n      contains-offset?\\\\n      normalized-selection\\\\n      node-text]\\\\n     ~@body))\\\\n\\\\n(defn normalized-selection\\\\n  \\\\\\"makes a syntaxically correct selection, that is the returned nodes are siblings.\\\\n   returns a vector of 2 locs.\\\\n   If the selection is empty, the first loc will give the start (get it via a call to 'loc-start on it)\\\\n   and the second loc will be nil.\\\\n   If the selection is not empty, the second loc will give the end (get it via a call to 'loc-end on it).\\\\n   Pre-requisites\: length >\=0, offset >\=0. rloc \= root loc of the tree\\\\\\"\\\\n  [rloc offset length]\\\\n  (let [left-leave (parse-leave (leave-for-offset rloc offset))\\\\n        right-leave (parse-leave (leave-for-offset rloc (+ offset length)))\\\\n        right-leave (cond \\\\n                      (\= \:root (loc-tag right-leave)) \\\\n                        (parse-leave (leave-for-offset rloc (dec (+ offset length)))) \\\\n                      (not\= (+ offset length) (start-offset right-leave))\\\\n                        (parse-node right-leave) \\\\n                      (nil? (seq (previous-leaves right-leave)))\\\\n                        (parse-node right-leave)\\\\n                      \:else\\\\n                        (parse-node (first (previous-leaves right-leave))))]\\\\n    (if (or\\\\n          (\= [0 0] [offset length])\\\\n          (and \\\\n            (\= 0 length)\\\\n            (\= (start-offset left-leave) offset))\\\\n          (and \\\\n            (\= (start-offset (parse-node left-leave)) offset)\\\\n            (\= (end-offset (parse-node right-leave)) (+ offset length))  \\\\n            (same-parent? (parse-node left-leave) (parse-node right-leave)))) \\\\n      [left-leave (when-not (zero? length) right-leave)]\\\\n      (let [left-leave (parse-node left-leave)\\\\n            right-leave (parse-node right-leave)\\\\n            min-depth (min (loc-depth left-leave) (loc-depth right-leave))\\\\n            left-leave (up-to-depth left-leave min-depth)\\\\n            right-leave (up-to-depth right-leave min-depth)]\\\\n        (first \\\\n          (filter \\\\n            (fn [[l r]] (\= (z/up l) (z/up r))) \\\\n            (iterate \\\\n              (fn [[l r]] [(z/up l) (z/up r)])\\\\n              [left-leave right-leave])))))))\\\\n\\\\n(defn parsed-in-tags? \\\\n  [parsed tags-set]\\\\n  (tags-set (-> parsed \:parents peek \:tag)))\\\\n\\\\n(defn parse-stopped-in-code?\\\\n  ; TODO the current function is not general enough, it just works for the offset\\\\n  ; the parse stopped at  \\\\n  \\\\\\"true if character at offset offset is in a code\\\\n   position, e.g. not in a string, regexp, literal char or comment\\\\\\"\\\\n  [parsed]\\\\n  (not (parsed-in-tags? parsed *not-in-code*)))\\\\n\\\\n(defn in-code? [loc] (and loc (not (*not-in-code* (loc-tag (parse-node loc))))))\\\\n  \\\\n(defmulti paredit (fn [k & args] k))\\\\n\\\\n(defn insert-balanced\\\\n  [[o c] t chars-with-no-space-before chars-with-no-space-after]\\\\n  (let [add-pre-space? (not (contains? chars-with-no-space-before \\\\n                                       (t/previous-char-str t 1 \#_(count o))))\\\\n        add-post-space? (not (contains? chars-with-no-space-after \\\\n                                        (t/next-char-str t)))\\\\n        ins-str (str (if add-pre-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\")\\\\n                     (str o c)\\\\n                     (if add-post-space? \\\\\\" \\\\\\" \\\\\\"\\\\\\"))\\\\n        offset-shift (if add-post-space? -2 -1)]\\\\n    (-> t (t/insert ins-str) (t/shift-offset offset-shift))))\\\\n\\\\n(declare wrap-with-balanced)\\\\n\\\\n(defn open-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n  (if (zero? length) \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]\\\\n      (if (in-code? offset-loc)\\\\n        (insert-balanced [o c] t chars-with-no-space-before chars-with-no-space-after)\\\\n        (-> t (t/insert (str o)))))\\\\n    (wrap-with-balanced parsed [o c] t)))\\\\n  \\\\n(defn close-balanced\\\\n  [parsed [o c] {\:keys [^String text offset length] \:as t} \\\\n   chars-with-no-space-before chars-with-no-space-after]\\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))]       \\\\n      (if (in-code? offset-loc)\\\\n        (let [up-locs (take-while identity (iterate z/up offset-loc))\\\\n              match (some \#(when (\= c (peek (\:content (z/node %)))) %) up-locs)]\\\\n          (if match\\\\n            (let [last-loc (-> match z/down z/rightmost z/left)\\\\n                  nb-delete (if (\= \:whitespace (loc-tag last-loc)) \\\\n                              (loc-count last-loc)\\\\n                              0)\\\\n                  t (if (> nb-delete 0) \\\\n                      (t/delete t (start-offset last-loc) nb-delete)\\\\n                      t)] ; z/left because there is the closing node\\\\n              (-> t (t/set-offset (- (end-offset match) nb-delete))))\\\\n            (-> t (t/insert (str c)))))\\\\n        (-> t (t/insert (str c))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-open-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (open-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t \\\\n      (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n      (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    (union (into *real-spaces* *open-brackets*) *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-open-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (open-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    (union (conj (into *real-spaces* *open-brackets*) \\\\\\"\#\\\\\\") *form-macro-chars*)\\\\n    (into *extended-spaces* *close-brackets*))))\\\\n    \\\\n(defmethod paredit \\\\n  \:paredit-close-round\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-square\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-close-curly\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized (close-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t\\\\n    nil nil)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-doublequote\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))] \\\\n      (cond\\\\n        ;(parse-stopped-in-code? parsed)\\\\n        (in-code? offset-loc)\\\\n          (insert-balanced [\\\\\\\\\\\\\\" \\\\\\\\\\\\\\"] t ; todo voir si on utilise open balanced ? (mais quid echappement?)\\\\n            (conj (into *real-spaces* *open-brackets*) \\\\\\\\\#)\\\\n            (into *extended-spaces* *close-brackets*))\\\\n        (not\= \:string (loc-tag offset-loc))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (and (\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t)) (not\= \\\\\\"\\\\\\\\\\\\\\\\\\\\\\" (t/previous-char-str t 2)))\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\")))\\\\n        (\= \\\\\\"\\\\\\\\\\\\\\"\\\\\\" (t/next-char-str t))\\\\n          (t/shift-offset t 1)\\\\n        \:else\\\\n          (-> t (t/insert (str \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\")))))))\\\\n\\\\n(defmethod paredit \\\\n  \:paredit-forward-delete\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               open-punct-length (.length (first (\:content (z/node offset-loc))))]\\\\n           (cond \\\\n             (and in-handled-form (\= offset (start-offset offset-loc)))\\\\n               (t/shift-offset t open-punct-length)\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (-> t ; delete the form \\\\n                   (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (t/shift-offset (- open-punct-length))))\\\\n             \:else\\\\n               (t/delete t offset 1)))\\\\n         (t/delete t offset 1)))))\\\\n\\\\n(defmethod paredit \\\\n   \:paredit-backward-delete\\\\n   [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n   (if (zero? (count text))\\\\n     t\\\\n     (with-important-memoized \\\\n       (if parsed\\\\n         (let [offset (dec offset)\\\\n               offset-loc (-> parsed parsed-root-loc (loc-for-offset offset))\\\\n               ;_ (println \\\\\\"offset-loc\:\\\\\\" (z/node offset-loc))\\\\n               handled-forms *brackets-tags*\\\\n               in-handled-form (handled-forms (loc-tag offset-loc))\\\\n               ;_ (println \\\\\\"in-handled-form\:\\\\\\" in-handled-form)\\\\n               ]\\\\n           (cond \\\\n             (and in-handled-form (<\= (start-offset offset-loc) offset (+ (start-offset offset-loc) (dec (-> offset-loc z/down loc-count)))))\\\\n               (if (> (-> offset-loc z/node \:content count) 2)\\\\n                 t     ; don't move\\\\n                 (do ;(println \\\\\\"delete the form\:\\\\\\" (start-offset offset-loc) (loc-count offset-loc))\\\\n                   (-> t ; delete the form \\\\n                     (t/delete (start-offset offset-loc) (loc-count offset-loc))\\\\n                     (t/shift-offset (- (-> offset-loc z/down loc-count))))))\\\\n             (and in-handled-form (\= offset (dec (end-offset offset-loc))))\\\\n               (do\\\\n                 ;(println \\\\\\"final t\:\\\\\\") \\\\n                 ;(println (start-offset offset-loc) (loc-count offset-loc))\\\\n                 (t/shift-offset t -1))\\\\n             \:else\\\\n               (-> t (t/delete offset 1) (t/shift-offset -1))))\\\\n         (-> t (t/delete offset 1) (t/shift-offset -1))))))\\\\n\\\\n(defn indent-column \\\\n  \\\\\\"pre-condition\: line-offset is already the starting offset of a line\\\\\\"\\\\n  [root-loc line-offset]\\\\n  (let [loc (loc-for-offset root-loc (dec line-offset))]\\\\n    (if-let [loc (z/left loc)]\\\\n      (loop [loc loc seen-loc nil indent 0]\\\\n        (cond\\\\n          (nil? loc)\\\\n            indent\\\\n          (punct-loc? loc)\\\\n            ; we reached the start of the parent form, indent depending on the form's type\\\\n            (+ (loc-col loc)\\\\n              (loc-count loc)    \\\\n              (if (\#{\\\\\\"(\\\\\\" \\\\\\"\#(\\\\\\"} (loc-text loc)) 1 0))\\\\n          (\= \:whitespace (loc-tag loc))\\\\n            ; we see a space\\\\n            (if (.contains ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")\\\\n              (if seen-loc\\\\n                (+ indent (dec (-> ^String (loc-text loc) (.substring (.lastIndexOf ^String (loc-text loc) \\\\\\"\\\\\\\\n\\\\\\")) .length)))\\\\n                (recur (z/left loc) nil 0))\\\\n              (recur (z/left loc) nil (+ indent (-> ^String (loc-text loc) .length))))\\\\n          \:else\\\\n            (recur (z/left loc) loc 0)))\\\\n      ; we are at the start of the file \!\\\\n      0)))\\\\n\\\\n(defn text-selection\\\\n  \\\\\\"returns a vector [offset length] from a normalized-selection\\\\\\"\\\\n  [nsel]\\\\n  (let [[l r] nsel\\\\n        offset (start-offset l)\\\\n        length (if (nil? r) 0 (- (end-offset r) offset))]\\\\n    [offset length]))\\\\n\\\\n \\\\n\\\\n(defn sel-match-normalized? \\\\n  \\\\\\"Does the selection denoted by offset and length match l (left) and r (right) locs ?\\\\\\"\\\\n  [offset length [l r]]\\\\n  (if (zero? length)\\\\n    (and (nil? r) (\= offset (start-offset l)))\\\\n    (and (\= offset (start-offset l)) (\= (+ offset length) (end-offset r)))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-left\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)\\\\n          l (if (sel-match-normalized? offset length [l r])\\\\n              (if-let [nl (z/left l)] nl (if (punct-loc? l) (z/left (z/up l)) (z/up l)))\\\\n              (do\\\\n                (spy [(z/node l) (and r (z/node r))])\\\\n                (spy \\\\\\"not normalized\!\\\\\\" l)))\\\\n          r (if (nil? r) l r)\\\\n          [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n      (spy (-> t (assoc-in [\:offset] (start-offset l))\\\\n             (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))))\\\\n      t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-up\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [l (if-let [nl (z/up (if (\= offset (start-offset (parse-node l)))\\\\n                                    (parse-node l) \\\\n                                    (parse-leave l)))]\\\\n                  nl \\\\n                  l)]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (- (end-offset l) (start-offset l)))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-expand-right\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (sel-match-normalized? offset length [l r])\\\\n        (-> t (assoc-in [\:offset] (start-offset l))\\\\n          (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l)))))\\\\n        (let [r (if (nil? r) \\\\n                  l \\\\n                  (if-let [nr (z/right r)] \\\\n                    nr\\\\n                    (z/up r)))\\\\n              [l r] (normalized-selection rloc (spy (start-offset l)) (spy (- (end-offset r) (start-offset l))))]\\\\n          (-> t (assoc-in [\:offset] (start-offset l))\\\\n            (assoc-in [\:length] (if (nil? r) 0 (- (end-offset r) (start-offset l))))))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-raise-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n    (let [[l r] (normalized-selection rloc offset length)]\\\\n      (if-not (and\\\\n                (sel-match-normalized? offset length [l r]) \\\\n                (\= offset (start-offset (parse-node l))))\\\\n        t\\\\n        (let  \\\\n          [to-raise-offset (start-offset l)\\\\n           to-raise-length (- (if r (end-offset r) (end-offset (parse-node l))) (start-offset l))\\\\n           to-raise-text (.substring text to-raise-offset (+ to-raise-offset to-raise-length))\\\\n           l (if-let [nl (z/up (parse-node l))] nl l)\\\\n           replace-offset (start-offset l)\\\\n           replace-length (- (end-offset l) replace-offset)]\\\\n          (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length to-raise-text))\\\\n            (assoc-in [\:offset] replace-offset)\\\\n            (assoc-in [\:length] 0)\\\\n            (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text to-raise-text})))))\\\\n    t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-split-sexp\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized (if (not\= 0 length)\\\\n    t\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [[l r] (normalized-selection rloc offset length)\\\\n            parent (cond\\\\n                     (\= \:string (loc-tag l)) l ; stay at the same level, and let the code take the correct open/close puncts, e.g. \\\\\\\\\\\\\\" \\\\\\\\\\\\\\"\\\\n                     \:else (if-let [nl (z/up (if (start-punct? l) (parse-node l) (parse-leave l)))] nl (parse-leave l)))\\\\n            open-punct (*tag-opening-brackets* (loc-tag parent))\\\\n            close-punct ^String (*tag-closing-brackets* (loc-tag parent))]\\\\n        (if-not close-punct\\\\n          t\\\\n          (let [replace-text (str close-punct \\\\\\" \\\\\\" open-punct)\\\\n                [replace-offset \\\\n                 replace-length] (if (and\\\\n                                       (not\= \:whitespace (loc-tag l))\\\\n                                       (or\\\\n                                         (\= \:string (loc-tag l))\\\\n                                         (not (and\\\\n                                                (sel-match-normalized? offset length [l r]) \\\\n                                                (\= offset (start-offset (parse-node l)))))))\\\\n                                   [offset 0]\\\\n                                   (let [start (or (some \#(when-not (\= \:whitespace (loc-tag %)) (end-offset %)) (previous-leaves l)) offset)\\\\n                                         end (or (some \#(when-not (\= \:whitespace (loc-tag %)) (start-offset %)) (next-leaves l)) 0)]\\\\n                                     [start (- end start)]))\\\\n                                 new-offset (+ replace-offset (.length close-punct))]\\\\n            (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n              (assoc-in [\:offset] new-offset)\\\\n              (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))\\\\n      t))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-join-sexps\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if (not\= 0 length)\\\\n      t\\\\n      (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n          (let [[l _] (normalized-selection rloc offset length)\\\\n                lf (first (remove \#(\= \:whitespace (loc-tag %)) (previous-leaves l)))\\\\n                rf (first (remove \#(\= \:whitespace (loc-tag %)) (cons l (next-leaves l))))]\\\\n            (if (or (nil? lf) (nil? rf) (start-punct? lf) (end-punct? rf))\\\\n              t\\\\n              (let [ln (parse-node lf)\\\\n                    rn (parse-node rf)] \\\\n                (if-not (and\\\\n                          (\= (loc-tag ln) (loc-tag rn)))\\\\n                  t\\\\n                  (let [replace-offset (- (end-offset ln) (if-let [punct ^String (*tag-closing-brackets* (loc-tag ln))] (.length punct) 0))\\\\n                        replace-length (- (+ (start-offset rn) (if-let [punct ^String (*tag-closing-brackets* (loc-tag rn))] (.length punct) 0)) replace-offset)\\\\n                        replace-text   (if ((conj *atom* \:string) (loc-tag ln)) \\\\\\"\\\\\\" \\\\\\" \\\\\\")\\\\n                        new-offset (if (\= offset (start-offset rn)) (+ replace-offset (.length replace-text)) replace-offset)]\\\\n                    (-> t (assoc-in [\:text] (t/str-replace text replace-offset replace-length replace-text))\\\\n                      (assoc-in [\:offset] new-offset)\\\\n                      (update-in [\:modifs] conj {\:offset replace-offset \:length replace-length \:text replace-text})))))))\\\\n          t))))\\\\n\\\\n(defn wrap-with-balanced\\\\n  [parsed [^String o c] {\:keys [^String text offset length] \:as t}]\\\\n  ;(println \\\\\\"+++++++++++++++\\\\\\")\\\\n  ;(println \\\\\\"parsed\: \\\\\\" parsed)\\\\n  ;(println (str \\\\\\"o\: '\\\\\\" o \\\\\\"', c\: '\\\\\\" c \\\\\\"'\\\\\\"))\\\\n  ;(println (str \\\\\\"test\:'\\\\\\" text \\\\\\"', offset\:\\\\\\" offset \\\\\\", length\:\\\\\\" length))\\\\n  (let [bypass \#(do\\\\n                   ;(println \\\\\\"bypassing\\\\\\")\\\\n                   (-> t \\\\n                  (update-in [\:text] t/str-replace offset length o)\\\\n                  (update-in [\:offset] + (.length o))\\\\n                  (assoc-in [\:length] 0)\\\\n                  (update-in [\:modifs] conj {\:text o \:offset offset \:length length})))]\\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [left-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (next-leaves (leave-for-offset rloc offset)))\\\\n            ;_ (println (str \\\\\\"left-leave\: node\:'\\\\\\" (-?> left-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (some (fn [l] (when (not\= \:whitespace (loc-tag l)) l)) (previous-leaves (leave-for-offset rloc (+ offset length))))\\\\n            ;_ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            right-leave (if (or (nil? right-leave) (<\= (start-offset right-leave) (start-offset left-leave))) left-leave right-leave)\\\\n            ;_ (println (str \\\\\\"right-leave\: node\:'\\\\\\" (-?> right-leave z/node) \\\\\\"'\\\\\\"))\\\\n            ]\\\\n        (if (or\\\\n              (not (in-code? (loc-containing-offset rloc offset)))\\\\n              (not (in-code? (loc-containing-offset rloc (+ offset length))))\\\\n              (> offset (start-offset left-leave))\\\\n              (and (not\= 0 length) (or (< (+ offset length) (end-offset right-leave))\\\\n                                     (and (not\= (z/up (loc-parse-node left-leave)) (z/up (loc-parse-node right-leave)))\\\\n                                       (not (some \#{(z/node (loc-parse-node left-leave))} (z/path right-leave)))))))\\\\n          (bypass)\\\\n          (let [text-to-wrap (.substring text (start-offset (z/up left-leave)) (end-offset (z/up right-leave))) \\\\n                new-text (str o text-to-wrap c)\\\\n                t (update-in t [\:text] t/str-replace (start-offset left-leave) (.length text-to-wrap) new-text)\\\\n                t (assoc-in t [\:offset] (inc (start-offset left-leave)))]\\\\n            (update-in t [\:modifs] conj {\:text new-text \:offset (start-offset left-leave) \:length (.length text-to-wrap)})))) \\\\n      (bypass))))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-square\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"[\\\\\\" \\\\\\"]\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-curly\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"{\\\\\\" \\\\\\"}\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-wrap-round\\\\n  [cmd parsed t]\\\\n  (with-important-memoized (wrap-with-balanced parsed [\\\\\\"(\\\\\\" \\\\\\")\\\\\\"] t)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-newline\\\\n  [cmd parsed {\:keys [text offset length] \:as t}]\\\\n  ; no call to with-important-memoized because we almost immediately delegate to \:paredit-indent-line\\\\n  (let [r (paredit \:paredit-indent-line \\\\n              (parse (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\")) ; TODO suppress (or optimize) this call, if possible\\\\n              {\:text (t/str-insert text offset \\\\\\"\\\\\\\\n\\\\\\") \\\\n               \:offset (inc offset) \\\\n               \:length length \\\\n               \:modifs [{\:text *newline* \:offset offset \:length 0}]})]\\\\n      (if (-?> r \:modifs count (\= 2))\\\\n        (let [m1 (get-in r [\:modifs 0])\\\\n              m2 (get-in r [\:modifs 1])\\\\n              r  (assoc-in r [\:modifs] [{\:text (str (\:text m1) (\:text m2)) \:offset offset \:length (+ (\:length m1) (\:length m2))}])\\\\n              r  (assoc-in r [\:offset] (+ (.length ^String (get-in r [\:modifs 0 \:text])) offset))]\\\\n          r)\\\\n        r)))\\\\n\\\\n(defmethod paredit\\\\n  \:paredit-indent-line\\\\n  [cmd parsed {\:keys [^String text offset length] \:as t}]\\\\n  (with-important-memoized \\\\n    (if-let [rloc (-?> parsed (parsed-root-loc true))]\\\\n      (let [line-start (spy (t/line-start (spy text) (spy offset)))\\\\n            line-stop (t/line-stop text offset)\\\\n            loc (loc-for-offset rloc line-start)]\\\\n        (if (and (\= \:string (loc-tag loc)) (< (start-offset loc) line-start))\\\\n          t\\\\n          (let [indent (indent-column rloc line-start)\\\\n                cur-indent-col (- \\\\n                                 (loop [o line-start]\\\\n                                   (if (>\= o (.length text)) \\\\n                                     o\\\\n                                     (let [c (.charAt text o)]\\\\n                                       (cond\\\\n                                         (\#{\\\\\\\\return \\\\\\\\newline} c) o ; test CR/LF before .isWhitespace \!\\\\n                                         (Character/isWhitespace c) (recur (inc o))\\\\n                                         (\= \\\\\\\\, c) (recur (inc o))\\\\n                                         \:else o))))\\\\n                                 line-start)\\\\n                to-add (- indent cur-indent-col)]\\\\n            (cond\\\\n            (zero? to-add) t\\\\n            \:else (let [t (update-in t [\:modifs] conj {\:text (str2/repeat \\\\\\" \\\\\\" indent) \:offset line-start \:length cur-indent-col})\\\\n                        t (update-in t [\:text] t/str-replace line-start cur-indent-col (str2/repeat \\\\\\" \\\\\\" indent))]\\\\n                    (cond \\\\n                      (>\= offset (+ line-start cur-indent-col)) \\\\n                        (update-in t [\:offset] + to-add)\\\\n                      (<\= offset (+ line-start indent))\\\\n                        t\\\\n                      \:else\\\\n                        (update-in t [\:offset] + (max to-add (- line-start \\\\n                                                               offset)))))))))\\\\n      t)))\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/core.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(binding [clojure.test/*test-out* *out*] (pts))" "(require 'paredit.core) ; automatically requires paredit.parser as well" "(require 'paredit.core)" "(def parse-tree (paredit.parser/parse \\"(foo bar)\\"))" "(paredit.core/paredit \:paredit-raise-sexp parse-tree {\:text \\"(foo bar)\\" \:offset 5 \:length 0}) ; Let's raise \\"bar\\" over \\"(foo bar)\\"" "(paredit.core/paredit \:paredit-split-sexp parse-tree {\:text \\"(foo bar)\\" \:offset 5 \:length 0}) ; Let's raise \\"bar\\" over \\"(foo bar)\\"" "(require 'clojure.set)" "(doc clojure.set/join)" "(doc clojure.set)" "(clojure.set/index \#{{\:a 1} {\:b 2} {\:a 3}} [\:a \:b \:c])" "(pprint (clojure.set/index \#{{\:a 1} {\:b 2} {\:a 3}} [\:a \:b \:c]))" "(pprint (clojure.set/index \#{{\:a 1 \:foo \:bar} {\:b 2} {\:a 3} {\:a 1 \:foo \:baz}} [\:a \:b \:c]))" "(pprint (clojure.set/index \#{{\:a 1 \:foo \:bar} {\:b 2} {\:a 3} {\:a 1 \:foo \:baz}} [\:a]))" "(clojure.set/union \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} \#{})" "(clojure.set/union \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} \#{{\:i 1 \:a \:c} {\:i 3 \:a \:d}})" "(clojure.set/union \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} \#{{\:i 1 \:a \:c} {\:i 3 \:a \:d}} [\:i])" "(clojure.set/union \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} \#{{\:i 1 \:a \:c} {\:i 3 \:a \:d}} \:i)" "(clojure.set/union \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} \#{{\:i 1 \:a \:c} {\:i 3 \:a \:d}} {\:i 1})" "(clojure.set/project \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} [\:i])" "(clojure.set/rename \#{{\:i 1 \:a \:b} {\:i 1 \:a \:c} {\:i 2 \:a \:b}} {\:i \:j})" "(doc clojure.set/join)" "(defmacro with-open2 [binding-exprs & body]\\n  (if (> (count binding-exprs) 2)\\n    `(with-open2 ~(vec (take 2 binding-exprs))\\n       (with-open2 ~(vec (drop 2 binding-exprs))\\n         ~@body))\\n    (let [[sym expr] binding-exprs]\\n      `(let [~sym ~expr]\\n         (try\\n           (let [res\# (do ~@body)]\\n             ; body didn't throw\\n             (.close ~sym)\\n             res\#)\\n           (catch Throwable t\#\\n             (try (.close ~sym) (catch Throwable _)) ; eat close exception\\n             (throw t\#))))))) ; and rethrow body exception  \\n" "(defmacro with-open\\n  \\"bindings \=> [name init ...]\\n\\n  Evaluates body in a try expression with names bound to the values\\n  of the inits, and a finally clause that calls (.close name) on each\\n  name in reverse order.\\"\\n  {\:added \\"1.0\\"}\\n  [bindings & body]\\n  (assert-args with-open\\n     (vector? bindings) \\"a vector for its binding\\"\\n     (even? (count bindings)) \\"an even number of forms in binding vector\\")\\n  (cond\\n    (\= (count bindings) 0) `(do ~@body)\\n    (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)\\n                              (try\\n                                (let [res\# (with-open ~(subvec bindings 2) ~@body)]\\n                                  ;body didn't throw\\n                                  (. ~(bindings 0) close)\\n                                  res\#)\\n                                (catch Throwable t\#\\n\\t                                (try (. ~(bindings 0) close) (catch Throwable _)) ; eat close exception\\n                                  (throw t\#)))) ; and rethrow body exception\\n    \:else (throw (IllegalArgumentException.\\n                   \\"with-open only allows Symbols in bindings\\"))))" "(in-ns 'clojure.core) (defmacro with-open\\n  \\"bindings \=> [name init ...]\\n\\n  Evaluates body in a try expression with names bound to the values\\n  of the inits, and a finally clause that calls (.close name) on each\\n  name in reverse order.\\"\\n  {\:added \\"1.0\\"}\\n  [bindings & body]\\n  (assert-args with-open\\n     (vector? bindings) \\"a vector for its binding\\"\\n     (even? (count bindings)) \\"an even number of forms in binding vector\\")\\n  (cond\\n    (\= (count bindings) 0) `(do ~@body)\\n    (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)\\n                              (try\\n                                (let [res\# (with-open ~(subvec bindings 2) ~@body)]\\n                                  ;body didn't throw\\n                                  (. ~(bindings 0) close)\\n                                  res\#)\\n                                (catch Throwable t\#\\n\\t                                (try (. ~(bindings 0) close) (catch Throwable _)) ; eat close exception\\n                                  (throw t\#)))) ; and rethrow body exception\\n    \:else (throw (IllegalArgumentException.\\n                   \\"with-open only allows Symbols in bindings\\"))))" "(require 'paredit.core)" "(in-ns 'paredit.parser)" "(sexp \\"foo\\")" "(sexp \\"3/4\\")" "(sexp \\"2\\")" "(-> (sexp \\"2\\") clojure.zip/xml-zip) " "(-> (sexp \\"2\\") clojure.zip/xml-zip paredit.loc-utils/next-leaves ) " "(->> (sexp \\"2\\") clojure.zip/xml-zip paredit.loc-utils/next-leaves (map clojure.zip/node)) " "(->> (sexp \\"2\\") clojure.zip/xml-zip paredit.loc-utils/next-leaves (map clojure.zip/node) (apply str)) " "(->> (sexp \\"(2\\") clojure.zip/xml-zip paredit.loc-utils/next-leaves (map clojure.zip/node) (apply str)) " "(->> (sexp \\"(2)\\") clojure.zip/xml-zip paredit.loc-utils/next-leaves (map clojure.zip/node) (apply str)) " "(->> (sexp \\"(defn 2)\\") clojure.zip/xml-zip paredit.loc-utils/next-leaves (map clojure.zip/node) (apply str)) " "(defn parsetree-to-string [parsetree]\\n  (->> parsetree \\n    clojure.zip/xml-zip \\n    paredit.loc-utils/next-leaves \\n    (map clojure.zip/node) \\n    (apply str)))" "(parsetree-to-string (sexp \\"qldsfjqofj iojezofij\\"))" "(slurp \\"/home/lpetit/projects/paredit.clj/pom.xml\\")" "(sexp (slurp \\"/home/lpetit/projects/paredit.clj/pom.xml\\"))" "(parsetree-to-string (sexp (slurp \\"/home/lpetit/projects/paredit.clj/pom.xml\\")))" "(\= (slurp \\"/home/lpetit/projects/paredit.clj/pom.xml\\") (parsetree-to-string (sexp (slurp \\"/home/lpetit/projects/paredit.clj/pom.xml\\"))))" "(let [s \\"package foo;\\\\npublic class MyClass { }\\"] (\= s (parsetree-to-string (sexp s))))" "(source clojure.core\\n  )" "(doc slurp)" "(find-doc \\"classpath\\")" "(source-fn 'clojure.core/map)" "(clojure.repl/source-fn 'clojure.core/map)" "(clojure.repl/source-fn 'clojure.repl/source-fn)" "(require '[clojure.java.io \:as jio])" "(jio/reader (.getResourceAsStream (RT/baseLoader) \\"/clojure/core.clj\\"))" "(jio/reader (.getResourceAsStream (clojure.lang.RT/baseLoader) \\"/clojure/core.clj\\"))" "(.getResourceAsStream (clojure.lang.RT/baseLoader) \\"/clojure/core.clj\\")" "(.getResourceAsStream (clojure.lang.RT/baseLoader) \\"/clojure/core/core.clj\\")" "(.getResourceAsStream (clojure.lang.RT/baseLoader) \\"clojure/core.clj\\")" "(jio/reader (.getResourceAsStream (clojure.lang.RT/baseLoader) \\"clojure/core.clj\\"))" "(source slurp)" "(slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) \\"clojure/core.clj\\"))" "(require 'paredit.tests)" "(in-ns 'paredit.tests)" "(parsetree-tests)" ";; Loading file test/paredit/tests.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.tests\\\\n  (\:use paredit.core-commands)\\\\n  (\:use paredit.core)\\\\n  (\:use [paredit.parser \:exclude [pts]])\\\\n  (\:require [paredit.text-utils \:as t])\\\\n  (\:use clojure.contrib.def)\\\\n  (\:use clojure.test)\\\\n  (\:require [clojure.contrib.str-utils2 \:as str2])\\\\n  (\:use clojure.contrib.core)\\\\n  (\:require [clojure.zip \:as zip])\\\\n  (\:use paredit.loc-utils))\\\\n\\\\n(defn text-spec-to-text \\\\n  \\\\\\"Converts a text spec to text map\\\\\\" \\\\n  [^String text-spec]\\\\n  (let [offset (.indexOf text-spec \\\\\\"|\\\\\\")\\\\n        second-pipe (dec (.indexOf text-spec \\\\\\"|\\\\\\" (inc offset)))]  \\\\n    {\:text (str2/replace text-spec \\\\\\"|\\\\\\" \\\\\\"\\\\\\")\\\\n     \:offset offset\\\\n     \:length (if (> second-pipe 0) (- second-pipe offset) 0)}))\\\\n\\\\n(defn text-to-text-spec\\\\n  \\\\\\"Converts a text map to text spec\\\\\\"\\\\n  [text]\\\\n  (let [spec (t/str-insert (\:text text) (\:offset text) \\\\\\"|\\\\\\")\\\\n        spec (if (zero? (\:length text)) spec (t/str-insert spec (+ 1 (\:offset text) (\:length text)) \\\\\\"|\\\\\\"))]\\\\n    spec))\\\\n\\\\n(deftest normalized-selection-tests\\\\n  (are [text offset length expected-offset expected-length]\\\\n    (\= [expected-offset expected-length] (-?> (parse text) (parsed-root-loc true) (normalized-selection offset length) (text-selection)))\\\\n    \\\\\\"foo bar baz\\\\\\" 4 0 4 0\\\\n    \\\\\\"foo bar baz\\\\\\" 4 3 4 3\\\\n    \\\\\\"foo bar baz\\\\\\" 4 6 4 7\\\\n    \\\\\\"foo bar baz\\\\\\" 4 7 4 7 \\\\n    \\\\\\"foo (bar baz)\\\\\\" 5 3 5 3 \\\\n    \\\\\\"foo (bar baz)\\\\\\" 5 4 5 4 \\\\n    \\\\\\"foo (bar baz)\\\\\\" 5 5 5 7 \\\\n    \\\\\\"foo (bar baz)\\\\\\" 5 7 5 7 \\\\n    \\\\\\"foo (bar baz)\\\\\\" 4 0 4 0\\\\n    \\\\\\"foo bar (baz) foo\\\\\\" 4 9 4 9\\\\n    \\\\\\"foo bar (baz) foo\\\\\\" 4 10 4 10\\\\n    \\\\\\"foo bar (baz) foo\\\\\\" 4 11 4 13 ;\\\\n    \\\\\\"foo (bar baz) foo\\\\\\" 4 2 4 9\\\\n    \\\\\\"foo bar\\\\\\" 2 5 0 7\\\\n    \\\\\\"foo (bar baz)\\\\\\" 4 9 4 9\\\\n    \\\\\\"foo (bar baz)\\\\\\" 4 4 4 9\\\\n    \\\\\\"foo (bar baz)\\\\\\" 9 4 4 9 \\\\n    \\\\\\"foo (bar baz)\\\\\\" 0 0 0 0\\\\n    \\\\\\"(foo bar)\\\\\\" 8 0 8 0\\\\n    \\\\\\"foo (bar baz)\\\\\\" 12 1 4 9 \\\\n    ))\\\\n\\\\n\\\\n(defn test-command [title-prefix command]\\\\n  (testing (str title-prefix \\\\\\" \\\\\\" (second command) \\\\\\" (\\\\\\\\\\\\\\"\\\\\\" (first command) \\\\\\"\\\\\\\\\\\\\\")\\\\\\")\\\\n    (doseq [[input expected] (get command 2)]\\\\n      (spy \\\\\\"++++++++++++++++++++\\\\\\")\\\\n      (spy (text-spec-to-text input))\\\\n      (let [{text \:text \:as t} (text-spec-to-text input)]\\\\n        (is (\= expected (text-to-text-spec (paredit (second command) (parse text) t))))))))\\\\n\\\\n(deftest paredit-tests\\\\n  (doseq [group *paredit-commands*]\\\\n    (testing (str (first group) \\\\\\"\:\\\\\\")\\\\n      (doseq [command (rest group)]\\\\n        (test-command \\\\\\"public documentation of paredit command\\\\\\" command)\\\\n        (test-command \\\\\\"additional non regression tests of paredit command \\\\\\" (assoc command 2 (get command 3)))))))\\\\n\\\\n(deftest spec-text-tests\\\\n  (are [spec text] (and \\\\n                     (\= text (text-spec-to-text spec))\\\\n                     (\= spec (text-to-text-spec text)))\\\\n    \\\\\\"foo |bar\\\\\\" {\:text \\\\\\"foo bar\\\\\\" \:offset 4 \:length 0}\\\\n    \\\\\\"|\\\\\\" {\:text \\\\\\"\\\\\\" \:offset 0 \:length 0}\\\\n    \\\\\\"|foo\\\\\\" {\:text \\\\\\"foo\\\\\\" \:offset 0 \:length 0}\\\\n    \\\\\\"foo|\\\\\\" {\:text \\\\\\"foo\\\\\\" \:offset 3 \:length 0}\\\\n    \\\\\\"foo |bar| foo\\\\\\" {\:text \\\\\\"foo bar foo\\\\\\" \:offset 4 \:length 3}))\\\\n\\\\n(deftest loc-for-offset-tests\\\\n  (are [text offset expected-tag] (\= expected-tag (-?> (parse text) (parsed-root-loc true) (loc-for-offset offset) (zip/node) \:tag))\\\\n    \\\\\\"foo (bar baz) baz\\\\\\" 12 \:list ;nil\\\\n    \\\\\\"foo (bar baz) baz\\\\\\" 4 \:list ;nil\\\\n    \\\\\\"foo (bar baz) baz\\\\\\" 5 \:atom ;nil\\\\n    \\\\\\"hello\\\\\\" 0 \:atom\\\\n    \\\\\\"hello\\\\\\" 1 \:atom\\\\n    \\\\\\"hello\\\\\\" 5 nil ;\:root\\\\n    \\\\\\"a b\\\\\\" 0 \:atom\\\\n    \\\\\\"a b\\\\\\" 1 \:whitespace\\\\n    \\\\\\"a b\\\\\\" 2 \:atom\\\\n    \\\\\\"foo \\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\" foo\\\\\\" 3 \:whitespace\\\\n    \\\\\\"foo \\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\" foo\\\\\\" 4 \:string))\\\\n\\\\n(deftest leave-for-offset-tests\\\\n  (are [text offset expected-tag ?expected-node]\\\\n    (let [l (-?> (parse text) (parsed-root-loc true) (leave-for-offset offset))] \\\\n      (and\\\\n        (\= expected-tag (loc-tag l))\\\\n        (or (nil? ?expected-node) (\= ?expected-node (zip/node l)))))\\\\n    \\\\\\"foo (bar baz) baz\\\\\\" 12 \:list \\\\\\")\\\\\\"\\\\n    \\\\\\"hello\\\\\\" 0 \:atom nil\\\\n    \\\\\\"hello\\\\\\" 1 \:atom nil\\\\n    \\\\\\"hello\\\\\\" 5 \:root nil\\\\n    \\\\\\"a b\\\\\\" 0 \:atom nil\\\\n    \\\\\\"a b\\\\\\" 1 \:whitespace nil\\\\n    \\\\\\"a b\\\\\\" 2 \:atom nil\\\\n    \\\\\\"foo \\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\" foo\\\\\\" 3 \:whitespace nil\\\\n    \\\\\\"foo \\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\" foo\\\\\\" 4 \:string nil\\\\n    ))\\\\n\\\\n(deftest parser-tests\\\\n  (is (not\= nil (sexp \\\\\\"\:\\\\\\"))))\\\\n\\\\n(deftest loc-containing-offset-tests\\\\n  (are [text offset expected-tag] (\= expected-tag (-?> (parse text) (parsed-root-loc true) (loc-containing-offset offset) (zip/node) \:tag))\\\\n    \\\\\\"hello\\\\\\" 1 \:atom\\\\n    \\\\\\"foo bar\\\\\\" 3 \:root\\\\n    \\\\\\"foo bar\\\\\\" 4 \:root\\\\n    \\\\\\"hello\\\\\\" 5 \:root\\\\n    \\\\\\"a b\\\\\\" 0 \:root\\\\n    \\\\\\"a b\\\\\\" 1 \:root\\\\n    \\\\\\"a b\\\\\\" 2 \:root\\\\n    \\\\\\"foo \\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\" foo\\\\\\" 3 \:root\\\\n    \\\\\\"foo \\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\" foo\\\\\\" 4 \:root\\\\n    ))\\\\n\\\\n(deftest parsetree-tests\\\\n  (doseq [r [\\\\\\"clojure/core.clj\\\\\\"]]\\\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\\\n      (parsetree-to-string (sexp s)))))\\\\n\\\\n(defn pts []\\\\n  \#_(normalized-selection-tests)\\\\n  \#_(t/line-stop-tests)\\\\n  \#_(spec-text-tests)\\\\n  (paredit-tests)\\\\n  (parser-tests)\\\\n  (parsetree-tests)\\\\n  ;;;;;;;\#_(loc-for-offset-tests)\\\\n  \#_(leave-for-offset-tests)\\\\n  \#_(loc-containing-offset-tests))\\\\n\\\\n(defvar *text* (atom {\:text \\\\\\"\\\\\\" \:offset 0 \:length 0})\\\\n  \\\\\\"defines a text, with \:offset being the cursor position,\\\\n   and \:length being a possible selection (may be negative)\\\\\\")\\") \\"/home/lpetit/projects/paredit.clj/test/paredit/tests.clj\\" \\"/home/lpetit/projects/paredit.clj/test\\")" "j" "(deftest parsetree-tests\\n  (doseq [r [\\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (parsetree-to-string (sexp s)))))" "(parsetree-tests)" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [r [\\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (throw (RuntimeException.))\\n      (parsetree-to-string (sexp s)))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [r [\\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (parsetree-to-string (sexp s)))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [r [\\"paredit/compile.clj\\" \\"paredit/core_commands.clj\\" \\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (parsetree-to-string (sexp s)))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [r [\\"paredit/compile.clj\\" \\"paredit/core_commands.clj\\" \\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s))))))\\n  (doseq [s [\\"\\"]]\\n    (is (\= s (parsetree-to-string (sexp s))))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"\u00E9\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(pts)" "(require 'paredit.tests)" "(require 'paredit.parser)" "(require 'paredit.loc-utils)" "(require 'paredit.parser)" "(require 'paredit.tests\\n  )" "(require 'paredit.core)" "(require 'paredit.tests)" "(in-ns 'paredit.tests)" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(require 'paredit.tests)" "(in-ns 'paredit.tests)" "(binding [clojure.test/*test-out* *out*] (parsetree-tests))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(use 'net.cgrand.regex)" "(def datestamp-re\\n  (let [d {\\\\0 \\\\9}]\\n    (regex [d d d d \:as \:year] \\\\- [d d \:as \:month] \\\\- [d d \:as \:day])))" "(exec datestamp-re \\"joo\\")" "(exec datestamp-re \\"2007-10-23\\")" "(def datestamp-re\\n  (let [d {\\\\0 \\\\9}]\\n    (regex [d d d d] \\\\- [d d] \\\\- [d d])))" "(exec datestamp-re \\"2007-10-23\\")" "(require 'paredit.parser)" "(in-ns 'paredit.parser\\n  )" "(sexp \\"3\\")" "(sexp \\"3/4\\")" "(sexp \\"/4\\")" "(sexp \\"3/\\")" "(sexp \\"3/4\\")" "3/4" "\\\\x34" "\\\\0x8" "\\\\0x73" "0x74" "0x43/0x23" "(type 0x74)" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:ratio [\:int* \\"/\\" \:int*]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(sexp \\"foo 3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"foo 3/4\\")" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]++(?\!\\\\.)|0[0-7]++(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]++(?\!\\\\.)|0[0-9]++(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    ;\:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             ;\:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\"\\n    ;\:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    ;\:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             ;\:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    ;\:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]++/[0-9]++\\"\\n    ;\:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(use 'net.cgrand.regex)" "(exec \#\\"[-+]?[0-9]++/[0-9]++\\" \\"98\\")" "(exec (regex \#\\"[-+]?[0-9]++/[0-9]++\\") \\"98\\")" "(regex \\"foo\\")" "(require '[net.cgrand.regex \:as r])" "(r/regex \\"f\\")" "(r/exec (r/regex \#\\"[-+]?[0-9]++/[0-9]++\\") \\"98\\")" "(r/exec \#\\"[-+]?[0-9]++/[0-9]++\\" \\"98\\")" "(\#\\"[-+]?[0-9]++/[0-9]++\\" \\"98\\")" "(re-find \#\\"[-+]?[0-9]++/[0-9]++\\" \\"98\\")" "(re-seq \#\\"[-+]?[0-9]++/[0-9]++\\" \\"98\\")" "(doc re-seq\\n  )" "(re-seq \#\\"98\\" \\"98\\")" "(re-seq \#\\"[-+]?[0-9]++/[0-9]++\\" \\"9/8\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(re-seq \#\\"[-+]?[0-9]+/[0-9]+\\" \\"3/4\\")" "(re-seq \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\" \\"3/4\\")" "(re-seq \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/)\\" \\"3/4\\")" "(re-seq \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\:?\!/)\\" \\"3/4\\")" "(re-seq \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A\\n  -Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\:?\!/)\\" \\"3/4\\")" "(re-seq \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!(?\:\\\\.|/)))\\" \\"3/4\\")" "(re-seq \#\\"[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))\\" \\"3/4\\")" "(re-seq \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\" \\"3/4\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    ;\:ratio [\:int \\"/\\" \:int]\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(sexp \\"3/4\\")" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]++\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]++)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)++\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)+\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*+\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*+\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)+\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?+\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)+\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [\\"(\\" \:expr* \\")\\"]\\n    \:chimera \#{ [\\"(\\"  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [\\"[\\"  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [\\"{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [\\"\#(\\" \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [\\"\#{\\" \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [\\"[\\" \:expr* \\"]\\"]\\n    \:map [\\"{\\" \:expr* \\"}\\"]\\n    \:set [\\"\#{\\" \:expr* \\"}\\"]\\n    \:quote [\\\\' \:expr]\\n    \:meta [\\"^\\" \:expr \:expr]\\n    \:deref [\\\\@ \:expr]\\n    \:syntax-quote [\\\\` \:expr]\\n    \:var [\\"\#'\\" \:expr]\\n    \:fn [\\"\#(\\" \:expr* \\")\\"]\\n    \:deprecated-meta [\\"\#^\\" \:expr \:expr]\\n    \:unquote-splicing [\\"~@\\" \:expr]\\n    \:unquote [\#\\"~(?\!@)\\" \:expr]\\n    \:string (unspaced \\\\\\"    \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced \\"\#\\\\\\"\\" \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg \#\\"%(?\:[0-9|\\\\&])?+\\"\\n    \:keyword (unspaced \#\\"\:{1,2}\\" \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\")\\n    \:char \#\\"\\\\\\\\(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\"\\n    \:whitespace \#\\"(?\:,|\\\\s)+\\"\\n    \:comment \#\\"(?\:\\\\\#\\\\\!|;)[^\\\\n]*\\"\\n    \:discard [\\"\#_\\" \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"3/4\\")" "\:\u00E9\u00E0" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.parser\\\\n  (\:use clojure.test)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:use paredit.regex-utils)\\\\n\\\\t(\:require [clojure.zip \:as zip])\\\\n  (\:require [clojure.contrib.zip-filter \:as zf])\\\\n  (\:use net.cgrand.parsley)\\\\n  (\:require [net.cgrand.parsley.lrplus \:as lr+])\\\\n  (\:require [net.cgrand.regex \:as r]))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n(def *brackets-tags* \#{\:list \:map \:vector \:string \:set \:fn \:regex})\\\\n(def *tag-closing-brackets* {\:list \\\\\\")\\\\\\", \:map \\\\\\"}\\\\\\", \:vector \\\\\\"]\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"}\\\\\\", \:fn \\\\\\")\\\\\\"})\\\\n(def *tag-opening-brackets* {\:list \\\\\\"(\\\\\\", \:map \\\\\\"{\\\\\\", \:vector \\\\\\"[\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"\#{\\\\\\", \:fn \\\\\\"\#(\\\\\\"})\\\\n(def *atom* \#{\:symbol \:keyword \:int \:float \:ratio \:anon-arg})\\\\n\\\\n\#_(def ^{\:private true} *brackets* {\\\\\\"(\\\\\\" \\\\\\")\\\\\\", \\\\\\"{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"[\\\\\\" \\\\\\"]\\\\\\", \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"\#(\\\\\\" \\\\\\")\\\\\\"})\\\\n\#_(def ^{\:private true} *opening-bracket-tags* {\\\\\\"(\\\\\\" \:list, \\\\\\"{\\\\\\" \:map, \\\\\\"[\\\\\\" \:vector, \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \:string, \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \:regex, \\\\\\"\#{\\\\\\" \:set, \\\\\\"\#(\\\\\\" \:fn})\\\\n\#_(def ^{\:private true} *opening-brackets* (set (keys *brackets*)))\\\\n\#_(def ^{\:private true} *closing-brackets* (set (vals *brackets*)))\\\\n\#_(def ^{\:private true} *spaces* \#{(str \\\\\\\\space) (str \\\\\\\\tab) (str \\\\\\\\newline) (str \\\\\\\\return) (str \\\\\\\\,)})\\\\n\#_(def *atoms* (conj *atom* \:whitespace))\\\\n\\\\n(defn eof [s eof?]\\\\n  (when (and (\= 0 (.length s)) eof?) [0 eof]))\\\\n\\\\n(defn bracket-end [s eof?]\\\\n  (lr+/match \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof} s eof?))\\\\n\\\\n(def gspaces \#{\:whitespace \:comment \:discard})\\\\n(def only-code (partial remove (comp gspaces \:tag)))\\\\n(defn code-children [e] (only-code (\:content e)))\\\\n(defn sym-name\\\\n  \\\\\\"returns the symbol name\\\\\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))\\\\n(defn call-of [e c] (and (\#{\\\\\\"(\\\\\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))\\\\n(defn call-args [e] (-> (code-children e) nnext butlast))\\\\n(defn form \\\\n  \\\\\\"removes the meta(s) to get to the form\\\\\\" \\\\n  [e]\\\\n  (if-not (\#{\:meta} (\:tag e))\\\\n    e\\\\n    (recur (nth (code-children e) 2))))\\\\n\\\\n(def open-list \\\\\\"(\\\\\\")\\\\n(def open-vector \\\\\\"[\\\\\\")\\\\n(def open-map \\\\\\"{\\\\\\")\\\\n(def open-set \\\\\\"\#{\\\\\\")\\\\n(def open-quote \\\\\\\\')\\\\n(def open-meta \\\\\\"^\\\\\\")\\\\n(def open-deref \\\\\\\\@)\\\\n(def open-syntax-quote \\\\\\\\`)\\\\n(def open-fn \\\\\\"\#(\\\\\\")\\\\n(def open-var \\\\\\"\#'\\\\\\")\\\\n(def open-deprecated-meta \\\\\\"\#^\\\\\\")\\\\n(def open-string \\\\\\\\\\\\\\")\\\\n(def open-regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\")\\\\n(def open-unquote-splicing \\\\\\"~@\\\\\\")\\\\n(def open-unquote \#\\\\\\"~(?\!@)\\\\\\")\\\\n(def open-anon-arg \\\\\\"%\\\\\\")\\\\n(def open-keyword \#\\\\\\"\:{1,2}\\\\\\")\\\\n(def open-discard \\\\\\"\#_\\\\\\")\\\\n(def whitespace \#\\\\\\"(?\:,|\\\\\\\\s)+\\\\\\")\\\\n(def open-comment \#\\\\\\"(?\:\\\\\\\\\#\\\\\\\\\!|;)\\\\\\")\\\\n(def open-char \\\\\\"\\\\\\\\\\\\\\\\\\\\\\")\\\\n(def ^{\:private true} prefixes\\\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\\\n    open-char\\\\n    })\\\\n\\\\n(def sexp\\\\n  (parser {\:root-tag \:root\\\\n           \:main \:expr*\\\\n           \:space (unspaced gspaces \:*)}\\\\n    \:expr- \#{\\\\n             \:list\\\\n             \:vector\\\\n             \:map\\\\n             \:set\\\\n             \:quote\\\\n             \:meta\\\\n             \:deref\\\\n             \:syntax-quote\\\\n             \:var\\\\n             \:fn\\\\n             \:deprecated-meta\\\\n             \:unquote-splicing\\\\n             \:unquote\\\\n             \:string\\\\n             \:regex\\\\n             \:symbol \\\\n             \:keyword \\\\n             \:int \\\\n             \:float \\\\n             \:ratio \\\\n             \:anon-arg\\\\n             \:char\\\\n             \:chimera\\\\n             }\\\\n    \:list [open-list \:expr* \\\\\\")\\\\\\"]\\\\n    \:chimera \#{ [open-list  \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}] \\\\n                [open-vector  \:expr* \#{\\\\\\")\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-map \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                [open-fn \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-set \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                }\\\\n    \:vector [open-vector \:expr* \\\\\\"]\\\\\\"]\\\\n    \:map [open-map \:expr* \\\\\\"}\\\\\\"]\\\\n    \:set [open-set \:expr* \\\\\\"}\\\\\\"]\\\\n    \:quote [open-quote \:expr]\\\\n    \:meta [open-meta \:expr \:expr]\\\\n    \:deref [open-deref \:expr]\\\\n    \:syntax-quote [open-syntax-quote \:expr]\\\\n    \:var [open-var \:expr]\\\\n    \:fn [open-fn \:expr* \\\\\\")\\\\\\"]\\\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\\\n    \:unquote [open-unquote \:expr]\\\\n    \:string (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:regex  (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:symbol \\\\n      (let [symbol-head \\\\n              \#\\\\\\"(?\:[a-z|A-Z|\\\\\\\\*|\\\\\\\\\!]|\\\\\\\\-(?\![0-9])|[\\\\\\\\_|\\\\\\\\?|\\\\\\\\>|\\\\\\\\<|\\\\\\\\\=|\\\\\\\\$]|\\\\\\\\+(?\![0-9]))\\\\\\"\\\\n            symbol-rest \\\\n              (interpol-regex \#\\\\\\"(?\:`symbol-head`|[0-9]|\\\\\\\\.|\\\\\\\\\#(?\!\\\\\\\\())\\\\\\")\\\\n            symbol-name\\\\n              (interpol-regex \#\\\\\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\\\\\:`symbol-rest`++)*+)\\\\\\")\\\\n              ]\\\\n        (interpol-regex \#\\\\\\"(?\:\\\\\\\\.|\\\\\\\\/|\\\\\\\\&|`symbol-name`(?\:\\\\\\\\/`symbol-name`)?)\\\\\\"))\\\\n    \:int \#\\\\\\"(?\:[-+]?(?\:0(?\!\\\\\\\\.)|[1-9][0-9]*+(?\!\\\\\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\\\\\.)|0[0-7]+(?\!\\\\\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\\\\\.)|0[0-9]+(?\!\\\\\\\\.))(?\!/))\\\\\\"\\\\n    \:ratio \#\\\\\\"[-+]?[0-9]+/[0-9]+\\\\\\"\\\\n    \:float \#\\\\\\"[-+]?[0-9]+\\\\\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\\\\\"\\\\n    \:anon-arg (unspaced open-anon-arg \#\\\\\\"(?\:[0-9|\\\\\\\\&])?+\\\\\\")\\\\n    \:keyword (unspaced open-keyword \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\{\\\\\\\\'\\\\\\\\^\\\\\\\\@\\\\\\\\`\\\\\\\\~\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\)\\\\\\\\]\\\\\\\\}]*\\\\\\")\\\\n    \:char (unspaced open-char \#\\\\\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\\\\\")\\\\n    \:whitespace whitespace\\\\n    \:comment (unspaced open-comment \#\\\\\\"[^\\\\\\\\n]*\\\\\\")\\\\n    \:discard [open-discard \:expr]\\\\n    ))\\\\n\\\\n(defn parse\\\\n  ([^String text]\\\\n    (sexp text))\\\\n  ([^String text offset]\\\\n    (sexp text)))\\\\n\\\\n(defn parse-tree\\\\n  [state]\\\\n  state)\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/parser.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" ";; Loading file src/paredit/parser.clj" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      (let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" ";; Loading file src/paredit/parser.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.parser\\\\n  (\:use clojure.test)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:use paredit.regex-utils)\\\\n\\\\t(\:require [clojure.zip \:as zip])\\\\n  (\:require [clojure.contrib.zip-filter \:as zf])\\\\n  (\:use net.cgrand.parsley)\\\\n  (\:require [net.cgrand.parsley.lrplus \:as lr+])\\\\n  (\:require [net.cgrand.regex \:as r]))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n\\\\n(def *brackets-tags* \#{\:list \:map \:vector \:string \:set \:fn \:regex})\\\\n(def *tag-closing-brackets* {\:list \\\\\\")\\\\\\", \:map \\\\\\"}\\\\\\", \:vector \\\\\\"]\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"}\\\\\\", \:fn \\\\\\")\\\\\\"})\\\\n(def *tag-opening-brackets* {\:list \\\\\\"(\\\\\\", \:map \\\\\\"{\\\\\\", \:vector \\\\\\"[\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"\#{\\\\\\", \:fn \\\\\\"\#(\\\\\\"})\\\\n(def *atom* \#{\:symbol \:keyword \:int \:float \:ratio \:anon-arg})\\\\n\\\\n\#_(def ^{\:private true} *brackets* {\\\\\\"(\\\\\\" \\\\\\")\\\\\\", \\\\\\"{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"[\\\\\\" \\\\\\"]\\\\\\", \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"\#(\\\\\\" \\\\\\")\\\\\\"})\\\\n\#_(def ^{\:private true} *opening-bracket-tags* {\\\\\\"(\\\\\\" \:list, \\\\\\"{\\\\\\" \:map, \\\\\\"[\\\\\\" \:vector, \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \:string, \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \:regex, \\\\\\"\#{\\\\\\" \:set, \\\\\\"\#(\\\\\\" \:fn})\\\\n\#_(def ^{\:private true} *opening-brackets* (set (keys *brackets*)))\\\\n\#_(def ^{\:private true} *closing-brackets* (set (vals *brackets*)))\\\\n\#_(def ^{\:private true} *spaces* \#{(str \\\\\\\\space) (str \\\\\\\\tab) (str \\\\\\\\newline) (str \\\\\\\\return) (str \\\\\\\\,)})\\\\n\#_(def *atoms* (conj *atom* \:whitespace))\\\\n\\\\n(defn eof [s eof?]\\\\n  (when (and (\= 0 (.length s)) eof?) [0 eof]))\\\\n\\\\n(defn bracket-end [s eof?]\\\\n  (lr+/match \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof} s eof?))\\\\n\\\\n(def gspaces \#{\:whitespace \:comment \:discard})\\\\n(def only-code (partial remove (comp gspaces \:tag)))\\\\n(defn code-children [e] (only-code (\:content e)))\\\\n(defn sym-name\\\\n  \\\\\\"returns the symbol name\\\\\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))\\\\n(defn call-of [e c] (and (\#{\\\\\\"(\\\\\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))\\\\n(defn call-args [e] (-> (code-children e) nnext butlast))\\\\n(defn form \\\\n  \\\\\\"removes the meta(s) to get to the form\\\\\\" \\\\n  [e]\\\\n  (if-not (\#{\:meta} (\:tag e))\\\\n    e\\\\n    (recur (nth (code-children e) 2))))\\\\n\\\\n(def open-list \\\\\\"(\\\\\\")\\\\n(def open-vector \\\\\\"[\\\\\\")\\\\n(def open-map \\\\\\"{\\\\\\")\\\\n(def open-set \\\\\\"\#{\\\\\\")\\\\n(def open-quote \\\\\\\\')\\\\n(def open-meta \\\\\\"^\\\\\\")\\\\n(def open-deref \\\\\\\\@)\\\\n(def open-syntax-quote \\\\\\\\`)\\\\n(def open-fn \\\\\\"\#(\\\\\\")\\\\n(def open-var \\\\\\"\#'\\\\\\")\\\\n(def open-deprecated-meta \\\\\\"\#^\\\\\\")\\\\n(def open-string \\\\\\\\\\\\\\")\\\\n(def open-regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\")\\\\n(def open-unquote-splicing \\\\\\"~@\\\\\\")\\\\n(def open-unquote \#\\\\\\"~(?\!@)\\\\\\")\\\\n(def open-anon-arg \\\\\\"%\\\\\\")\\\\n(def open-keyword \#\\\\\\"\:{1,2}\\\\\\")\\\\n(def open-discard \\\\\\"\#_\\\\\\")\\\\n(def whitespace \#\\\\\\"(?\:,|\\\\\\\\s)+\\\\\\")\\\\n(def open-comment \#\\\\\\"(?\:\\\\\\\\\#\\\\\\\\\!|;)\\\\\\")\\\\n(def open-char \\\\\\"\\\\\\\\\\\\\\\\\\\\\\")\\\\n(def ^{\:private true} prefixes\\\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\\\n    open-char\\\\n    })\\\\n\\\\n(def sexp\\\\n  (parser {\:root-tag \:root\\\\n           \:main \:expr*\\\\n           \:space (unspaced gspaces \:*)}\\\\n    \:expr- \#{\\\\n             \:list\\\\n             \:vector\\\\n             \:map\\\\n             \:set\\\\n             \:quote\\\\n             \:meta\\\\n             \:deref\\\\n             \:syntax-quote\\\\n             \:var\\\\n             \:fn\\\\n             \:deprecated-meta\\\\n             \:unquote-splicing\\\\n             \:unquote\\\\n             \:string\\\\n             \:regex\\\\n             \:symbol \\\\n             \:keyword \\\\n             \:int \\\\n             \:float \\\\n             \:ratio \\\\n             \:anon-arg\\\\n             \:char\\\\n             \:chimera\\\\n             }\\\\n    \:list [open-list \:expr* \\\\\\")\\\\\\"]\\\\n    \:chimera \#{ [open-list  \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}] \\\\n                [open-vector  \:expr* \#{\\\\\\")\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-map \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                [open-fn \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-set \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                }\\\\n    \:vector [open-vector \:expr* \\\\\\"]\\\\\\"]\\\\n    \:map [open-map \:expr* \\\\\\"}\\\\\\"]\\\\n    \:set [open-set \:expr* \\\\\\"}\\\\\\"]\\\\n    \:quote [open-quote \:expr]\\\\n    \:meta [open-meta \:expr \:expr]\\\\n    \:deref [open-deref \:expr]\\\\n    \:syntax-quote [open-syntax-quote \:expr]\\\\n    \:var [open-var \:expr]\\\\n    \:fn [open-fn \:expr* \\\\\\")\\\\\\"]\\\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\\\n    \:unquote [open-unquote \:expr]\\\\n    \:string (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:regex  (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:symbol \\\\n      (let [symbol-head \\\\n              \#\\\\\\"(?\:[a-z|A-Z|\\\\\\\\*|\\\\\\\\\!]|\\\\\\\\-(?\![0-9])|[\\\\\\\\_|\\\\\\\\?|\\\\\\\\>|\\\\\\\\<|\\\\\\\\\=|\\\\\\\\$]|\\\\\\\\+(?\![0-9]))\\\\\\"\\\\n            symbol-rest \\\\n              (interpol-regex \#\\\\\\"(?\:`symbol-head`|[0-9]|\\\\\\\\.|\\\\\\\\\#(?\!\\\\\\\\())\\\\\\")\\\\n            symbol-name\\\\n              (interpol-regex \#\\\\\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\\\\\:`symbol-rest`++)*+)\\\\\\")\\\\n              ]\\\\n        (interpol-regex \#\\\\\\"(?\:\\\\\\\\.|\\\\\\\\/|\\\\\\\\&|`symbol-name`(?\:\\\\\\\\/`symbol-name`)?)\\\\\\"))\\\\n    \:int \#\\\\\\"(?\:[-+]?(?\:0(?\!\\\\\\\\.)|[1-9][0-9]*+(?\!\\\\\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\\\\\.)|0[0-7]+(?\!\\\\\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\\\\\.)|0[0-9]+(?\!\\\\\\\\.))(?\!/))\\\\\\"\\\\n    \:ratio \#\\\\\\"[-+]?[0-9]+/[0-9]+\\\\\\"\\\\n    \:float \#\\\\\\"[-+]?[0-9]+\\\\\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\\\\\"\\\\n    \:anon-arg (unspaced open-anon-arg \#\\\\\\"(?\:[0-9|\\\\\\\\&])?+\\\\\\")\\\\n    \:keyword (unspaced open-keyword \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\{\\\\\\\\'\\\\\\\\^\\\\\\\\@\\\\\\\\`\\\\\\\\~\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\)\\\\\\\\]\\\\\\\\}]*\\\\\\")\\\\n    \:char (unspaced open-char \#\\\\\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\\\\\")\\\\n    \:whitespace whitespace\\\\n    \:comment (unspaced open-comment \#\\\\\\"[^\\\\\\\\n]*\\\\\\")\\\\n    \:discard [open-discard \:expr]\\\\n    ))\\\\n\\\\n(defn parse\\\\n  ([^String text]\\\\n    (sexp text))\\\\n  ([^String text offset]\\\\n    (sexp text)))\\\\n\\\\n(defn parse-tree\\\\n  [state]\\\\n  state)\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/parser.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(doc def)" "(doc defvar)" "(sex \\"'\\")" "(require 'paredit.parser)" "(in-ns 'paredit.par)" "(in-ns 'paredit.parser)" "(sexp \\"(\\")" "(sexp \\"-\\")" "(sexp \\"-9\\")" "(sexp \\"9\\")" "(sexp \\"9sd\\")" "(re-seq \\"9s\\")" "(re-seq \#\\"[^([\#{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9]\\" \\"9s\\")" "(re-seq \#\\"[^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9]\\" \\"9s\\")" "(def symbol-exclusion \#\\"[^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9]\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#_(let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#_(interpol-regex \#\\"`symbol-exclusion`[]\\" )\\n      \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(def ^{\:private true} prefixes\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\n    open-char})" "(def symbol-exclusion \#\\"[^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9]\\")" "(def ^{\:private true} prefixes\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\n    open-char})" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#_(let [symbol-head \\n              \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n            symbol-rest \\n              (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n            symbol-name\\n              (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n              ]\\n        (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#_(interpol-regex \#\\"`symbol-exclusion`[]\\" )\\n      \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      ;\#_(interpol-regex \#\\"`symbol-exclusion`[]\\" )\\n      \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"[^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(sexp \\"hello\\")" "(sexp \\"3/4\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"^foo\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(sexp \\"^foo\\")" "(sexp \\"^foo bar\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"3/4\\")" "(sexp \\"-3/4\\")" "-sdf" "(def -sd)" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:-[^0-9])?[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(sexp \\"-3\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"-[^0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]*|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(sexp \\"-3\\")" "(re-seq \#\\"-[^0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]*|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-3\\")" "(re-seq \#\\"(?\:-[^0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]*|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-3\\")" "(re-seq \#\\"(?\:-[^0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]*|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-0\\")" "(re-seq \#\\"(?\:-[^0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]*|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-1\\")" "(re-seq \#\\"(?\:-(?\![^0-9]))?[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-3\\")" "(re-seq \#\\"-\\" \\"-3\\")" "(re-seq \#\\"-(?\![0-9])\\" \\"-3\\")" "(re-seq \#\\"(?\:-(?\![0-9]))?[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-3\\")" "(re-seq \#\\"(?\:-(?\![0-9]))[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`;0-9\\\\)\\\\]\\\\}]+\\" \\"-3\\")" "(re-seq \#\\"(?\:-(?\![0-9]))[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]+|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]+\\" \\"-3\\")" "(re-seq \#\\"(?\:-(?\![0-9]))[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*\\" \\"-3\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:-(?\![0-9]))[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:-(?\![0-9])|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"-3\\")" "(re-seq \#\\"(?\:-(?\![0-9])|[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*\\" \\"-3\\")" "-" "(sex \\"-\\")" "(sexp \\"-\\")" "(re-seq \#\\"(?\:-(?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\\" \\"-3\\")" "(re-seq \#\\"(?\:-(?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\\" \\"3\\")" "(re-seq \#\\"(?\:-(?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\\" \\"+3\\")" "+3" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:-(?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"-3\\")" "(sexp \\"+3\\")" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\\!\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(sexp \\"+3\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(sexp \\"-3\\")" "(sexp \\"-q\\")" "(sexp \\"*3\\")" "(sexp \\"*\\")" "(paredit.tests/paredit-tests)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/paredit-tests)))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parser-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             \\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\";\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"set\!\\")" "(sexp \\"set\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"\!\\")" "\!" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(sexp \\"\!\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"&\\")" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"`o\\")" "(sexp \\"o\#\\")" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             ;\\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:expr]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [;\\"paredit/compile.clj\\" \\n             ;\\"paredit/core_commands.clj\\"\\n             ;\\"paredit/c.clj\\"\\n             ;\\"paredit/core.clj\\"\\n             ;\\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"\\")" "(sexp \\"\:sdf\#sdf\\")" "(sexp \\"^\\")" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r (comment [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ])]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "^" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r (comment [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ])]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(sexp \\"^\\")" "(clojure.core/in-ns 'paredit.tests)\\n[\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      ;\#_(let [symbol-head \\n      ;        \#\\"(?\:[a-z|A-Z|\\\\*|\\\\\!]|\\\\-(?\![0-9])|[\\\\_|\\\\?|\\\\>|\\\\<|\\\\\=|\\\\$]|\\\\+(?\![0-9]))\\"\\n      ;      symbol-rest \\n      ;        (interpol-regex \#\\"(?\:`symbol-head`|[0-9]|\\\\.|\\\\\#(?\!\\\\())\\")\\n      ;      symbol-name\\n      ;        (interpol-regex \#\\"(?\:`symbol-head``symbol-rest`*(?\:\\\\\:`symbol-rest`++)*+)\\")\\n      ;        ]\\n      ;  (interpol-regex \#\\"(?\:\\\\.|\\\\/|\\\\&|`symbol-name`(?\:\\\\/`symbol-name`)?)\\"))\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]+\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"3/\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(clojure.core/in-ns 'paredit.tests)\\n(deftest parsetree-tests\\n  (doseq [s [\\"\\"\\n             \\"(defn \\"\\n             \\"3/4\\"\\n             \\"-3/4\\"\\n             \\"3/\\"\\n             \\"\:\u00E9\u00E0\\"\\n             \\"\:\:\u00E9\u00E0\\"\\n             \\"or\#\\"\\n             \\"^\\"\\n             \\"\#\\"]]\\n    (is (\= s (parsetree-to-string (sexp s)))))\\n  (doseq [r [\\"paredit/compile.clj\\" \\n             \\"paredit/core_commands.clj\\"\\n             \\"paredit/c.clj\\"\\n             \\"paredit/core.clj\\"\\n             \\"paredit/loc_utils.clj\\"\\n             \\"clojure/core.clj\\"\\n             ]]\\n    (let [s (slurp (.getResourceAsStream (clojure.lang.RT/baseLoader) r))]\\n      (is (\= s (parsetree-to-string (sexp s)))))))\\n(clojure.core/in-ns 'paredit.parser)" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\:[\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!]))\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol \\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol ; \\"\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])\\"\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!]))\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" "(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol ; \\"\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])\\"\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/parsetree-tests)))" ";; Loading file src/paredit/parser.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.parser\\\\n  (\:use clojure.test)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:use paredit.regex-utils)\\\\n\\\\t(\:require [clojure.zip \:as zip])\\\\n  (\:require [clojure.contrib.zip-filter \:as zf])\\\\n  (\:use net.cgrand.parsley)\\\\n  (\:require [net.cgrand.parsley.lrplus \:as lr+])\\\\n  (\:require [net.cgrand.regex \:as r]))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n(defn aaa \\\\\\"abc (ns ...)\\\\\\" [])\\\\n(def *brackets-tags* \#{\:list \:map \:vector \:string \:set \:fn \:regex})\\\\n(def *tag-closing-brackets* {\:list \\\\\\")\\\\\\", \:map \\\\\\"}\\\\\\", \:vector \\\\\\"]\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"}\\\\\\", \:fn \\\\\\")\\\\\\"})\\\\n(def *tag-opening-brackets* {\:list \\\\\\"(\\\\\\", \:map \\\\\\"{\\\\\\", \:vector \\\\\\"[\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"\#{\\\\\\", \:fn \\\\\\"\#(\\\\\\"})\\\\n(def *atom* \#{\:symbol \:keyword \:int \:float \:ratio \:anon-arg})\\\\n(aaa)\\\\n\#_(def ^{\:private true} *brackets* {\\\\\\"(\\\\\\" \\\\\\")\\\\\\", \\\\\\"{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"[\\\\\\" \\\\\\"]\\\\\\", \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"\#(\\\\\\" \\\\\\")\\\\\\"})\\\\n\#_(def ^{\:private true} *opening-bracket-tags* {\\\\\\"(\\\\\\" \:list, \\\\\\"{\\\\\\" \:map, \\\\\\"[\\\\\\" \:vector, \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \:string, \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \:regex, \\\\\\"\#{\\\\\\" \:set, \\\\\\"\#(\\\\\\" \:fn})\\\\n\#_(def ^{\:private true} *opening-brackets* (set (keys *brackets*)))\\\\n\#_(def ^{\:private true} *closing-brackets* (set (vals *brackets*)))\\\\n\#_(def ^{\:private true} *spaces* \#{(str \\\\\\\\space) (str \\\\\\\\tab) (str \\\\\\\\newline) (str \\\\\\\\return) (str \\\\\\\\,)})\\\\n\#_(def *atoms* (conj *atom* \:whitespace))\\\\n\\\\n(defn eof [s eof?]\\\\n  (when (and (\= 0 (.length s)) eof?) [0 eof]))\\\\n\\\\n(defn bracket-end [s eof?]\\\\n  (lr+/match \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof} s eof?))\\\\n\\\\n(def gspaces \#{\:whitespace \:comment \:discard})\\\\n(def only-code (partial remove (comp gspaces \:tag)))\\\\n(defn code-children [e] (only-code (\:content e)))\\\\n(defn sym-name\\\\n  \\\\\\"returns the symbol name\\\\\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))\\\\n(defn call-of [e c] (and (\#{\\\\\\"(\\\\\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))\\\\n(defn call-args [e] (-> (code-children e) nnext butlast))\\\\n(defn form \\\\n  \\\\\\"removes the meta(s) to get to the form\\\\\\" \\\\n  [e]\\\\n  (if-not (\#{\:meta} (\:tag e))\\\\n    e\\\\n    (recur (nth (code-children e) 2))))\\\\n\\\\n(def open-list \\\\\\"(\\\\\\")\\\\n(def open-vector \\\\\\"[\\\\\\")\\\\n(def open-map \\\\\\"{\\\\\\")\\\\n(def open-set \\\\\\"\#{\\\\\\")\\\\n(def open-quote \\\\\\\\')\\\\n(def open-meta \\\\\\"^\\\\\\")\\\\n(def open-deref \\\\\\\\@)         ;\\\\\\"\#(?\:[\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\" \\\\n(def open-syntax-quote \\\\\\\\`)\\\\n(def open-fn \\\\\\"\#(\\\\\\")\\\\n(def open-var \\\\\\"\#'\\\\\\")\\\\n(def open-deprecated-meta \\\\\\"\#^\\\\\\")\\\\n(def open-string \\\\\\\\\\\\\\")\\\\n(def open-regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\")\\\\n(def open-unquote-splicing \\\\\\"~@\\\\\\")\\\\n(def open-unquote \#\\\\\\"~(?\!@)\\\\\\")\\\\n(def open-anon-arg \\\\\\"%\\\\\\")\\\\n(def open-keyword \#\\\\\\"\:{1,2}\\\\\\")\\\\n(def open-discard \\\\\\"\#_\\\\\\")\\\\n(def whitespace \#\\\\\\"(?\:,|\\\\\\\\s)+\\\\\\")\\\\n(def open-comment \#\\\\\\"(?\:\\\\\\\\\#\\\\\\\\\!|;)\\\\\\")\\\\n(def open-char \\\\\\"\\\\\\\\\\\\\\\\\\\\\\")\\\\n(def symbol-exclusion \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\\!\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`;0-9]\\\\\\")\\\\n(def ^{\:private true} prefixes\\\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\\\n    open-char})\\\\n(def sexp\\\\n  (parser {\:root-tag \:root\\\\n           \:main \:expr*\\\\n           \:space (unspaced gspaces \:*)}\\\\n    \:expr- \#{\\\\n             \:list\\\\n             \:vector\\\\n             \:map\\\\n             \:set\\\\n             \:quote\\\\n             \:meta\\\\n             \:deref\\\\n             \:syntax-quote\\\\n             \:var\\\\n             \:fn\\\\n             \:deprecated-meta\\\\n             \:unquote-splicing\\\\n             \:unquote\\\\n             \:string\\\\n             \:regex\\\\n             \:symbol \\\\n             \:keyword \\\\n             \:int \\\\n             \:float \\\\n             \:ratio \\\\n             \:anon-arg\\\\n             \:char\\\\n             \:chimera\\\\n             }\\\\n    \:list [open-list \:expr* \\\\\\")\\\\\\"]\\\\n    \:chimera \#{ [open-list  \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}] \\\\n                [open-vector  \:expr* \#{\\\\\\")\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-map \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                [open-fn \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-set \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                }\\\\n    \:vector [open-vector \:expr* \\\\\\"]\\\\\\"]\\\\n    \:map [open-map \:expr* \\\\\\"}\\\\\\"]\\\\n    \:set [open-set \:expr* \\\\\\"}\\\\\\"]\\\\n    \:quote [open-quote \:expr]\\\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\\\n    \:deref [open-deref \:expr]\\\\n    \:syntax-quote [open-syntax-quote \:expr]\\\\n    \:var [open-var \:expr]\\\\n    \:fn [open-fn \:expr* \\\\\\")\\\\\\"]\\\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\\\n    \:unquote [open-unquote \:expr]\\\\n    \:string (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:regex  (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:symbol ; \\\\\\"\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\"\\\\n      \#\\\\\\"(?\:[\\\\\\\\-\\\\\\\\+](?\![0-9])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)|(?\:[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}\\\\\\\\-\\\\\\\\+;0-9][^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*|\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)\#?\\\\\\"\\\\n    \:keyword (unspaced open-keyword \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\{\\\\\\\\'\\\\\\\\^\\\\\\\\@\\\\\\\\`\\\\\\\\~\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\)\\\\\\\\]\\\\\\\\}]*\\\\\\"); factorize with symbol\\\\n    \:int \#\\\\\\"(?\:[-+]?(?\:0(?\!\\\\\\\\.)|[1-9][0-9]*+(?\!\\\\\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\\\\\.)|0[0-7]+(?\!\\\\\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\\\\\.)|0[0-9]+(?\!\\\\\\\\.))(?\!/))\\\\\\"\\\\n    \:ratio \#\\\\\\"[-+]?[0-9]+/[0-9]*\\\\\\"\\\\n    \:float \#\\\\\\"[-+]?[0-9]+\\\\\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\\\\\"\\\\n    \:anon-arg (unspaced open-anon-arg \#\\\\\\"(?\:[0-9|\\\\\\\\&])?+\\\\\\")\\\\n    \:char (unspaced open-char \#\\\\\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\\\\\")\\\\n    \:whitespace whitespace\\\\n    \:comment (unspaced open-comment \#\\\\\\"[^\\\\\\\\n]*\\\\\\")\\\\n    \:discard [open-discard \:expr]\\\\n    ))\\\\n\\\\n(defn parse\\\\n  ([^String text]\\\\n    (sexp text))\\\\n  ([^String text offset]\\\\n    (sexp text)))\\\\n\\\\n(defn parse-tree\\\\n  [state]\\\\n  state)\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/parser.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(def a [[1 2 3]\\n       [4 5 6]\\n       [7 8 9]])" "(map vector a)" "(apply map vector a)" "(vec (apply map vector a))" ";; Loading file src/paredit/parser.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns paredit.parser\\\\n  (\:use clojure.test)\\\\n  (\:use clojure.contrib.core)\\\\n  (\:use paredit.regex-utils)\\\\n\\\\t(\:require [clojure.zip \:as zip])\\\\n  (\:require [clojure.contrib.zip-filter \:as zf])\\\\n  (\:use net.cgrand.parsley)\\\\n  (\:require [net.cgrand.parsley.lrplus \:as lr+])\\\\n  (\:require [net.cgrand.regex \:as r]))\\\\n\\\\n\#_(set\! *warn-on-reflection* true)\\\\n(defn get-in-2 [] 10)\\\\n\\\\n(defn usage [] (get-in-2))\\\\n\\\\n\\\\n(def *brackets-tags* \#{\:list \:map \:vector \:string \:set \:fn \:regex})\\\\n(def *tag-closing-brackets* {\:list \\\\\\")\\\\\\", \:map \\\\\\"}\\\\\\", \:vector \\\\\\"]\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"}\\\\\\", \:fn \\\\\\")\\\\\\"})\\\\n(def *tag-opening-brackets* {\:list \\\\\\"(\\\\\\", \:map \\\\\\"{\\\\\\", \:vector \\\\\\"[\\\\\\", \:string \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \:regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\", \:set \\\\\\"\#{\\\\\\", \:fn \\\\\\"\#(\\\\\\"})\\\\n(def *atom* \#{\:symbol \:keyword \:int \:float \:ratio \:anon-arg})\\\\n\\\\n\#_(def ^{\:private true} *brackets* {\\\\\\"(\\\\\\" \\\\\\")\\\\\\", \\\\\\"{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"[\\\\\\" \\\\\\"]\\\\\\", \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \\\\\\"\\\\\\\\\\\\\\"\\\\\\", \\\\\\"\#{\\\\\\" \\\\\\"}\\\\\\", \\\\\\"\#(\\\\\\" \\\\\\")\\\\\\"})\\\\n\#_(def ^{\:private true} *opening-bracket-tags* {\\\\\\"(\\\\\\" \:list, \\\\\\"{\\\\\\" \:map, \\\\\\"[\\\\\\" \:vector, \\\\\\"\\\\\\\\\\\\\\"\\\\\\" \:string, \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\" \:regex, \\\\\\"\#{\\\\\\" \:set, \\\\\\"\#(\\\\\\" \:fn})\\\\n\#_(def ^{\:private true} *opening-brackets* (set (keys *brackets*)))\\\\n\#_(def ^{\:private true} *closing-brackets* (set (vals *brackets*)))\\\\n\#_(def ^{\:private true} *spaces* \#{(str \\\\\\\\space) (str \\\\\\\\tab) (str \\\\\\\\newline) (str \\\\\\\\return) (str \\\\\\\\,)})\\\\n\#_(def *atoms* (conj *atom* \:whitespace))\\\\n\\\\n(defn eof [s eof?]\\\\n  (when (and (\= 0 (.length s)) eof?) [0 eof]))\\\\n\\\\n(defn bracket-end [s eof?]\\\\n  (lr+/match \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof} s eof?))\\\\n\\\\n(def gspaces \#{\:whitespace \:comment \:discard})\\\\n(def only-code (partial remove (comp gspaces \:tag)))\\\\n(defn code-children [e] (only-code (\:content e)))\\\\n(defn sym-name\\\\n  \\\\\\"returns the symbol name\\\\\\" [e] (and (\#{\:symbol} (\:tag e)) (apply str (\:content e))))\\\\n(defn call-of [e c] (and (\#{\\\\\\"(\\\\\\"} (nth (code-children e) 0)) (\#{c} (sym-name (nth (code-children e) 1))) e))\\\\n(defn call-args [e] (-> (code-children e) nnext butlast))\\\\n(defn form \\\\n  \\\\\\"removes the meta(s) to get to the form\\\\\\" \\\\n  [e]\\\\n  (if-not (\#{\:meta} (\:tag e))\\\\n    e\\\\n    (recur (nth (code-children e) 2))))\\\\n\\\\n(def open-list \\\\\\"(\\\\\\")\\\\n(def open-vector \\\\\\"[\\\\\\")\\\\n(def open-map \\\\\\"{\\\\\\")\\\\n(def open-set \\\\\\"\#{\\\\\\")\\\\n(def open-quote \\\\\\\\')\\\\n(def open-meta \\\\\\"^\\\\\\")\\\\n(def open-deref \\\\\\\\@)         ;\\\\\\"\#(?\:[\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\" \\\\n(def open-syntax-quote \\\\\\\\`)\\\\n(def open-fn \\\\\\"\#(\\\\\\")\\\\n(def open-var \\\\\\"\#'\\\\\\")\\\\n(def open-deprecated-meta \\\\\\"\#^\\\\\\")\\\\n(def open-string \\\\\\\\\\\\\\")\\\\n(def open-regex \\\\\\"\#\\\\\\\\\\\\\\"\\\\\\")\\\\n(def open-unquote-splicing \\\\\\"~@\\\\\\")\\\\n(def open-unquote \#\\\\\\"~(?\!@)\\\\\\")\\\\n(def open-anon-arg \\\\\\"%\\\\\\")\\\\n(def open-keyword \#\\\\\\"\:{1,2}\\\\\\")\\\\n(def open-discard \\\\\\"\#_\\\\\\")\\\\n(def whitespace \#\\\\\\"(?\:,|\\\\\\\\s)+\\\\\\")\\\\n(def open-comment \#\\\\\\"(?\:\\\\\\\\\#\\\\\\\\\!|;)\\\\\\")\\\\n(def open-char \\\\\\"\\\\\\\\\\\\\\\\\\\\\\")\\\\n(def symbol-exclusion \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\\!\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`;0-9]\\\\\\")\\\\n(def ^{\:private true} prefixes\\\\n  \#{open-list open-vector open-map open-set open-quote open-meta open-deref open-syntax-quote\\\\n    open-fn open-var open-deprecated-meta open-string open-regex open-unquote-splicing\\\\n    open-unquote open-anon-arg open-keyword open-discard whitespace open-comment\\\\n    open-char})\\\\n(def sexp\\\\n  (parser {\:root-tag \:root\\\\n           \:main \:expr*\\\\n           \:space (unspaced gspaces \:*)}\\\\n    \:expr- \#{\\\\n             \:list\\\\n             \:vector\\\\n             \:map\\\\n             \:set\\\\n             \:quote\\\\n             \:meta\\\\n             \:deref\\\\n             \:syntax-quote\\\\n             \:var\\\\n             \:fn\\\\n             \:deprecated-meta\\\\n             \:unquote-splicing\\\\n             \:unquote\\\\n             \:string\\\\n             \:regex\\\\n             \:symbol \\\\n             \:keyword \\\\n             \:int \\\\n             \:float \\\\n             \:ratio \\\\n             \:anon-arg\\\\n             \:char\\\\n             \:chimera\\\\n             }\\\\n    \:list [open-list \:expr* \\\\\\")\\\\\\"]\\\\n    \:chimera \#{ [open-list  \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}] \\\\n                [open-vector  \:expr* \#{\\\\\\")\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-map \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                [open-fn \:expr* \#{\\\\\\"]\\\\\\" \\\\\\"}\\\\\\" eof}]\\\\n                [open-set \:expr* \#{\\\\\\")\\\\\\" \\\\\\"]\\\\\\" eof}]\\\\n                (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\!\\\\\\\\\\\\\\")\\\\\\" \:? eof)\\\\n                }\\\\n    \:vector [open-vector \:expr* \\\\\\"]\\\\\\"]\\\\n    \:map [open-map \:expr* \\\\\\"}\\\\\\"]\\\\n    \:set [open-set \:expr* \\\\\\"}\\\\\\"]\\\\n    \:quote [open-quote \:expr]\\\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\\\n    \:deref [open-deref \:expr]\\\\n    \:syntax-quote [open-syntax-quote \:expr]\\\\n    \:var [open-var \:expr]\\\\n    \:fn [open-fn \:expr* \\\\\\")\\\\\\"]\\\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\\\n    \:unquote [open-unquote \:expr]\\\\n    \:string (unspaced open-string \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:regex  (unspaced open-regex \#\\\\\\"(?\:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])++(?\=\\\\\\\\\\\\\\")\\\\\\" \:? \\\\\\\\\\\\\\")\\\\n    \:symbol ; \\\\\\"\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])\\\\\\"\\\\n      \#\\\\\\"(?\:[\\\\\\\\-\\\\\\\\+](?\![0-9])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)|(?\:[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}\\\\\\\\-\\\\\\\\+;0-9][^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*|\#(?\![\\\\\\\\{\\\\\\\\(\\\\\\\\'\\\\\\\\^\\\\\\\\\\\\\\"\\\\\\\\_\\\\\\\\\!])[^\\\\\\\\^\\\\\\\\(\\\\\\\\[\\\\\\\\\#\\\\\\\\{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\~\\\\\\\\%\\\\\\\\\:\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\'\\\\\\\\@\\\\\\\\`\\\\\\\\)\\\\\\\\]\\\\\\\\}]*)\#?\\\\\\"\\\\n    \:keyword (unspaced open-keyword \#\\\\\\"[^\\\\\\\\(\\\\\\\\[\\\\\\\\{\\\\\\\\'\\\\\\\\^\\\\\\\\@\\\\\\\\`\\\\\\\\~\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\,\\\\\\\\s\\\\\\\\;\\\\\\\\)\\\\\\\\]\\\\\\\\}]*\\\\\\"); factorize with symbol\\\\n    \:int \#\\\\\\"(?\:[-+]?(?\:0(?\!\\\\\\\\.)|[1-9][0-9]*+(?\!\\\\\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\\\\\.)|0[0-7]+(?\!\\\\\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\\\\\.)|0[0-9]+(?\!\\\\\\\\.))(?\!/))\\\\\\"\\\\n    \:ratio \#\\\\\\"[-+]?[0-9]+/[0-9]*\\\\\\"\\\\n    \:float \#\\\\\\"[-+]?[0-9]+\\\\\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\\\\\"\\\\n    \:anon-arg (unspaced open-anon-arg \#\\\\\\"(?\:[0-9|\\\\\\\\&])?+\\\\\\")\\\\n    \:char (unspaced open-char \#\\\\\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\\\\\")\\\\n    \:whitespace whitespace\\\\n    \:comment (unspaced open-comment \#\\\\\\"[^\\\\\\\\n]*\\\\\\")\\\\n    \:discard [open-discard \:expr]\\\\n    ))\\\\n\\\\n(defn parse\\\\n  ([^String text]\\\\n    (sexp text))\\\\n  ([^String text offset]\\\\n    (sexp text)))\\\\n\\\\n(defn parse-tree\\\\n  [state]\\\\n  state)\\\\n\\") \\"/home/lpetit/projects/paredit.clj/src/paredit/parser.clj\\" \\"/home/lpetit/projects/paredit.clj/src\\")" "(map (fn [c1 c2 c3] [c1 c2 c3]) [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3])" "(map vector [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3])\\n([\:c1.1 \:c2.1 \:c3.1] [\:c1.2 \:c2.2 \:c3.2] [\:c1.3 \:c2.3 \:c3.3])" "(map vector [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3])" "(apply map vector (list [\:c1.1 \:c1.2 \:c1.3] [\:c2.1 \:c2.2 \:c2.3] [\:c3.1 \:c3.2 \:c3.3]))" "(let [users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\")]\\n(firs users)\\n)" "(let [users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\")]\\n(first users)\\n)" "(let [users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\")]\\n(-> users \:content \:first)\\n)" "(def users (clojure.xml/parse\\n\\"http\://api.twitter.com/1/statuses/friends/barackobama.xml\\"))" "users" "(-> users \:content first)" "'(require 'paredit.parser)" "'(in-ns 'paredit.parser)" "(in-ns 'paredit.parser)" "(require 'paredit.tests)" "(in-ns 'p.t)" "(in-ns 'paredit.tests)" "(pts)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(clojure.core/in-ns 'paredit.parser)\\n(def sexp\\n  (parser {\:root-tag \:root\\n           \:main \:expr*\\n           \:space (unspaced gspaces \:*)}\\n    \:expr- \#{\\n             \:list\\n             \:vector\\n             \:map\\n             \:set\\n             \:quote\\n             \:meta\\n             \:deref\\n             \:syntax-quote\\n             \:var\\n             \:fn\\n             \:deprecated-meta\\n             \:unquote-splicing\\n             \:unquote\\n             \:string\\n             \:regex\\n             \:symbol \\n             \:keyword \\n             \:int \\n             \:float \\n             \:ratio \\n             \:anon-arg\\n             \:char\\n             \:chimera\\n             }\\n    \:list [open-list \:expr* \\")\\"]\\n    \:chimera \#{ [open-list  \:expr* \#{\\"]\\" \\"}\\" eof}] \\n                [open-vector  \:expr* \#{\\")\\" \\"}\\" eof}]\\n                [open-map \:expr* \#{\\")\\" \\"]\\" eof}]\\n                [open-fn \:expr* \#{\\"]\\" \\"}\\" eof}]\\n                [open-set \:expr* \#{\\")\\" \\"]\\" eof}]\\n                (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\!\\\\\\")\\" \:? eof)\\n                }\\n    \:vector [open-vector \:expr* \\"]\\"]\\n    \:map [open-map \:expr* \\"}\\"]\\n    \:set [open-set \:expr* \\"}\\"]\\n    \:quote [open-quote \:expr*]\\n    \:meta [open-meta \:expr \:? \:expr \:?]\\n    \:deref [open-deref \:expr]\\n    \:syntax-quote [open-syntax-quote \:expr]\\n    \:var [open-var \:expr]\\n    \:fn [open-fn \:expr* \\")\\"]\\n    \:deprecated-meta [open-deprecated-meta \:expr \:expr]\\n    \:unquote-splicing [open-unquote-splicing \:expr]\\n    \:unquote [open-unquote \:expr]\\n    \:string (unspaced open-string \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:regex  (unspaced open-regex \#\\"(?\:\\\\\\\\.|[^\\\\\\\\\\\\\\"])++(?\=\\\\\\")\\" \:? \\\\\\")\\n    \:symbol ; \\"\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])\\"\\n      \#\\"(?\:[\\\\-\\\\+](?\![0-9])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)|(?\:[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}\\\\-\\\\+;0-9][^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*|\#(?\![\\\\{\\\\(\\\\'\\\\^\\\\\\"\\\\_\\\\\!])[^\\\\^\\\\(\\\\[\\\\\#\\\\{\\\\\\\\\\\\\\"\\\\~\\\\%\\\\\:\\\\,\\\\s\\\\;\\\\'\\\\@\\\\`\\\\)\\\\]\\\\}]*)\#?\\"\\n    \:keyword (unspaced open-keyword \#\\"[^\\\\(\\\\[\\\\{\\\\'\\\\^\\\\@\\\\`\\\\~\\\\\\"\\\\\\\\\\\\,\\\\s\\\\;\\\\)\\\\]\\\\}]*\\"); factorize with symbol\\n    \:int \#\\"(?\:[-+]?(?\:0(?\!\\\\.)|[1-9][0-9]*+(?\!\\\\.)|0[xX][0-9A-Fa-f]+(?\!\\\\.)|0[0-7]+(?\!\\\\.)|[1-9][0-9]?[rR][0-9A-Za-z]+(?\!\\\\.)|0[0-9]+(?\!\\\\.))(?\!/))\\"\\n    \:ratio \#\\"[-+]?[0-9]+/[0-9]*\\"\\n    \:float \#\\"[-+]?[0-9]+\\\\.[0-9]*+(?\:[eE][-+]?+[0-9]+)?+M?\\"\\n    \:anon-arg (unspaced open-anon-arg \#\\"(?\:[0-9|\\\\&])?+\\")\\n    \:char (unspaced open-char \#\\"(?\:newline|space|tab|backspace|formfeed|return|u[0-9|a-f|A-F]{4}|o[0-3]?+[0-7]{1,2}|.)\\")\\n    \:whitespace whitespace\\n    \:comment (unspaced open-comment \#\\"[^\\\\n]*\\")\\n    \:discard [open-discard \:expr]\\n    ))\\n(clojure.core/in-ns 'paredit.tests)" "(do (require 'paredit.tests) (binding [clojure.test/*test-out* *out*] (paredit.tests/pts)))" "(run-tests)" "(pts)" "(-> sexp \\"(salut)\\" pprint)" "(-> \\"(salut)\\" sexp  pprint)" ";; Switching to paredit.parser namespace" "(-> \\"(salut)\\" sexp  pprint)" "(use 'paredit.loc-utils)" "(-> \\"(salut)\\" sexp  node-text)" "step" "lr+/step" "lr+/reset" "reset" "(-> \\"(salut)\\" lr+/step)" "(def d [\\"(defn foo [bar\\", \\"           baz]\\" \\"  \\\\\\"hello\\\\\\")\\"])" "d" "(defn dser-ser [d] (-> (s/join \\"\\\\n\\" d) sexp node-text))" "(require '[clojure.string \:as s])" "(defn dser-ser [d] (-> (s/join \\"\\\\n\\" d) sexp node-text))" "(dser-ser d)" "(print (dser-ser d))" "d" "(def d0 (first d))" "d0" "(-> d0 (sexp zero d0) )" "(-> d0 (sexp lr+/zero d0) )" "(->> d0 (sexp lr+/zero) )" "(->> d0 (sexp lr+/zero) stitch)" "(let [a (sexp d0 lr+/zero)\\n      b (sexp a nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (lr+/stich a b))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (lr+/stitch a b))" "(require '[net.cgrand.parsley.fold \:as f])" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "step" "lr+/step" "(lr+/step d0)" "(lr+/step sexp d0)" "(lr+/step sexp lr+/zero d0)" "(sexp d0)" "(def d1 (second d))" "(sexp lr+/zero d0)" "(let [a (sexp lr+/zero d0)\\n      b (sexp d0 nil)]\\n  (f/stitch a b))" "(let [a (sexp lr+/zero d0)\\n      b (sexp d0 nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  b)" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/make-node (f/stitch a b)))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/make-node sexp (f/stitch a b)))" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(def d0 \\"(\\\\n\\")" "(def d1 \\")\\")" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(require '[net.cgrand.parsley.lrplus \:as lr+])" "(require '[net.cgrand.parsley.fold \:as f])" "(require '[net.cgrand.parsley.lrplus \:as l])" "(require '[net.cgrand.parsley.fold \:as f])" "(def d0 \\"(\\\\n\\")" "(def d1 \\")\\")" "(let [a (sexp lr+/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(require '[net.cgrand.parsley.lrplus \:as l])" "(require '[net.cgrand.parsley.fold \:as f])" "(def d0 \\"(\\\\n\\")" "(def d1 \\")\\")" "(let [a (sexp l/zero d0)\\n      b (sexp a nil)]\\n  (f/stitch a b))" "(let [a (sexp l/zero d0)\\n      b (sexp a d1)\\n      c (sexp b nil)]\\n  (f/stitch (f/stitch a b) c))" "(let [a (sexp l/zero d0)\\n      b (sexp a d1)\\n      c (sexp b nil)]\\n  (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2)))" "(let [a (sexp l/zero d0)\\n      b (sexp a d1)\\n      c (sexp b nil)]\\n  (node-text (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "d" "(dser-ser d)" "(defn dser-ser-inc [d] nil)" "(dser-ser-inc d)" "(doc reductions\\n  )" "(peek [1 2])" "(defn dser-ser-inc [d]\\n  (let [steps (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [] (concat [l/zero] d nil))]\\n    steps))" "(dser-ser-inc d)" "(concat [l/zero] d nil)" "(concat [l/zero] d [nil])" "(defn dser-ser-inc [d]\\n  (let [steps (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [] (concat [l/zero] d [nil]))]\\n    steps))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [] (concat [l/zero] d [nil])))]\\n    steps))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))]\\n    steps))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    stitch))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (f/make-node \:root (nth stitch 2))))" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (node-text (f/make-node \:root (nth stitch 2)))))" "(dser-ser-inc d)" "(deftest assert-incremental (is (\= (dser-ser d) (dser-ser-inc d))))" "(assert-incremental)" "d" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (node-text (f/make-node \:root (nth stitch 2)))))" "d" "(def d [\\"([\\" \\"])\\"])" "(assert-incremental)" "(def d [\\"([\\" \\"]) \\"])" "(assert-incremental)" "(dser-ser-inc d)" "(defn dser-ser-inc [d]\\n  (let [steps (first (reduce (fn [[steps l] r] (let [step (sexp l r)] [(conj steps step) step])) [[] l/zero] (concat d [nil])))\\n        stitch (reduce f/stitch steps)]\\n    (f/make-node \:root (nth stitch 2))))" "(dser-ser-inc d)" "(defn dser-ser [d] (-> (s/join \\"\\\\n\\" d) sexp))" "(dser-ser d)" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\"])\\")\\n      c (sexp b      nil)]\\n  (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2)))" "(def sexp (parser {\:main \:expr*} \:expr- \#{\:list \:vector}, \:list [\\"(\\" \:expr* \\")\\"], \:vector [\\"[\\" \:expr* \\"]\\"]))" "(sexp \\"([])\\")" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\"])\\")\\n      c (sexp b      nil)]\\n  (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2)))" "(def sexp (parser {\:main \:expr*} \\n                  \:expr- \#{\:list \:vector}, \\n                  \:list [\\"(\\" \:expr* \\")\\"], \\n                  \:vector [\\"[\\" \:expr* \\"]\\"]))" "(pprint (sexp \\"([])\\"))" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\"])\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"([\\")\\n      b (sexp a      \\")\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"(\\")\\n      b (sexp a      \\")\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"((\\")\\n      b (sexp a      \\"))\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]))\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch a b) c) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]\\")\\n      c (sexp b      nil)]\\n  (pprint (f/make-node \:root (nth (f/stitch (f/stitch (f/stitch a b) c) nil) 2))))" "(let [a (sexp l/zero \\"[[\\")\\n      b (sexp a      \\"]]\\")\\n      c (sexp b      nil)]\\n  (f/stitch (f/stitch a b) c))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"salut\\")" "(sexp \\"]\\")" "(sexp \\"\\\\\\"\\")" "(sexp \\"]\\")" "(sexp \\"[]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" "(sexp \\"[]\\")" ";; Loading file src\\\\paredit\\\\core.clj" "(sexp \\"[]\\")" "(sexp \\"]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" "(sexp \\"]\\")" ";; Loading file src\\\\paredit\\\\core.clj" "(sexp \\"]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley.clj" ";; Loading file src\\\\paredit\\\\core.clj" "(sexp \\"]\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"]\\")" "(sexp \\"[\\")" "(sexp \\"[]\\")" "(sexp \\"]\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "(sexp \\"]\\")" "(sexp \\"a\\")" "(net.cgrand.parsley.lrplus/step sexp net.cgrand.parsley.lrplus/zero \\"a\\")" "(sexp \\"a\\")" "(sexp \\"ab\\")" ";; Loading file src\\\\paredit\\\\parser.clj" "(dser-ser-inc [\\"(hello\\" \\"(little)\\" \\"world)\\"])" "(dser-ser-inc [\\"((\\" \\"))\\"])" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" "(dser-ser-inc [\\"((\\" \\"))\\"])" "(dser-ser-inc [\\"(\\" \\"(\\" \\"coucou\\" \\")\\" \\")\\"])" "(dser-ser-inc [\\"(\\" \\"[(\\" \\"coucou\\" \\")\\" \\"])\\"])" "(dser-ser-inc [\\"(\\" \\"[(\\" \\"coucou\\" \\")\\" \\"})\\"])" "(dser-ser-inc [\\"(\\" \\"[(\\" \\"coucou\\" \\")\\" \\"}\\"])" "(dser-ser-inc \\"((foo))\\")" "(dser-ser-inc [\\"((foo))\\"])" "(lu/node-text (dser-ser-inc [\\"((foo))\\"]))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")] (lu/node-text (dser-ser-inc [\\"((foo))\\"])))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")] (\= c (lu/node-text (dser-ser-inc [c]))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (seq (.split c \\"\\\\n\\"))] (\= c (lu/node-text (dser-ser-inc d))))" "(.split \\"salut\\\\nles\\\\ncopains\\")" "(.split \\"salut\\\\nles\\\\ncopains\\" \\"\\\\n\\")" "(seq (.split \\"salut\\\\nles\\\\ncopains\\" \\"\\\\n\\"))" "(clojure.string/split-lines \\"salut\\\\nles\\\\ncopains\\")" "(map \#(str % \\"\\\\n\\") (clojure.string/split-lines \\"salut\\\\nles\\\\ncopains\\"))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (\= c (lu/node-text (dser-ser-inc d))))" "(\= 1 1 1)" "(\= 1 2 1)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (\= c (lu/node-text (dser-ser-inc d)) (sexp c)))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(update-in {} [\:lines \\"id\\"] identity)" "(update-in {} [\:lines \\"id\\" \:qty] + 2)" "(update-in {} [\:lines \\"id\\"] (fnil update-in {\:qty 3}) [\:qty] + 2)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(require '[paredit.loc-utils \:as lu])" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp d)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(doc time)" "(source time)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(doc treeseq)" "(doc tree-seq)" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(sexp \\"salut\\")" "(sexp \\"(\\")" "(map? {})" "(nil? (\:tag {}))" "(sexp \\"(\\")" "(sexp \\"(())\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Loading file test\\\\paredit\\\\tests.clj" ";; Switching to paredit.tests namespace" "(pts)" ";; Switching to paredit.tests namespace" "(pts)" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" ";; Switching to paredit.parser namespace" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" "(doc into)" "(doc into\!)" "(find-doc \\"transient\\")" "(show into)" "(source into)" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" ";; Loading file src\\\\paredit\\\\parser.clj" "(let [c (slurp \\"C\:\\\\\\\\Users\\\\\\\\Laurent\\\\\\\\Downloads\\\\\\\\1.3.0-alpha6\\\\\\\\src\\\\\\\\clj\\\\\\\\clojure\\\\\\\\core.clj\\")\\n      d (map \#(str % \\"\\\\n\\") (clojure.string/split-lines c))]\\n  (println \\"Executing full parser\:\\")\\n  (dotimes [_ 10] (time (sexp c)))\\n  (println \\"Executing parser incrementally\:\\")\\n  (dotimes [_ 10] (time (dser-ser-inc d)))\\n  (\= c (lu/node-text (dser-ser-inc d)) (lu/node-text (sexp c))))" ";; Loading file test\\\\paredit\\\\tests.clj" "(pts)" ";; Switching to paredit.tests namespace" "(pts)"]
eclipse.preferences.version=1
