(ns ccw.e4.dsl
  "Eclipse 4 DSL namespace.
   You can consider using (:require [ccw.e4.dsl :refer-all])
   since the macros / functions exposed have been carefully chosen."
  (:require [ccw.e4.model   :as m]
            [ccw.eclipse    :as e]
            [ccw.core.trace :as t])
  (:import [ccw.util GenericHandler]))

(def ^:dynamic *load-key* "repl")

(defn handler-factory [context nsname name] 
  (GenericHandler. (str nsname "/" name)))

(defmacro defcommand' [command opts]
  `(def ~command
     (let [spec# (-> (merge
                       {:id ~(str *ns* "/" command)
                        :name ~(opts :name (str command))}
                       ~(dissoc opts :name))
                   (update-in [:transient-data]
                              assoc
                              "ccw/load-key" *load-key*)
                   (update-in [:tags]
                              (fnil conj #{})
                              "ccw"))]
       (t/format :e4 "spec#: %s" spec#)
       (m/merge-command! @m/app spec#))))

(defmacro defcommand
   "(defcommand reset-components \"Reset Components\" \"Cmd+U R\"
      [context] (repl/send '(user/reset)))
    is similar to
    (defcommand reset-components \"Reset Components\")
    (defkeybinding reset-components \"Cmd+U R\")
    (defhandler reset-components (fn [context] (repl/send '(user/reset)))).
  
    In the sugared form, the arguments vector for the handling function can 
    have zero args, or a context arg. If context arg is given, it's possible
    to use destructuring on it to immediately get value for key(s) of interest
    in the context.
    Keys can be any key acceptable by IEclipseContext, plus predefined keyword
    keys in ccw.core.e4.model/service-constants.

    Examples:
    (defcommand c2 \\\"command name/description\\\" \\\"Cmd+U S\\\"
      [] (repl/send '(user/reset)))
    (defcommand c1 \"command name/description\" \"Cmd+U R\"
      [context] (function-using context)))
    (defcommand c3 \"command name/description\" \"Cmd+U R\"
      [{:keys [:workbench :active-shell]}]
      (function-using workbench)
      (function-using active-shell))"
  [command name & [keybinding arg-vec & body :as rest]]
  (if-not rest
    `(defcommand' ~command ~(into {:name name} (apply hash-map rest)))
    `(do
       (defcommand' ~command ~{:name name})
       (defhandler ~command (fn ~(if (empty? arg-vec) [(gensym)] arg-vec) ~@body))
       (defkeybinding ~command ~keybinding))))

(defn- wrap-context
  "Wrap the Eclipse IContext so that:
   - destructuring is possible (extend clojure.lang.ILookup)
   - in addition to Strings and Classes, keywords referencing entries in
     ccw.e4.model/service-constants can be used"
  [eclipse-context]
  (reify clojure.lang.ILookup
    (valAt [this k]
      (if (or (= k :eclipse-context)
              (= k "org.eclipse.e4.core.contexts.IEclipseContext"))
        eclipse-context
        (m/context-key eclipse-context k)))
    (valAt [this k default-k]
      (if (or (= k :eclipse-context)
              (= k "org.eclipse.e4.core.contexts.IEclipseContext"))
        eclipse-context
        (m/context-key eclipse-context k default-k)))))

;;; TODO register for deletion in  m/*elements* (a set)
(defmacro defhandler
  "Defines a handler for the command. Takes a single additional argument
   that must be either a var symbol, or a closure that will be automatically
   bound to a var."
  [command var-symbol-or-closure]
  (let [cmd-id (str *ns* "/" command)
        id (str *ns* "/" "__" command "-handler")
        create-var? (not (symbol? var-symbol-or-closure))
        var-symbol (if create-var?
                     (symbol id)
                     var-symbol-or-closure)
        platform-uri (str "bundleclass://ccw.core/clojure/ccw.e4.dsl/handler-factory/"
                       (or (namespace var-symbol) (ns-name *ns*)) "/" (name var-symbol))]
    `(do
       ~(when create-var?
          `(def ~var-symbol
             ~(str "Var generated by CCW to hold the closure " var-symbol-or-closure)
             (fn [context#] (~var-symbol-or-closure (#'wrap-context context#)))))
       (let [spec# (-> {:contribution-URI ~platform-uri
                        :command ~cmd-id
                        :id ~id}
                     (update-in [:transient-data]
                       assoc
                       "ccw/load-key" *load-key*)
                     (update-in [:tags]
                       (fnil conj #{})
                       "ccw"))]
         (t/format :e4 "spec#: %s" spec#)
         (m/merge-handler! @m/app spec#)))))

;; TODO support options !!!
(defmacro defkeybinding 
  "Example:
   (defkeybinding greeter \"Ctrl+Alt+M\")
   (defkeybinding greeter \"Ctrl+Alt+M\"
     :scheme :emacs

   :scheme
   Predefined values 

 ... TODO document all this carefully ...

:sequence
\"M1+M2+P\"
\"Ctrl+Alt+M\"

:scheme key - see ccw.e4.model/key-binding-scheme

:context key - see ccw.e4.model/key-binding-context

:command

:platform ; Based on SWT/getPlatform ()
:win32
:gtk
:motif
:carbon
:photon

:locale
:en
:en_CA

"
  [command key-sequence & {:as opts}]
  `(let [spec# (-> (merge {:command ~command
                           :scheme  :default
                           :key-sequence ~key-sequence
                           :context :window}
                          ~opts)
                 (update-in [:transient-data]
                              assoc
                              "ccw/load-key" *load-key*)
                   (update-in [:tags]
                              (fnil conj #{})
                              "ccw"))]
     (t/format :e4 "spec#: %s" spec#)
     (m/merge-key-binding! @m/app spec#)))
